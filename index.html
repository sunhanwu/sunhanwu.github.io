<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Talk is cheap, show me the code!">
<meta property="og:type" content="website">
<meta property="og:title" content="SunPages">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SunPages">
<meta property="og:description" content="Talk is cheap, show me the code!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SunPages">
<meta name="twitter:description" content="Talk is cheap, show me the code!">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>SunPages</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SunPages</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/lab1/" class="post-title-link" itemprop="url">系统调用实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 17:01:20" itemprop="dateCreated datePublished" datetime="2019-09-12T17:01:20+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>6.7k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>6 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验一实验报告"><a href="#实验一实验报告" class="headerlink" title="实验一实验报告"></a>实验一实验报告</h1><blockquote>
<p>孙汉武    16281047    安全1601</p>
</blockquote>
<p>[TOC]</p>
<h2 id="Task-1-系统调用实验"><a href="#Task-1-系统调用实验" class="headerlink" title="Task 1 系统调用实验"></a>Task 1 系统调用实验</h2><h3 id="1-1-直接调用和汇编中断调用系统调用getpid"><a href="#1-1-直接调用和汇编中断调用系统调用getpid" class="headerlink" title="1.1 直接调用和汇编中断调用系统调用getpid"></a>1.1 直接调用和汇编中断调用系统调用getpid</h3><h4 id="C语言直接调用"><a href="#C语言直接调用" class="headerlink" title="C语言直接调用"></a>C语言直接调用</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>getpid_c.c</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = getpid();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源代码，得到可执行文件getpid_c</li>
<li>执行可执行文件，得到程序的pid</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171700.jpg" width="600"></p>
</li>
<li><p>查看getpid的系统调用号</p>
<p>64位Linux系统的系统调用列表保存在/usr/include/asm/unistd_64.h（32位在unistd_32.h）,查看该文件可得到<strong>getpid的系统调用号为39（32位系统的系统调用号为20）</strong></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171717.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171721.jpg" width="600"></p>
<p>通过上图可以看出，在64位系统中，有两套系统调用号的宏定义，除了64位正常的系统调用号表之外，还有一套用于向下兼容32位系统。</p>
<p>在Linux(debian)中，/usr/include/asm中有两个h文件，分别是unistd_32.h和unistd_64.这两个头文件中保存着系统调用号的宏定义， 当在程序代码中用到系统调用时，编译器会将上面提到的宏展开，展开后的代码实际上是将系统调用号放入ax后移用int 0x80使处理器转向系统调用入口，然后查找系统调用表，进而由内核调用真正的功能函数。 通过汇编代码可以看到中断向量号是0x80,而0x14是指系统调用号，在32位系统中，getpid系统调用号为20，所以是16进制的0x14，而64位系统的getpid的系统调用号为39.</p>
</li>
<li><p>系统调用号跟操作系统的位数(32或64)和不同的发行版本(debian和Ubuntu)有关，例如Ubuntu 64位机器上getpid的系统调用号是172，而网上查到Linux内核64位为39，32位为20。 出现不一致的原因是，在Linux64位系统中，对32位程序进行了兼容操作。之前的32位机中，系统通过开放0x80搭配系统调用号来实现用户程序使用系统调用功能。但在64位机中，已经不使用int 0x80作为触发系统调用的机制了，而使用syscall指令来触发。但为了保持兼容性，系统仍然支持int 0x80进行‘32位’风格的调用。自然我们的汇编代码使用20这个系统调用号，依然可以正确运行在64位机器上。</p>
</li>
</ol>
<h4 id="汇编中断调用"><a href="#汇编中断调用" class="headerlink" title="汇编中断调用"></a>汇编中断调用</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>getpid_asm.c</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">            <span class="keyword">pid_t</span> pid;  </span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl $0x14,%%eax\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"int $0x80\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl %%eax,%0\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             :<span class="string">"=m"</span>(pid)  </span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" current PID is : %u\n"</span>,pid);  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源码，得到可执行文件getpid_asm</li>
<li>执行可执行文件，得到程序的pid</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171732.jpg" width="600"></p>
</li>
<li><p>getpid的中断向量号</p>
<p>在汇编代码<code>int $0x80\n\t</code>可以看到getpid的<strong>中断向量号为0x80</strong></p>
</li>
</ol>
<h3 id="1-2-习题1-13"><a href="#1-2-习题1-13" class="headerlink" title="1.2 习题1.13"></a>1.2 习题1.13</h3><h4 id="使用C语言"><a href="#使用C语言" class="headerlink" title="使用C语言"></a>使用C语言</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>print_c.c</code>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源码，得到可执行文件print_c</li>
<li>执行文件，屏幕打印Hello World</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171737.jpg" width="600"></p>
</li>
</ol>
<h4 id="使用汇编"><a href="#使用汇编" class="headerlink" title="使用汇编"></a>使用汇编</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>print_asm.asm</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">section data</span><br><span class="line">msg db &quot;Hello World&quot;,0xA</span><br><span class="line">len equ $-msg</span><br><span class="line">section .text</span><br><span class="line">	global _start</span><br><span class="line">_start:</span><br><span class="line">	mov eax,4</span><br><span class="line">	mov ebx,1</span><br><span class="line">	mov ecx,msg</span><br><span class="line">	mov edx,len</span><br><span class="line">	int 0x80</span><br><span class="line">	mov eax,1</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	int 0x80</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编源码，得到对象文件print_asm.o</li>
<li>链接得到可执行文件print_asm</li>
<li>执行可执行文件print_asm,屏幕打印Hello World</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171743.jpg" width="600"></p>
</li>
</ol>
<h3 id="1-3-阅读pintos源码"><a href="#1-3-阅读pintos源码" class="headerlink" title="1.3 阅读pintos源码"></a>1.3 阅读pintos源码</h3><p>​    pintos中关于系统调用的源码以下部分。下面分别介绍他们各自的作用：</p>
<ol>
<li><p><code>/src/lib/user/syscall.c</code></p>
<ul>
<li>这个文件中以宏定义的形式定义了四种系统调用的方式，分别是不传递参数、传递一个参数、传递两个参数、传递三个参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall0(NUMBER) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall1(NUMBER, ARG0) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall2(NUMBER, ARG0, ARG1) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall3(NUMBER, ARG0, ARG1, ARG2) ...</span></span><br></pre></td></tr></table></figure>
<p>四个系统调用方式的中断向量号均为0x30.</p>
<ul>
<li>定义了20种系统调用函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">halt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function">pid_t <span class="title">exec</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait</span> <span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">create</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> initial_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filesize</span> <span class="params">(<span class="keyword">int</span> fd)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buffer, <span class="keyword">unsigned</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">unsigned</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seek</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> position)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">tell</span> <span class="params">(<span class="keyword">int</span> fd)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">mapid_t</span> mmap (<span class="keyword">int</span> fd, <span class="keyword">void</span> *addr);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">munmap</span> <span class="params">(<span class="keyword">mapid_t</span> mapid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chdir</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mkdir</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readdir</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> name[READDIR_MAX_LEN + <span class="number">1</span>])</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdir</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inumber</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的系统调用在下面的头文件中都有对应的系统调用号</p>
</li>
<li><p><code>/src/lib/syscallnr.h</code></p>
<p>这个文件中定义了系统调用列表，通过枚举类型定义了系统调用号</p>
<p>具体如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171749.jpg" width="600"></p>
</li>
<li><p><code>src/userprog/syscall.c</code></p>
<p>这个文件中只有两个函数<code>syscall_init</code>和<code>syscall_handler</code>,其中<code>syscall_init</code>是负责系统调用初始化工作的，<code>syscall_handler</code>是负责处理系统调用的</p>
<ul>
<li><p><code>syscall_init</code>函数</p>
<p>这个函数内部调用了<code>intr_register_int</code>函数，用于注册软中断从而调用系统调用处理函数</p>
</li>
</ul>
</li>
<li><p>下面是pintos系统调用的完整流程图</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171754.jpg" width="300"></p>
</li>
</ol>
<h2 id="Task-2-并发实验"><a href="#Task-2-并发实验" class="headerlink" title="Task 2 并发实验"></a>Task 2 并发实验</h2><h3 id="2-1-实验步骤"><a href="#2-1-实验步骤" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ol>
<li><p>编写<code>cpu.c</code>程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage:cpu&lt;string&gt;\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *str=argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码cpu.c，得到可执行文件cpu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc cpu.c -o cpu</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行cpu程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cpu A &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171801.jpg" width="600"></p>
</li>
<li><p>程序功能解释：</p>
<p>该程序的接受且仅能接受一个参数，当正确接受到参数的时候打印该参数，没有正确接受参数的时候，通过打印标准错误输出提示用户正确输入参数。</p>
</li>
</ol>
<h3 id="2-2-实验结果"><a href="#2-2-实验结果" class="headerlink" title="2.2 实验结果"></a>2.2 实验结果</h3><p>通过上面的实验可以观察到四个进程的运行顺序并没有规律。对于这种现象的解释如下：</p>
<ul>
<li>现代操作系统中进程的运行都是并发实现的，并不是像以前的单道批处理的操作系统那样，总是按照进程进入内存的先后顺序来执行，因此进程的运行的顺序并没有规律。</li>
<li>现代CPU一般都是多核CUP（我的电脑是四核），因此实验中的四个进程可能也不是简单的在一个CPU中并发，而有可能是在多个CPU核心中并行运行，也有可能某两个进程在一个CPU核心中并发运行，和其他的进程在不同的CPU核心中并行运行。所以进程的运行顺序并没有特别的规律。</li>
</ul>
<h2 id="Task-3-内存分配实验"><a href="#Task-3-内存分配实验" class="headerlink" title="Task 3 内存分配实验"></a>Task 3 内存分配实验</h2><h3 id="3-1-实验步骤"><a href="#3-1-实验步骤" class="headerlink" title="3.1 实验步骤"></a>3.1 实验步骤</h3><ol>
<li><p>编写<code>mem.c</code>程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	assert(p!=<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(%d) address pointed to by p: %p\n"</span>,getpid(),p);</span><br><span class="line">	*p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		*p=*p+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d) p: %d\n"</span>,getpid(),*p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码<code>mem.c</code>，得到可执行程序<code>mem</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mem.c -o mem</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行mem程序</p>
<ul>
<li>测试一：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171809.jpg" width="600"></p>
<ul>
<li>测试二：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171812.jpg" width="600"></p>
<ul>
<li>测试三：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171818.jpg" width="600"></p>
</li>
</ol>
<ol>
<li><p>程序功能解释</p>
<p>mem程序的功能是首先申请一个int大小的内存地址，并打印进程号和内存地址。之后就是对该内存地址保存的值进行循环累加操作</p>
</li>
</ol>
<h3 id="3-2-实验结果与结论"><a href="#3-2-实验结果与结论" class="headerlink" title="3.2 实验结果与结论"></a>3.2 实验结果与结论</h3><ol>
<li><p>实验现象</p>
<p>通过内存分配实验可以观察到如下现象：</p>
<ul>
<li>两个进程申请分配的内存地址有时一样，有时不一样，但是大概率出现的是不一样的。</li>
<li>对于每个进程而言，每个进程一直在该分配的内存空间进行累加操作，并且两个进程之间没有相互影响。</li>
<li>关闭地址空间随机化之后会发现每次执行两个进程申请的地址是相同的。</li>
</ul>
</li>
<li><p>原理解释</p>
<ul>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。进程需要用页表来记录哪些数据在物理地址，哪些不在，如果在的话在哪。</li>
<li>printf函数中%p打印的是虚拟地址</li>
<li>当关闭了地址空间随机化之后，在每个进程相当于有4G的独立虚拟内存，由于每个进程的程序是一模一样的，所以分配的地址肯定也一样。如果在申请的话应该就是顺序分配了。</li>
</ul>
</li>
<li><p>现象解释</p>
<p>由于每个进程都会有独立的4G虚拟内存，所以每个进程的内存地址在分配的时候可能相同，也可能不同，因为两个虚拟的地址之间没有任何关联。由于每个进程的虚拟地址是独立于其他进程的，通过页表将虚拟地址转换为真实地址，不论两个进程申请的虚拟内存地址是否相同，真实的物理地址一定是不一样的，所以两个进程对地址上的数值操作都是独立的。</p>
<p>但是关闭地址空间随机化之后两个进程的操作是完全一样的，加上有没有地址空间随机化的干扰，所以地址就是相同的</p>
</li>
</ol>
<h2 id="Task-4-共享问题"><a href="#Task-4-共享问题" class="headerlink" title="Task 4 共享问题"></a>Task 4 共享问题</h2><h3 id="4-1-实验步骤"><a href="#4-1-实验步骤" class="headerlink" title="4.1 实验步骤"></a>4.1 实验步骤</h3><ol>
<li><p>编写程序<code>thread.c</code>,源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> loops;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage: thread &lt;value&gt;\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	loops=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Initial value: %d\n"</span>,counter);</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Final value: %d\n"</span>,counter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码<code>thread.c</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o thread -lpthread thread.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行thread程序</p>
<ul>
<li><code>./thread 1000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171825.jpg" width="600"></p>
<ul>
<li><code>./thread 10000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171829.jpg" width="600"></p>
<ul>
<li><code>./thread_1 1000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171833.jpg" width="600"></p>
<ul>
<li><code>./thread_1 10000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171837.jpg" width="600"></p>
</li>
<li><p>程序功能解释</p>
<p>程序一个main进程下创建了两个线程，两个线程执行相同的操作，都是对loops变量进行自增操作。</p>
</li>
</ol>
<h3 id="4-2-实验结果与结论"><a href="#4-2-实验结果与结论" class="headerlink" title="4.2 实验结果与结论"></a>4.2 实验结果与结论</h3><ol>
<li><p>实验现象</p>
<p>可以看到当输入的参数比较小的时候，Final value等于Initial value的两倍，当输入的参数比较大的时候，Final value的值在Initial vlaue的一倍到两倍之间.并且在最后两个测试样例中可以看到两个线程操作的loops变量的内存地址是相同的。</p>
</li>
<li><p>原理解释</p>
<ul>
<li>由于两个线程在同一个进程中，并且访问操作的是共享的变量。如果每个线程对内存都是可读可写的话，就会发生读取脏数据的问题，即是线程A读取内存x的之后，对它进行+1，在线程A操作完成的数据写入x之前，线程B也读取了原来的数据，导致最终线程B写入的数据和A写入的一样，相当于两个线程只进行了一次操作。</li>
<li>为了解决上面所说的脏数据的问题，现代CPU一般采用了加锁的解决办法，通过加锁使另一个线程不能读取。</li>
<li>现代计算机都是多核心的，对于每个独立的CPU核心来说，都不会发生问题，但是不同CPU核心之间却依然有问题。</li>
</ul>
</li>
<li><p>现象解释</p>
<ul>
<li>当输入的参数比较小的时候，一个CPU的核心足够处理，就是单核CPU运行多线程，由于每个核心都有内存锁机制，所以计算结果没有错误</li>
<li>当输入的参数比较大的时候，使用多个CPU核心进行运算，就会发生读取脏数据的问题。</li>
</ul>
</li>
</ol>
<h2 id="5-实验疑问"><a href="#5-实验疑问" class="headerlink" title="5 实验疑问"></a>5 实验疑问</h2><ol>
<li><p>在Task3中，关闭了地址空间随机化之后，按照理论上将申请两个int的地址应该是连续的，所以我我就验证了一下，在原本的代码中申请两个int类型的地址，然后打印这两个地址，看这两个地址连不连续。代码如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171842.jpg" width="600"></p>
</li>
</ol>
<p>之后编译运行程序，结果如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171850.jpg" width="600"></p>
<p>发现地址并不是连续的，因此还有一下疑问：</p>
<ul>
<li>0x1fd5260这个地址指的是啥，就是每个进程的虚拟内存的地址吗？</li>
<li>我尝试过将int换成其他类型的，发现并没有发生变化，这是为啥呢？</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/2/" class="post-title-link" itemprop="url">ryu控制器实现集线器</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:54:28" itemprop="dateCreated datePublished" datetime="2019-09-12T15:54:28+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>12k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>11 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-Switching-Hub"><a href="#2-Switching-Hub" class="headerlink" title="2 Switching Hub"></a>2 Switching Hub</h1><p>[TOC]</p>
<h2 id="2-1-Switching-Hub"><a href="#2-1-Switching-Hub" class="headerlink" title="2.1 Switching Hub"></a>2.1 Switching Hub</h2><p>交换集线器有很多种不同的功能，在这我们看看拥有以下功能的集线器：</p>
<ul>
<li>能够学习集线器端口连接主机的MAC地址并将其保存在MAC地址表中</li>
<li>当收到MAC地址已知的报文时，将其转发到对应端口</li>
<li>当收到地址未知的报文的时候，进行泛洪</li>
</ul>
<p>让我们用ryu来实现这种功能的交换机</p>
<h2 id="2-2-openflow交换集线器"><a href="#2-2-openflow交换集线器" class="headerlink" title="2.2 openflow交换集线器"></a>2.2 openflow交换集线器</h2><p>openflow交换机可以实现下列功能通过接受控制器的指令(例如ryu控制器)</p>
<ul>
<li>改写接受数据包的地址或者从特定端口转发数据包</li>
<li>转发数据包到控制器(packet-In)</li>
<li>控制器从指定端口转发数据包(Packet-Out)</li>
</ul>
<p>可以实现组合了这些功能的交换集线器。<br>首先，您需要使用Packet-In功能来学习MAC地址。控制器可以使用Packet-In函数从交换机接收数据包。交换机分析收到的数据包，以了解主机的MAC地址和有关连接端口的信息。<br>学习之后，交换机传输接收的数据包。交换机调查数据包的目的MAC地址是否属于已知主机。根据调查结果，交换机执行以下处理。</p>
<ul>
<li>如果主机已经是已知主机…使用Packet-Out功能从连接的端口转发数据包。</li>
<li>如果主机是未知主机…使用Packet-Out功能执行泛洪</li>
</ul>
<p>以下使用附图以逐步的方式说明上述操作：</p>
<ol>
<li><p>初始状态</p>
<p>初始状态下流表为空，假设主机A连接端口1，主机B连接端口4，主机C连接端口3</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-10-133501.jpg" width="600"></div>
</li>
<li><p>主机A-&gt; 主机B</p>
<p>当数据包从主机A发送到主机B的时候，一个Packet-In消息将会被发送到控制器并且主机A的MAC地址将会被端口1学习。但是由于主机B的端口还不知道，因此数据包被泛洪到除了端口1以外的所有端口并且被主机B和主机C接受。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-10-133821.jpg" width="600"></div>

<ul>
<li><p>Packet-In：</p>
<p>入端口:1</p>
<p>目的主机：B</p>
<p>源主机：A</p>
</li>
<li><p>Packet-Out：</p>
<p>动作：输出：泛洪</p>
</li>
</ul>
</li>
<li><p>主机B-&gt;主机A</p>
<p>当主机B回应主机A的数据包返回的时候，由于已经有一个流表项被加入到流表中所以数据包将被转发到端口1，所以主机C将不会收到B发送的数据包</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-10-134423.jpg" width="600"></div>

<ul>
<li><p>Packet-In:</p>
<p>入端口：4</p>
<p>目的主机：主机A</p>
<p>源主机：主机B</p>
</li>
<li><p>Packet-Out:</p>
<p>动作：输出：端口1</p>
</li>
</ul>
</li>
<li><p>主机A-&gt;主机B</p>
<p>当主机A再一次向主机B发送数据包的时候，由于前面主机B回应数据包的时候，端口4已经学习到主机B的MAC地址，所以这一次数据包将会直接向端口4发送</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-10-134853.jpg" width="600"></div>

<ul>
<li><p>Packet-In</p>
<p>入端口：1</p>
<p>目的主机：主机B</p>
<p>源主机：主机A</p>
</li>
<li><p>Packet-Out：</p>
<p>动作：输出：端口4</p>
</li>
</ul>
</li>
</ol>
<p>下面我们来看看交换集线器的ryu源码实现</p>
<h2 id="2-3-使用Ryu实现交换集线器"><a href="#2-3-使用Ryu实现交换集线器" class="headerlink" title="2.3 使用Ryu实现交换集线器"></a>2.3 使用Ryu实现交换集线器</h2><p>源码在ryu/app/example_switch_13.py</p>
<p>除了上述之外，还有simple_switch.py（OpenFlow 1.0）和simple_switch_12.py（OpenFlow 1.2），具体取决于OpenFlow的版本，但我们看一下支持OpenFlow 1.3的实现</p>
<p>源代码很短，因此我们在下面显示了完整的源代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright (C) 2016 Nippon Telegraph and Telephone Corporation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or</span></span><br><span class="line"><span class="comment"># implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ryu.base <span class="keyword">import</span> app_manager</span><br><span class="line"><span class="keyword">from</span> ryu.controller <span class="keyword">import</span> ofp_event</span><br><span class="line"><span class="keyword">from</span> ryu.controller.handler <span class="keyword">import</span> CONFIG_DISPATCHER, MAIN_DISPATCHER</span><br><span class="line"><span class="keyword">from</span> ryu.controller.handler <span class="keyword">import</span> set_ev_cls</span><br><span class="line"><span class="keyword">from</span> ryu.ofproto <span class="keyword">import</span> ofproto_v1_3</span><br><span class="line"><span class="keyword">from</span> ryu.lib.packet <span class="keyword">import</span> packet</span><br><span class="line"><span class="keyword">from</span> ryu.lib.packet <span class="keyword">import</span> ethernet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSwitch13</span><span class="params">(app_manager.RyuApp)</span>:</span></span><br><span class="line">    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(ExampleSwitch13, self).__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># initialize mac address table.</span></span><br><span class="line">        self.mac_to_port = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">switch_features_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        datapath = ev.msg.datapath</span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br><span class="line"></span><br><span class="line">        <span class="comment"># install the table-miss flow entry.</span></span><br><span class="line">        match = parser.OFPMatch()</span><br><span class="line">        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,</span><br><span class="line">                                          ofproto.OFPCML_NO_BUFFER)]</span><br><span class="line">        self.add_flow(datapath, <span class="number">0</span>, match, actions)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_flow</span><span class="params">(self, datapath, priority, match, actions)</span>:</span></span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br><span class="line"></span><br><span class="line">        <span class="comment"># construct flow_mod message and send it.</span></span><br><span class="line">        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,</span><br><span class="line">                                             actions)]</span><br><span class="line">        mod = parser.OFPFlowMod(datapath=datapath, priority=priority,</span><br><span class="line">                                match=match, instructions=inst)</span><br><span class="line">        datapath.send_msg(mod)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        msg = ev.msg</span><br><span class="line">        datapath = msg.datapath</span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get Datapath ID to identify OpenFlow switches.</span></span><br><span class="line">        dpid = datapath.id</span><br><span class="line">        self.mac_to_port.setdefault(dpid, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># analyse the received packets using the packet library.</span></span><br><span class="line">        pkt = packet.Packet(msg.data)</span><br><span class="line">        eth_pkt = pkt.get_protocol(ethernet.ethernet)</span><br><span class="line">        dst = eth_pkt.dst</span><br><span class="line">        src = eth_pkt.src</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the received port number from packet_in message.</span></span><br><span class="line">        in_port = msg.match[<span class="string">'in_port'</span>]</span><br><span class="line"></span><br><span class="line">        self.logger.info(<span class="string">"packet in %s %s %s %s"</span>, dpid, src, dst, in_port)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># learn a mac address to avoid FLOOD next time.</span></span><br><span class="line">        self.mac_to_port[dpid][src] = in_port</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the destination mac address is already learned,</span></span><br><span class="line">        <span class="comment"># decide which port to output the packet, otherwise FLOOD.</span></span><br><span class="line">        <span class="keyword">if</span> dst <span class="keyword">in</span> self.mac_to_port[dpid]:</span><br><span class="line">            out_port = self.mac_to_port[dpid][dst]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out_port = ofproto.OFPP_FLOOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># construct action list.</span></span><br><span class="line">        actions = [parser.OFPActionOutput(out_port)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># install a flow to avoid packet_in next time.</span></span><br><span class="line">        <span class="keyword">if</span> out_port != ofproto.OFPP_FLOOD:</span><br><span class="line">            match = parser.OFPMatch(in_port=in_port, eth_dst=dst)</span><br><span class="line">            self.add_flow(datapath, <span class="number">1</span>, match, actions)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># construct packet_out message and send it.</span></span><br><span class="line">        out = parser.OFPPacketOut(datapath=datapath,</span><br><span class="line">                                  buffer_id=ofproto.OFP_NO_BUFFER,</span><br><span class="line">                                  in_port=in_port, actions=actions,</span><br><span class="line">                                  data=msg.data)</span><br><span class="line">        datapath.send_msg(out)</span><br></pre></td></tr></table></figure>

<p>让我们来看看各自实现的内容。</p>
<h3 id="2-3-1-类定义和初始化"><a href="#2-3-1-类定义和初始化" class="headerlink" title="2.3.1 类定义和初始化"></a>2.3.1 类定义和初始化</h3><p>为了实现一个ryu应用， ryu.base.app_manager.RyuApp被引用，此外，要使用OpenFlow 1.3，OpenFlow 1.3版本是为OFP_VERSIONS指定的。此外，定义了MAC地址表mac_to_port.</p>
<p>在OpenFlow协议中，已经定义了一些过程，例如Open-Flow交换机和控制器之间通信所需的握手。但是，由于Ryu的框架负责处理这些程序，因此在ryu app中不需要了解这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSwitch13</span><span class="params">(app_manager.RyuApp)</span>:</span></span><br><span class="line">    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(ExampleSwitch13, self).__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># initialize mac address table.</span></span><br><span class="line">        self.mac_to_port = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-事件处理函数"><a href="#2-3-2-事件处理函数" class="headerlink" title="2.3.2 事件处理函数"></a>2.3.2 事件处理函数</h3><p>对于Ryu，当接收到OpenFlow消息时，生成对应于该消息的事件。 Ryu应用程序实现了与希望接收的消息相对应的事件处理程序。事件处理程序定义了一个具有参数的事件对象的函数，并使用ryu.controller.handler.set_ev_cls装饰器来装饰。</p>
<p>set_ev_cls指定支持接收消息的事件类以及参数的OpenFlow交换机的状态。事件类名称为ryu.controller.ofp_event.EventOFP + &lt;OpenFlow消息名称&gt;。例如，在Packet-In消息的情况下，它变为EventOFPPacketIn。有关详细信息，请参阅Ryu的标题为API Reference的文档。对于状态，请指定以下之一或列表。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-053905.jpg" width="800"></div>

<ol>
<li><p>添加缺失流表项</p>
<p>在与OpenFlow交换机完成握手之后，将缺失流表项添加到交换机流表中以准备接收Packet-In消息。具体地，在接收到交换机特征（特征回复）消息时，添加表缺失流条目。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">switch_features_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        datapath = ev.msg.datapath</span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br></pre></td></tr></table></figure>

<p>在ev.msg中，存储与该事件对应的OpenFlow消息类的实例。在本例中，它是ryu.ofproto.ofproto_v1_3_parser.OFPSwitchFeatures。在msg.datapath中，存储与发出此消息的OpenFlow交换机对应的ryu.controller.controller.Datapath类的实例。Datapath类执行重要的处理，例如与OpenFlow交换机的实际通信以及与接收的消息相对应的事件的发布。<br>Ryu应用程序使用的datapath主要属性如下：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-054538.jpg" width="800"></div>

<p>Ryu应用程序中使用的Datapath类的主要方法如下：</p>
<p><code>send_msg（msg）</code></p>
<p>发送OpenFlow消息。 msg是与发送OpenFlow消息对应的ryu.ofproto.ofproto_parser.MsgBase的子类。<br>交换集线器并不特别使用收到的交换机功能消息本身。它被作为事件处理以获得添加表缺失流条目的定时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch_features_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        <span class="comment"># install the table-miss flow entry.</span></span><br><span class="line">        match = parser.OFPMatch()</span><br><span class="line">        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,</span><br><span class="line">                                          ofproto.OFPCML_NO_BUFFER)]</span><br><span class="line">        self.add_flow(datapath, <span class="number">0</span>, match, actions)</span><br></pre></td></tr></table></figure>

<p>Table-miss流条目具有最低（0）优先级，并且该条目匹配所有分组。在该条目的指令中，通过指定输出到控制器端口的输出动作，如果接收的数据包与任何正常流条目都不匹配，则发出Packet-In。生成空匹配以匹配所有数据包。匹配在OFPMatch类中表示。<br>接下来，生成OUTPUT操作类（OFPActionOutput）的实例以传输到控制器端口。控制器被指定为输出目的地，OFPCML_NO_BUFFER被指定为max_len，以便将所有数据包发送到控制器。<br>最后，为优先级指定0（最低），并执行add_flow（）方法以发送Flow Mod消息。 add_flow（）方法的内容将在后面的部分中介绍。</p>
<ol start="2">
<li><p>Packet-In 消息</p>
<p>创建Packet-In事件处理程序的处理程序，以接受具有未知目标的已接收数据包</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        msg = ev.msg</span><br><span class="line">        datapath = msg.datapath</span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br></pre></td></tr></table></figure>

<p>常用的OFPPacketIn类属性如下所示：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-061623.jpg" width="800"></div>

<ol start="3">
<li>更新MAC地址表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the received port number from packet_in message.</span></span><br><span class="line">        in_port = msg.match[<span class="string">'in_port'</span>]</span><br><span class="line"></span><br><span class="line">        self.logger.info(<span class="string">"packet in %s %s %s %s"</span>, dpid, src, dst, in_port)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># learn a mac address to avoid FLOOD next time.</span></span><br><span class="line">        self.mac_to_port[dpid][src] = in_port</span><br></pre></td></tr></table></figure>

<p>$\qquad$从OFPPacketIn匹配中获取接收端口（in_port）。目标MAC地址和发送方MAC地址使用Ryu的数据包库从接收到的数据包的以太网报头中获取。基于获取的发送方MAC地址和接收的端口号，更新MAC地址表。<br>$\qquad$为了支持与多个OpenFlow交换机的连接，MAC地址表被设计为针对每个OpenFlow交换机进行管理。datapath ID用于标识OpenFlow交换机。</p>
<ol start="4">
<li><p>判断转发目的端口</p>
<p>当MAC地址表中存在目的MAC地址时，使用相应的端口号。如果未找到，则生成OUTPUT操作类的实例，该实例指定输出端口的泛洪（OFPP_FLOOD）</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the destination mac address is already learned,</span></span><br><span class="line">        <span class="comment"># decide which port to output the packet, otherwise FLOOD.</span></span><br><span class="line">        <span class="keyword">if</span> dst <span class="keyword">in</span> self.mac_to_port[dpid]:</span><br><span class="line">            out_port = self.mac_to_port[dpid][dst]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out_port = ofproto.OFPP_FLOOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># construct action list.</span></span><br><span class="line">        actions = [parser.OFPActionOutput(out_port)]</span><br><span class="line">        <span class="comment"># install a flow to avoid packet_in next time.</span></span><br><span class="line">        <span class="keyword">if</span> out_port != ofproto.OFPP_FLOOD:</span><br><span class="line">            match = parser.OFPMatch(in_port=in_port, eth_dst=dst)</span><br><span class="line">            self.add_flow(datapath, <span class="number">1</span>, match, actions)</span><br></pre></td></tr></table></figure>

<p>$\qquad$如果找到目标MAC地址，则会在OpenFlow交换机的流表中添加一个条目。与添加Table-miss流条目一样，指定匹配和操作，并执行add_flow（）以添加流条目。</p>
<p>$\qquad$与Table-miss流条目不同，此次设置匹配条件。这次实现了交换集线器，指定了接收端口（in_port）和目标MAC地址（eth_dst）。例如，由端口1接收的寻址到主机B的分组是目标。<br>$\qquad$对于此次的流条目，优先级指定为1,值越大，优先级越高，因此，此处添加的流条目将在Table-miss流条目之前进行评估。<br>$\qquad$根据包含上述操作的摘要，将以下条目添加到流表中。将端口1接收到的主机B（目标MAC地址为B）的数据包传输到端口4。</p>
<blockquote>
<p>对于OpenFlow，在选项中规定了一个名为NORMAL的逻辑输出端口，当为输出端口指定NORMAL时，交换机的L2 / L3功能用于处理数据包。这意味着，通过指示将所有数据包输出到NORMAL端口，可以使交换机作为交换集线器运行。但是，我们使用OpenFlow实现每个处理</p>
</blockquote>
<ol start="5">
<li>添加流表项</li>
</ol>
<p>Packet-In处理程序的处理尚未完成，但这里将介绍添加流表项的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_flow</span><span class="params">(self, datapath, priority, match, actions)</span>:</span></span><br><span class="line">        ofproto = datapath.ofproto</span><br><span class="line">        parser = datapath.ofproto_parser</span><br><span class="line"></span><br><span class="line">        <span class="comment"># construct flow_mod message and send it.</span></span><br><span class="line">        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,</span><br><span class="line">                                             actions)]</span><br></pre></td></tr></table></figure>

<p>对于流表项，设置指示目标数据包条件的匹配，以及指示对数据包的操作，条目优先级和有效时间的指令。在交换集线器实现中，Apply Actions用于设置指令，以便立即使用指定的操作。<br>最后，通过发出Flow Mod消息向流表添加条目</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_flow</span><span class="params">(self, datapath, priority, match, actions)</span>:</span></span><br><span class="line">        mod = parser.OFPFlowMod(datapath=datapath, priority=priority,</span><br><span class="line">                                match=match, instructions=inst)</span><br><span class="line">        datapath.send_msg(mod)</span><br></pre></td></tr></table></figure>

<p>与Flow Mod消息对应的类是OFPFlowMod类。生成OFPFlowMod类的实例，并使用Datapath.send_msg（）方法将消息发送到OpenFlow交换机。OFPFlowMod类的构造函数有很多参数。其中许多通常可以是默认值。括号内是默认值。</p>
<ul>
<li><p>datapath</p>
<p>这是支持流表操作的OpenFlow交换机的Datapath类实例。通常，指定从传递给处理程序的事件中获取的那个，例如Packet-In消息。</p>
</li>
<li><p>cookie(0)</p>
<p>控制器指定的可选值，可在更新或删除条目时用作过滤条件。这不用于数据包处理。</p>
</li>
<li><p>cookie_mask(0)</p>
<p>更新或删除条目时，如果指定了0以外的值，则使用条目的cookie值将其用作操作目标条目的过滤器</p>
</li>
<li><p>table_id</p>
<p>指定操作目标流表的表ID</p>
</li>
<li><p>command (ofproto_v1_3.OFPFC_ADD)、</p>
<p>指定要执行的操作。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-064100.jpg" width="600"></div>
</li>
<li><p>idle_timeout(0)</p>
<p>指定此条目的有效期，以秒为单位。如果未引用该条目并且idle_timeout指定的时间过去，则删除该条目。引用该条目时，将重置已用时间。<br>删除条目后，会向控制器发送Flow Removed消息。</p>
</li>
<li><p>hard_timeout (0)</p>
<p>指定此条目的有效期，以秒为单位。与idle_timeout不同，使用hard_timeout，即使引用了条目，也不会重置已用时间。也就是说，无论条目的引用如何，都在指定的时间过去时删除该条目。<br>与idle_timeout一样，当删除条目时，将发送Flow Removed消息。</p>
</li>
<li><p>priority(0)</p>
<p>指定此条目的优先级顺序。值越大，优先级越高。</p>
</li>
<li><p>buffer_id (ofproto_v1_3.OFP_NO_BUFFER)</p>
<p>指定OpenFlow交换机上缓冲的数据包的缓冲区ID。在分组输入消息中通知缓冲区ID，并且当指定的处理与发送两个消息时相同，即，为输出端口和流模式消息指定了OFPP_TABLE的分组输出消息。当命令为OFPFC_DELETE或OFPFC_DELETE_STRICT时，将忽略此项。<br>如果未指定缓冲区ID，请设置OFP_NO_BUFFER</p>
</li>
<li><p>out_port</p>
<p>如果命令为OFPFC_DELETE或OFPFC_DELETE_STRICT，则输出端口将过滤目标条目。如果命令为OFPFC_ADD，OFPFC_MODIFY或OFPFC_MODIFY_STRICT，则忽略该命令。<br>要禁用输出端口的过滤，请指定OFPP_ANY。</p>
</li>
<li><p>out_group(0)</p>
<p>与out_port一样，按输出组过滤。要禁用，请指定OFPG_ANY。</p>
</li>
<li><p>flag(0)</p>
<p>您可以指定以下标志组合</p>
</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-064628.jpg" width="800"></div>

<ul>
<li><p>match(None)</p>
<p>具体的match</p>
</li>
<li><p>instructions ([])</p>
<p>指定指令列表</p>
</li>
</ul>
<ol start="6">
<li><p>数据包转移</p>
<p>现在我们返回Packet-In处理程序并解释最终处理。无论是否从MAC地址表中找到目的地MAC地址，最后都发出分组输出消息并传送接收的分组。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_packet_in_handler</span><span class="params">(self, ev)</span>:</span></span><br><span class="line">        out = parser.OFPPacketOut(datapath=datapath,</span><br><span class="line">                                  buffer_id=ofproto.OFP_NO_BUFFER,</span><br><span class="line">                                  in_port=in_port, actions=actions,</span><br><span class="line">                                  data=msg.data)</span><br><span class="line">        datapath.send_msg(out)</span><br></pre></td></tr></table></figure>

<p>与Packet-Out消息对应的类是OFPPacketOut类。 OFPPacketOut的构造函数的参数如下：</p>
<ul>
<li><p>datapath</p>
<p>指定OpenFlow交换机对应的Datapath类的实例</p>
</li>
<li><p>buffer_id</p>
<p>指定OpenFlow上缓冲的数据包的缓冲区ID。如果未缓冲，则指定OFP_NO_BUFFER。</p>
</li>
<li><p>in_port</p>
<p>指定接收数据包的端口。如果不是收到的数据包，则指定OFPP_CONTROLLER</p>
</li>
<li><p>actions</p>
<p>指定操作列表。</p>
</li>
<li><p>data</p>
<p>指定数据包的二进制数据。当为buffer_id指定OFP_NO_BUFFER时使用此方法。使用OpenFlow交换机的缓冲区时，省略</p>
</li>
</ul>
<p>$\qquad$在交换集线器实现中，已经为buffer_id指定了Packet-In消息的buffer_id。如果已禁用Packet-In消息的buffer-id，则为发送数据包的数据指定收到的Packet-In数据包。</p>
<h2 id="2-4-ryu应用执行"><a href="#2-4-ryu应用执行" class="headerlink" title="2.4 ryu应用执行"></a>2.4 ryu应用执行</h2><p>因为xterm是从Mininet启动的，所以使用mn命令启动Mininet环境。要构建的环境具有简单的结构，具有三个主机和一个交换机。<br>mn命令参数如下：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-11-070404.jpg" width="600"></div>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/lab5/" class="post-title-link" itemprop="url">文件系统实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:53:40" itemprop="dateCreated datePublished" datetime="2019-09-12T15:53:40+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>21k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>19 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验五-文件系统-实验报告"><a href="#实验五-文件系统-实验报告" class="headerlink" title="实验五-文件系统 实验报告"></a><center>实验五-文件系统 实验报告</center></h1><blockquote>
<center>孙汉武    16281047    安全1601</center>
</blockquote>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab5" target="_blank" rel="noopener">实验源码链接:https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab5</a></p>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/raw/master/lab5/lab5.pdf" target="_blank" rel="noopener">pdf下载</a></p>
<h2 id="一-概要设计"><a href="#一-概要设计" class="headerlink" title="一 概要设计"></a>一 概要设计</h2><p>$\qquad$本次的实验的实验目的是在模拟的I/O系统中开发一个简单的文件系统，并且提供一些借口给用户用于交互，从实验目的可以看出，本实验重点在于构建模拟的I/O系统和基于I/O系统的文件系统。所以，在概要设计中，将详细介绍模拟I/O系统的设计、文件系统的设计和测试模块的设计这三个部分。</p>
<h3 id="1-1-I-O系统设计"><a href="#1-1-I-O系统设计" class="headerlink" title="1.1 I/O系统设计"></a>1.1 I/O系统设计</h3><p> $\qquad$IO系设计首先要解决的是需要有一个物理磁盘，为此，我们通过定义一个三维的磁盘块结构体数组表示物理磁盘，该结构体数组的每一个维度分别表示物理磁盘中的一个层次。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-082923.jpg" width="400"></div>

<p>$\qquad$我们模拟的磁盘如上所示，第一维表柱面，第二维表示磁头，最后一维表示扇区。磁盘定义好之后需要定义一系列的函数用于操作磁盘。IO系统工作的流程和结构如下所示：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-090054.jpg" width="400"></div>

<p>$\qquad$IO系统提供的操作磁盘的API如上图所示，主要分为五个大类，分别是初始化磁盘、磁盘搜索、磁盘读写、磁盘位图处理、磁盘与文件转化等，下面的表格分别介绍了各个类别提供的API的详细信息。</p>
<ul>
<li>磁盘初始化</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InitDisk()</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">初始化磁盘数组</td>
</tr>
</tbody></table>
<ul>
<li>磁盘搜索 </li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SearchBitMap</td>
<td align="center">无</td>
<td align="center">空闲磁盘块号</td>
<td align="center">搜索并返回最小的空闲磁盘块号</td>
</tr>
</tbody></table>
<ul>
<li>磁盘读写</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ReadBlock</td>
<td align="center">int i :指定读取的磁盘块号<br>char *p ：返回读取内容</td>
<td align="center">无</td>
<td align="center">读取指定磁盘块内容</td>
</tr>
<tr>
<td align="center">WriteBlock</td>
<td align="center">int i：指定写入的磁盘块号<br>char *p:写入的内容</td>
<td align="center">无</td>
<td align="center">写入内容到指定磁盘块</td>
</tr>
</tbody></table>
<ul>
<li>磁盘位图处理</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InitBitMap</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">初始化位图</td>
</tr>
<tr>
<td align="center">ChangeBitMap</td>
<td align="center">int i:要修改的磁盘块号<br>char p:修改的内容(Y/N)</td>
<td align="center">无</td>
<td align="center">修改位图每一位的值</td>
</tr>
</tbody></table>
<ul>
<li>磁盘与文件的转化</li>
</ul>
<p>$\qquad$由于是在内从中创建数组模拟物理磁盘，所以这种方式无法模拟物理磁盘断电不丢失信息的特性。为了满足这个要求，设计一下的函数用于将数组中的信息存储到文件中和文件中读取相关信息。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DiskToFile</td>
<td align="center">char filename[]：文件名</td>
<td align="center">无</td>
<td align="center">将磁盘数组信息存储为文件</td>
</tr>
<tr>
<td align="center">FileToDsik</td>
<td align="center">char filename[]:文件名</td>
<td align="center">无</td>
<td align="center">将文件读取到磁盘数组中</td>
</tr>
</tbody></table>
<h3 id="1-2-文件系统设计"><a href="#1-2-文件系统设计" class="headerlink" title="1.2 文件系统设计"></a>1.2 文件系统设计</h3><p>$\qquad$在上一节设计的IO系统的基础上，进行文件系统的设计，文件系统设计时有两个很重要的概念，分别是文件描述符和目录项这两个数据结构的定以及在这个基础上进行的一系列操作。</p>
<ol>
<li>用户接口</li>
</ol>
<p>$\qquad$文件系统提供了一系列便于用户操作的接口，用于对文件系统中的文件进行增删改查，具体接口信息如下：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">create</td>
<td align="center">char filename[]</td>
<td align="center">无</td>
<td align="center">创建文件</td>
</tr>
<tr>
<td align="center">destroy</td>
<td align="center">char filename[]</td>
<td align="center">无</td>
<td align="center">删除文件</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">char  filename[]</td>
<td align="center">无</td>
<td align="center">打开文件</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">char filename[]</td>
<td align="center">无</td>
<td align="center">关闭文件</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">index:文件描述符号<br>mem_area:读取的位置<br>count:读取的字节数</td>
<td align="center">无</td>
<td align="center">读取文件内容</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">index:文件描述符<br>mem_area:x写入的位置<br>count:写入字节数</td>
<td align="center">无</td>
<td align="center">向文件中写入信息</td>
</tr>
<tr>
<td align="center">lseek</td>
<td align="center">index:文件描述符 号<br>pos:位置</td>
<td align="center">无</td>
<td align="center">移动文件读写指针</td>
</tr>
</tbody></table>
<p>$\qquad$文件系统提供的上述接口已经可以满足对文件系统的常规操作。上面的接口中提到的文件描述符在文件系统中是一个很重要的概念，每个文件都必须 通过一个文件描述符来表示 ，其文件长度信息 ，文件存储位置等常规 信息都存储在文件描述符中。</p>
<p>$\qquad$为此我设计了一个结构体<code>FileDescriptor</code>用于表示文件描述符，并且将该结构体进行4字节对齐，方便后续以二进制形式存储在文件中。</p>
<p>$\qquad$在文件系统中另外一个重要概念就是目录，因此定义一个结构体表示目录项，用于存储文件名和文件描述符号。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-100056.jpg" width="400"></div>

<p>$\qquad$文件描述符和目录项在磁盘中存储的位置如上图所示，其中磁盘块的第一和第二块用于存储磁盘块的位图，第3-13块用于存储文描述符，14块用于存储目录项信息。</p>
<p>$\qquad$经过4字节对齐之后的文件描述符结构体大小为24字节，而一个磁盘块有512字节存储空间，所以一个磁盘块最多存储21个文件描述符，而本实验中设置的用于存储文件描述符的磁盘块为10块，最多可以存储210个文件描述符。</p>
<p>$\qquad$目录也可以看做一个文件，所以也会占据一个文件文件描述符，本实验中目录占用的文件描述符是第一个文件描述符。并且存储目录信息的磁盘是14号磁盘，经过4字节对齐的目录项结构体大小为16B，所以最多有32个文件。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-102802.jpg" width="400"></div>

<p>$\qquad$文件系统的API如上图所示，我将文件系统的API分为初始化、用户接口、搜索和其他这四类，每一个大类具体的函数如下表所示：</p>
<ul>
<li>文件系统初始化</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InitFileDescriptor</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">初始化文件描述符数组</td>
</tr>
<tr>
<td align="center">InitMenu</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">初始化目录项数组</td>
</tr>
</tbody></table>
<ul>
<li>文件系统用户接口(上面已经介绍过，不在赘述)</li>
<li>文件系统搜索</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SearchFileDescriptor</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">搜索空闲的文件描述符</td>
</tr>
<tr>
<td align="center">SearchMenuItem</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">搜索空闲的目录项</td>
</tr>
</tbody></table>
<ul>
<li>其他</li>
</ul>
<p>$\qquad$这部分主要定义的是一些方便操作的函数，例如将文件描述符数组写入磁盘块中去，将目录系统写入磁盘块等等。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DiskToFileDescriptor</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">从磁盘块中恢复文件描述符数组</td>
</tr>
<tr>
<td align="center">FileDescriptorToDisk</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">将文件描述符数组信息写入磁盘块</td>
</tr>
<tr>
<td align="center">MenuToFileDescriptor</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">将目录项数组写入第一个文件描述符</td>
</tr>
<tr>
<td align="center">FileDescriptorToMenu</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">将第一个文件描述符内容恢复到目录项数组</td>
</tr>
</tbody></table>
<p>$\qquad$到此，文件系统部分所有数据结构和函数均介绍完毕</p>
<h3 id="1-3-菜单系统设计"><a href="#1-3-菜单系统设计" class="headerlink" title="1.3 菜单系统设计"></a>1.3 菜单系统设计</h3><p>$\qquad$完成IO系统的设计和文件系统的设计，需要对上述的功能设计一个外壳程序，即一个用户界面便于使用，总结文件系统的所有功能，设计的菜单驱动程序包含如下两层菜单。</p>
<ol>
<li>一级菜单<ul>
<li>创建新磁盘系统</li>
<li>从文件中恢复历史磁盘系统</li>
</ul>
</li>
<li>二级菜单<ul>
<li>查看目录</li>
<li>创建文件</li>
<li>删除文件</li>
<li>打开文件</li>
<li>修改文件</li>
<li>查看位图</li>
<li>保存磁盘</li>
<li>退出</li>
</ul>
</li>
</ol>
<h2 id="二-I-O系统"><a href="#二-I-O系统" class="headerlink" title="二 I/O系统"></a>二 I/O系统</h2><h3 id="2-1-磁盘块结构体"><a href="#2-1-磁盘块结构体" class="headerlink" title="2.1 磁盘块结构体"></a>2.1 磁盘块结构体</h3><blockquote>
<p>I/O系统部分全部代码都在IO.h文件中</p>
</blockquote>
<ol>
<li>磁盘块结构体BLOCK</li>
</ol>
<p>$\qquad$设计整个I/O系统的基础就是设计模拟磁盘块的结构体，并用结构体数组代表磁盘，通过定义三维的结构体数组来模拟出整个磁盘的物理结构，这三维分别代表柱面、磁头和扇区。下面是磁盘块(逻辑块)结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Content[<span class="number">512</span>]; <span class="comment">//逻辑块存储的内容</span></span><br><span class="line">    <span class="keyword">int</span> BlockNnum; <span class="comment">//逻辑块号</span></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// 柱面号</span></span><br><span class="line">    <span class="keyword">int</span> h; <span class="comment">//磁头号</span></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//扇区号</span></span><br><span class="line">&#125;BLOCK;</span><br></pre></td></tr></table></figure>

<p>$\qquad$磁盘块结构体最重要的成员就是用于存储信息Content，这是一个字符型数组，大小为512个字节。而另外的逻辑块号，柱面号，磁头号和扇区号这四个成员是为了便于后续程序设计的。下面的表格详细表示每个成员的信息：</p>
<table>
<thead>
<tr>
<th align="center">成员名</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Content</td>
<td align="center">字符数组</td>
<td align="center">512字节</td>
<td align="center">存储磁盘块内容</td>
</tr>
<tr>
<td align="center">BlockNum</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">磁盘块的逻辑块号</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">柱面号</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">磁头号</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">扇区号</td>
</tr>
</tbody></table>
<ol start="2">
<li>物理磁盘(BLOCK数组)</li>
</ol>
<p>$\qquad$磁盘块结构体定义好之后，可以模拟出一个磁盘块，但是完整的磁盘是一个三维的磁盘块结构体数组构成的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 10 <span class="comment">// 柱面号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H 10 <span class="comment">//磁头号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 10 <span class="comment">//扇区号</span></span></span><br><span class="line">BLOCK ldisk[C][H][B];<span class="comment">//磁盘模型</span></span><br></pre></td></tr></table></figure>

<p>$\qquad$在<code>IO.h</code>直接定义ldisk数组，模拟物理磁盘。并且通过宏定义C、H和B三个量调整物理磁盘的大小。</p>
<ol start="3">
<li>磁盘初始化函数</li>
</ol>
<p>$\qquad$在模拟物理磁盘的三维结构体数组定义好之后，需要对该数组进行初始化，对数组中的每个元素，即每个磁盘块进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitDisk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ldisk[i][j][k].c=i;</span><br><span class="line">                ldisk[i][j][k].h=j;</span><br><span class="line">                ldisk[i][j][k].b=k;</span><br><span class="line">                ldisk[i][j][k].BlockNnum=DiskNumToBlock(i,j,k);<span class="comment">//计算对应的逻辑块号</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$可以看到对磁盘块数组进行初始化的方式非常简单，主要包含两个工作，一个就是顺序编号其柱面号、磁头号和扇区号；还有一个功能就是计算逻辑块号</p>
<h3 id="2-2-磁盘读写"><a href="#2-2-磁盘读写" class="headerlink" title="2.2 磁盘读写"></a>2.2 磁盘读写</h3><p>$\qquad$说道磁盘系统的API函数，最重要的两个函数就是对磁盘块进行读写操作的两个函数。下面分别介绍这个两个函数的详细内容。</p>
<ol>
<li>读磁盘块函数：<code>ReadBlock(int i,char *p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadBlock</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,h,b;<span class="comment">//磁盘的柱面 磁道 扇区</span></span><br><span class="line">    c = i % (H*B);<span class="comment">//</span></span><br><span class="line">    h = (i -c*H*B) % B;<span class="comment">//</span></span><br><span class="line">    b = i-c*H*B - h*B;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,ldisk[c][h][b].Content,<span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$3-6行计算逻辑号为i的逻辑块在磁盘系统中的柱面号、磁头号和扇区号；</p>
<p>$\qquad$第7行可以看作此函数的核心操作，完成的工作就是将制定磁盘块中的内容通过<code>memcpy</code>函数复制到字符型指针p中去。</p>
<blockquote>
<p>注意：这里不能使用strcpy函数复制字符串，因为strcpy函数在复制的时候会遇到第一个\0就会停止复制，但是磁盘块中存储的信息可能不是连续的字符串，可能是一些其他信息，例如文件描述符等，这个时候就会碰到一些空位置用\0补充，但是后面还有有用的信息，所以使用memcp函数，按照指定字节数复制，而不考虑\0的问题</p>
</blockquote>
<ol start="2">
<li>写磁盘块函数：<code>WriteBlock(int i,char *p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,h,b;</span><br><span class="line">    b = i % B;</span><br><span class="line">    h = ((i - b) / B) % H;</span><br><span class="line">    c = (i -b -h*B) / (H*B);</span><br><span class="line">    b = i -c*H*B -h*B ;</span><br><span class="line">    <span class="built_in">memcpy</span>(ldisk[c][h][b].Content,p,<span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$3-6行操作与上面相似，就是计算柱面号、磁头号和扇区号这三个参数</p>
<p>$\qquad$8第8行主要用于将参数p指针中的内容复制到磁盘块中</p>
<h3 id="2-3-磁盘位图"><a href="#2-3-磁盘位图" class="headerlink" title="2.3 磁盘位图"></a>2.3 磁盘位图</h3><p>$\qquad$为了方便查询磁盘中的空闲磁盘块，直接遍历查询的效率非常低，所以本实验中采用了位图的方式来表示磁盘块的占用与否，一个字符表示一个磁盘块的占用与否，其中Y表示占用，N表示空闲。而位图编号就是磁盘块的逻辑块号数。</p>
<ol>
<li>初始化磁盘位图函数：<code>InitBitMap(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第0，1号磁盘已经被占用</span></span><br><span class="line">    ChangeBitMap(<span class="number">0</span>,<span class="string">'Y'</span>);</span><br><span class="line">    ChangeBitMap(<span class="number">1</span>,<span class="string">'Y'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;C*H*B;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ChangeBitMap(i,<span class="string">'N'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$可以看到初始化函数中将磁盘块数量(C*B*H)个单位的字符修改为N，表示为占用。4-5两行表示第一块和第二块物理磁盘初始化就被占用，因为这两块物理磁盘用于存储位图。</p>
<ol start="2">
<li>修改位图函数：<code>ChangeBitMap(int i,char p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeBitMap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">512</span>)</span><br><span class="line">        ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[i] = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[i<span class="number">-512</span>] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$这个函数使用一个if结构判断逻辑块号，如果大于512的话存入 第二个磁盘块中，否则存入第一个磁盘块中。</p>
<h3 id="2-4-磁盘文件的存取"><a href="#2-4-磁盘文件的存取" class="headerlink" title="2.4 磁盘文件的存取"></a>2.4 磁盘文件的存取</h3><p>$\qquad$在内存中定义的磁盘块结构体数组无法满足断电后信息还能保存的特性，因此需要内存中的磁盘块数组中的信息保存到文件中去，需要的时候再加载出来。</p>
<ol>
<li>将磁盘数组保存为文件：<code>DiskToFile(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskToFile</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    FileDescriptorToDisk();</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(filename,<span class="string">"wb"</span>);</span><br><span class="line">    <span class="comment">//判断fp打开成功</span></span><br><span class="line">    <span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File Open Fail"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历，将磁盘块内容写入二进制文件中去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">                <span class="comment">//以二进制的形式写入二进制文件中</span></span><br><span class="line">                fwrite(ldisk[i][j][k].Content,<span class="number">512</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$3-5行以二进制写入形式打开指定文件名的文件</p>
<p>$\qquad$7-11行判断文件是否打开成功，没打开成功的话输出错误信息并退出程序</p>
<p>$\qquad$13-17行，遍历磁盘数组，以二进制的形式将磁盘块中存储的内容写入到文件中去。最后关闭文件</p>
<ol start="2">
<li>加载文件到磁盘块数组：<code>FileToDisk(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件中读取数据，恢复磁盘系统</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileToDisk</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line">     fp = fopen(filename,<span class="string">"rb"</span>);</span><br><span class="line">     <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"File Open Fail"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">int</span> c,h,b;</span><br><span class="line">         b = index % B;</span><br><span class="line">         h = ((index - b) / B) % H;</span><br><span class="line">         c = (index -b -h*B) / (H*B);</span><br><span class="line">         b = index -c*H*B -h*B ;</span><br><span class="line">         fread(ldisk[c][h][b].Content,<span class="number">512</span>,<span class="number">1</span>,fp);</span><br><span class="line">         ldisk[c][h][b].c = c;</span><br><span class="line">         ldisk[c][h][b].h = h;</span><br><span class="line">         ldisk[c][h][b].b = b;</span><br><span class="line">         index++;</span><br><span class="line">     &#125;</span><br><span class="line">     fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$这段程序除了打开文件等常规操作之外，核心的代码是while循环中的，首先计算逻辑号为index的逻辑块的柱面号、磁头号和扇区号；之后每次读取512字节数据到对应磁盘块数组中的磁盘块中去。</p>
<h3 id="2-5-空闲磁盘块搜索"><a href="#2-5-空闲磁盘块搜索" class="headerlink" title="2.5 空闲磁盘块搜索"></a>2.5 空闲磁盘块搜索</h3><p>$\qquad$2.3节中定义了位图，用于存储磁块的空闲状态，所以当需要使用磁盘块的时候 ，需要查询位图找到一个空闲磁盘块号返回。</p>
<ol>
<li>空闲磁盘块搜索函数：`SearchBitMap(void)：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索位图，找到空闲磁盘块号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>;i&lt;C*H*B;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">512</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[i]==<span class="string">'N'</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[i<span class="number">-512</span>]==<span class="string">'N'</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $\qquad$本函数的实现方式就是通过遍位图知道找到一个空闲的磁盘块。不过由于所有的位图 信息并不是全部存储在一个磁盘块中，而是两个磁盘块，所以在遍历的时候需要判断在哪个磁盘块。</p>
<h2 id="三-文件系统"><a href="#三-文件系统" class="headerlink" title="三 文件系统"></a>三 文件系统</h2><blockquote>
<p>文件系统全部代码存储在FS.h文件中</p>
</blockquote>
<h3 id="3-1-文件描述符结构体-amp-目录项结构体"><a href="#3-1-文件描述符结构体-amp-目录项结构体" class="headerlink" title="3.1 文件描述符结构体 &amp; 目录项结构体"></a>3.1 文件描述符结构体 &amp; 目录项结构体</h3><ol>
<li><p>文件描述符结构体定义</p>
<p>$\qquad$文件系统采用文件描述符来记录每一个文件的信息，下面是文件描述符的结构体定义：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileDescriptor</span> //此文件描述符总共占据磁盘24字节</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Length;<span class="comment">//文件长度</span></span><br><span class="line">    <span class="keyword">int</span> DiskNum[DiskNumLen]; <span class="comment">//第二个3只是表示每个磁盘块好最大长度是3位</span></span><br><span class="line">    <span class="keyword">int</span> Num; <span class="comment">//文件描述符号</span></span><br><span class="line">    <span class="keyword">char</span> IsFree; <span class="comment">//表示此文件描述符是否空闲</span></span><br><span class="line">&#125;FileDescriptor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个结构体定义有一个特别的地方需要注意，就是使用了4字节对齐机制，因为后来这些结构体需要存储到字符型数组中，如果不采用对齐的话可能会导致不同结构体的长度不同，读取的时候就没办法读取.</p>
</blockquote>
<p>$\qquad$下面是该结构体各个成员的详细解释：</p>
<table>
<thead>
<tr>
<th align="center">成员名</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Length</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">存储文件大小</td>
</tr>
<tr>
<td align="center">DiskNum</td>
<td align="center">整型数组</td>
<td align="center">12字节</td>
<td align="center">存储文件内容的磁盘块好数组</td>
</tr>
<tr>
<td align="center">Num</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">文件描述符号</td>
</tr>
<tr>
<td align="center">IsFree</td>
<td align="center">字符型</td>
<td align="center">4字节(对齐后)</td>
<td align="center">表示当前描述符时候空闲</td>
</tr>
</tbody></table>
<ol start="2">
<li>目录项结构体定义</li>
</ol>
<p>$\qquad$目录是文件系统必不可缺的组成部分，本实验中通过目录项数组组成一个目录，而每个目录项由文件名和文件描述符号组成。下面是目录项结构体定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MenuItem</span> //目录对应0号文件描述符,一个目录项占据16字节，所以一个文件描述符可以存储96个文件</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> FileName[<span class="number">12</span>]; <span class="comment">//目录项中文件名的最大长度为16字节</span></span><br><span class="line">    <span class="keyword">int</span> FileDescriptorNum;<span class="comment">//文件描述符号</span></span><br><span class="line">&#125;MenuItem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样目录项结构体也是经过4字节对齐的，作用与上面的文件描述符结构体相似</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">成员名</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileName</td>
<td align="center">字符型数组</td>
<td align="center">12字节</td>
<td align="center">存储文件名</td>
</tr>
<tr>
<td align="center">FileDescriptorNum</td>
<td align="center">整型</td>
<td align="center">4字节</td>
<td align="center">文件描述符号</td>
</tr>
</tbody></table>
<h3 id="3-2-文件系统初始化"><a href="#3-2-文件系统初始化" class="headerlink" title="3.2 文件系统初始化"></a>3.2 文件系统初始化</h3><p>$\qquad$文件系统的初始化包括对文件描述符数组的初始化和目录项数组的初始化，和IO系统中的磁盘数组初始化一样，文件系统的初始化也就是对这两个数组进行一些编号操作等基本操作。</p>
<ol>
<li>文件描述符初始化：<code>InitFileDescriptor(void):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span>  DiskNum[<span class="number">3</span>]; <span class="comment">//磁盘号数组</span></span><br><span class="line">      DiskNum[<span class="number">0</span>] = i;</span><br><span class="line">      DiskNum[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">      DiskNum[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> FileDescriptorNum = i; <span class="comment">//文件描述符号</span></span><br><span class="line">      ChangeFileDescriptor(&amp;filedescriptor[i],<span class="number">0</span>,DiskNum,FileDescriptorNum,<span class="string">'Y'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    FileDescriptorToDisk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$首先遍历整个文件描述符数组，进行编号并且初始化的时候文件描述符对应的三个磁盘块只分配一个。</p>
<ol start="2">
<li>目录项初始化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMenu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        menuitem[i].FileDescriptorNum = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-文件系统用户接口"><a href="#3-3-文件系统用户接口" class="headerlink" title="3.3 文件系统用户接口"></a>3.3 文件系统用户接口</h3><ol>
<li>创建文件：<code>create(char filename[]):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是文件系统与用户直接的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> FileDescriptorNum,MenuItemNum,DiskNum;</span><br><span class="line">    <span class="comment">//寻找空闲目录项</span></span><br><span class="line">    MenuItemNum = SearchMenuItem();</span><br><span class="line">    <span class="built_in">strcpy</span>(menuitem[MenuItemNum].FileName,filename);</span><br><span class="line">    <span class="comment">//寻找空闲文件描述符</span></span><br><span class="line">    FileDescriptorNum = SearchFileDescriptor();</span><br><span class="line">    menuitem[MenuItemNum].FileDescriptorNum = FileDescriptorNum;</span><br><span class="line">    <span class="comment">//寻找空闲磁盘块</span></span><br><span class="line">    DiskNum = SearchBitMap();</span><br><span class="line">    filedescriptor[FileDescriptorNum].DiskNum[<span class="number">0</span>] = DiskNum;</span><br><span class="line">    filedescriptor[FileDescriptorNum].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    <span class="comment">//修改磁盘位图</span></span><br><span class="line">    ChangeBitMap(DiskNum,<span class="string">'Y'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$创建一个新的文件的时候，首先需要搜索一个空闲的目录项，将文件名存储在目录项中，然后在搜索一个空闲的描述符，分配该文件描述符给他文件，在搜索 一个空闲的磁盘块，将该磁盘块存储在文件描述符中。最后修改文件描述符状态和位图对应磁盘块的状态为占用。</p>
<ol start="2">
<li>删除文件：<code>destroy(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MenuItemNum=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(menuitem[i].FileName,filename)==<span class="number">0</span>)</span><br><span class="line">            MenuItemNum = i;</span><br><span class="line">    <span class="keyword">if</span>(MenuItemNum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"目录中没有此文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> FileDesCriptorNum = menuitem[MenuItemNum].FileDescriptorNum;</span><br><span class="line">    <span class="comment">//将目录项重置,重置时只需要将文件名删除，而不需要重置文件描述符，因为前面判断文件是否存在的条件是文件名是否存在</span></span><br><span class="line">    <span class="built_in">memset</span>(menuitem[MenuItemNum].FileName,<span class="number">0</span>, <span class="keyword">sizeof</span>(menuitem[MenuItemNum].FileName));</span><br><span class="line">    <span class="comment">//修改文件描述符为空闲状态</span></span><br><span class="line">    filedescriptor[FileDesCriptorNum].IsFree = <span class="string">'Y'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(filedescriptor[FileDesCriptorNum].DiskNum[i]!=<span class="number">-1</span>)</span><br><span class="line">        ChangeBitMap(filedescriptor[FileDesCriptorNum].DiskNum[i],<span class="string">'N'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$根据文件名在目录项数组中搜索对应的目录项，删除文件名，再找到目录项后读取该文件对应的文件描述符号，修改文件描述符状态为空闲；再讲文件描述符中记录的所有磁盘块状态全部改为空闲。</p>
<ol start="3">
<li>打开文件：<code>open(char filename[])</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MenuItemNum=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(menuitem[i].FileName,filename)==<span class="number">0</span>)</span><br><span class="line">            MenuItemNum = i;</span><br><span class="line">    <span class="keyword">if</span>(MenuItemNum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"目录中没有此文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//返回文件描述符号</span></span><br><span class="line">        <span class="keyword">return</span> menuitem[MenuItemNum].FileDescriptorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$这个函数通过遍历目录项数组，找到文件名符合的目录项，读取其文件描述符号返回，没有找到的话打印错误信息并返回-1</p>
<ol start="4">
<li>读取文件：<code>read(int index,int mem_area,int count)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">read</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> mem_area,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *temp;</span><br><span class="line">   <span class="keyword">char</span> block[<span class="number">512</span>];</span><br><span class="line">   temp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(count* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">   ReadBlock(filedescriptor[index].DiskNum[<span class="number">0</span>],block);</span><br><span class="line">   <span class="built_in">memcpy</span>(temp,&amp;block[mem_area],count);</span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$读取文件内容函数首先找到文件描述符中的磁盘号，然后调用IO系统提供的读取磁盘块的接口读取该磁盘块，读取后按照要求取对应位置指定长度的数据返回。</p>
<ol start="5">
<li>写文件：<code>write(int index,int mem_area,int count,char content[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> mem_area,<span class="keyword">int</span> count,<span class="keyword">char</span> content[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span> *s1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(mem_area* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">char</span> *s2=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(mem_area* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">int</span> DiskNum = filedescriptor[index].DiskNum[<span class="number">0</span>];</span><br><span class="line">    ReadBlock(DiskNum,temp);</span><br><span class="line">    <span class="built_in">memcpy</span>(s1,temp,mem_area);</span><br><span class="line">    <span class="built_in">memcpy</span>(s2,&amp;temp[mem_area],<span class="number">512</span>-mem_area);</span><br><span class="line">    s = <span class="built_in">strcat</span>(s1,content);</span><br><span class="line">    s = <span class="built_in">strcat</span>(s,s2);</span><br><span class="line">    filedescriptor[index].Length = <span class="built_in">strlen</span>(s);</span><br><span class="line">    WriteBlock(DiskNum,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$写文件的时候需要考虑可能是在原来文件的基础上，在某段插入一些内容，所以用s1字符指针保存mem_area之前的信息，s2保存mem_area之后的信息，加入要加入的内容后在连接成为一个完整的字符数组，最后调用IO系统提供的写入磁盘块接口写入 对应磁盘块。</p>
<h3 id="3-4-搜索文件系统"><a href="#3-4-搜索文件系统" class="headerlink" title="3.4 搜索文件系统"></a>3.4 搜索文件系统</h3><p>$\qquad$上面文件系统的用户接口中 很多地方用到了搜索文件描述符、搜索目录项等操作，所以需要单独写几个函数用于搜索文件描述符和目录项等结构。</p>
<ol>
<li>搜索空闲文件描述符:<code>SearchFileDescriptor():</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchFileDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(filedescriptor[i].IsFree == <span class="string">'Y'</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$遍历文件描述符数组，找到空闲的文件描述符号返回</p>
<ol start="2">
<li>搜索空闲目录项：<code>SearchMenuItem()：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchMenuItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(menuitem[i].FileName)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$遍历所有的目录项数组，知道找到空闲的目录项返回目录项号</p>
<h3 id="3-5-其它文件系统函数"><a href="#3-5-其它文件系统函数" class="headerlink" title="3.5 其它文件系统函数"></a>3.5 其它文件系统函数</h3><p>$\qquad$除了上面介绍的文件操作之外，还需一些函数，例如将文件描述符写入到磁盘中去，将目录项数组写入到第一个文件描述符对应的磁盘中；从磁盘中恢复文件描述符数组，恢复目录项数组。</p>
<ol>
<li>将文件描述符数组写入磁盘：<code>FileDescriptorToDisk(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件描述符写入磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileDescriptorToDisk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp_block[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> DiskNumIndex = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_descriptor[<span class="number">24</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_descriptor,&amp;filedescriptor[i], <span class="keyword">sizeof</span>(FileDescriptor));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;temp_block[index*<span class="number">24</span>],temp_descriptor,<span class="number">24</span>);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">int</span> t = index % <span class="number">21</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(DiskNumIndex&lt;<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][DiskNumIndex].Content,temp_block,<span class="number">512</span>);</span><br><span class="line">                ChangeBitMap(DiskNumIndex,<span class="string">'Y'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(ldisk[<span class="number">0</span>][<span class="number">1</span>][DiskNumIndex-B].Content,temp_block,<span class="number">512</span>);</span><br><span class="line">                ChangeBitMap(DiskNumIndex,<span class="string">'Y'</span>);<span class="comment">//修改位图</span></span><br><span class="line">            &#125;</span><br><span class="line">            DiskNumIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$遍历整个文件描述符数组，每个文件描述符占据24字节信息，21个文件描述符一组，一共504字节，将每组504字节信息存入到一个磁盘块中，存入后修改磁盘的状态为占用。</p>
<ol start="2">
<li>从磁盘恢复文件描述符数组：<code>DiskToFileDescriptor(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将磁盘读取的信息恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskToFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">if</span> (i&lt;B)</span><br><span class="line">            <span class="built_in">memcpy</span>(temp,ldisk[<span class="number">0</span>][<span class="number">0</span>][i].Content,<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memcpy</span>(temp,ldisk[<span class="number">0</span>][<span class="number">1</span>][i-B].Content,<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">21</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(((i<span class="number">-2</span>)*<span class="number">21</span>+j)&gt;<span class="number">256</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">char</span> temp_FileDescriptor[<span class="number">24</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(temp_FileDescriptor,&amp;temp[j*<span class="number">24</span>],<span class="number">24</span>);</span><br><span class="line">            FileDescriptor *f;</span><br><span class="line">            f = (FileDescriptor*)temp_FileDescriptor;</span><br><span class="line">            <span class="keyword">int</span> num = (i<span class="number">-2</span>)*<span class="number">21</span>+j;</span><br><span class="line">            filedescriptor[num].IsFree = f-&gt;IsFree;</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">0</span>] = f-&gt;DiskNum[<span class="number">0</span>];</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">1</span>] = f-&gt;DiskNum[<span class="number">1</span>];</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">2</span>] = f-&gt;DiskNum[<span class="number">2</span>];</span><br><span class="line">            filedescriptor[num].Length = f-&gt;Length;</span><br><span class="line">            filedescriptor[num].Num = f-&gt;Num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$由于每个磁盘块的空间只能存储21个文件描述符，所以每隔21就需要将index归零一次，用于从新读取一个新的磁盘的文件描述符信息，每次读取的是一整个磁盘的信息，长度是512字节，而每个文件描述符的大小为24，所以首先全部服务磁盘块信息到<code>temp_block</code>，然后每次读取24字节信息到<code>temp_descriptor</code>,之后通过强制类型转换，将字符换数组转化为文件描述符结构体指针，这样就将磁盘块中的信息读入。</p>
<ol start="3">
<li>将目录项数组写入文件描述符：<code>MenuToFileDescriptor(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将目录内容写入文件描述中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MenuToFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp_FileDescriptor[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_menuitem[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_menuitem,&amp;menuitem[i],<span class="number">16</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;temp_FileDescriptor[i*<span class="number">16</span>],temp_menuitem,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>] = SearchBitMap();</span><br><span class="line">    filedescriptor[<span class="number">0</span>].Length = <span class="number">512</span>;</span><br><span class="line">    WriteBlock(filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>],temp_FileDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$将所有的目录项合并为一个512字节的字符数组(注意使用的是memcpy而不是strcpy)然后将第一个文件描述符的状态修改位占用，并将字符数组写入第一个文件描述符对应的磁盘块。</p>
<ol start="4">
<li>从第一个文件描述符恢复目录项数组：<code>FileDescriptorToMenu(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileDescriptorToMenu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> MenuContent[<span class="number">512</span>];</span><br><span class="line">    ReadBlock(filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>],MenuContent);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_menuitem[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_menuitem,&amp;MenuContent[i*<span class="number">16</span>],<span class="number">16</span>);</span><br><span class="line">        MenuItem *t;</span><br><span class="line">        t = (MenuItem *)temp_menuitem;</span><br><span class="line">        <span class="built_in">strcpy</span>(menuitem[i].FileName,t-&gt;FileName);</span><br><span class="line">        menuitem[i].FileDescriptorNum = t-&gt;FileDescriptorNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$首先读取第一个文件描述符对应的磁盘块信息到<code>MenuContent</code>字符数中去，然后每次读取16字节信息，将读取的16字节信息强制转换为目录项指针。这样磁盘上存储的所欲目录项信息就会被全部读取。</p>
<h2 id="四-菜单系统"><a href="#四-菜单系统" class="headerlink" title="四 菜单系统"></a>四 菜单系统</h2><blockquote>
<p>菜单系统代码在main.cpp文件中</p>
</blockquote>
<p>$\qquad$IO系统和文件系统准备好之后就可以更具需要的功能设计出具体的功能，并对应写出一个菜单系统。</p>
<p>对应的菜单系统有如下函数：</p>
<ol>
<li>查看目录函数：<code>ShowDir()</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> exist = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************目录***********************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前目录下文件有:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(menuitem[i].FileName)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %s %dB\n"</span>,index,menuitem[i].FileName,filedescriptor[menuitem[i].FileDescriptorNum].Length);</span><br><span class="line">            exist++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"一共存在%d个文件\n"</span>,exist);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************************************\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$可以看到这个查看目录函数遍历目录项数组，打印所有非空目录项 内容，包括文件名和文件大小，最后统计出一共存在多少个文件。</p>
<ol start="2">
<li>打印位图：<code>ShowBitMap()</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n****************位图**********************\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前的磁盘使用情况如下(Y表示使用，N表示未使用)\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d号柱面磁盘信息如下:\n"</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   区:0 1 2 3 4 5 6 7 8 9\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"头\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t:"</span>,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=i*H*B+j*B+k;</span><br><span class="line">                <span class="keyword">if</span>(t&lt;<span class="number">512</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>,ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t]);</span><br><span class="line">                    <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t] == <span class="string">'Y'</span>)</span><br><span class="line">                        used++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>,ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[t<span class="number">-512</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t] == <span class="string">'Y'</span>)</span><br><span class="line">                        used++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"总共使用%d个磁盘块，剩余%d个磁盘块空闲\n"</span>,used,(C*B*H-used));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************************************\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$这个函数的大部分代码在进行位图打印信息的排版，每个柱面为一页，每一页中每一行表示一个磁头，每一列表示一个扇区。最后统计出所有磁盘的使用占比。</p>
<ol start="3">
<li>主菜单程序</li>
</ol>
<blockquote>
<p>由于整个函数代码太长，所以只展示核心代码，完整代码请查看github</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:ShowDir();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要创建的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        create(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要删除的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        destroy(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要打开的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        ReadFile(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">int</span> choice3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1. 增加内容\t2. 删除内容"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n请选择："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice3);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要修改的文件名:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        <span class="keyword">if</span>(choice3==<span class="number">1</span>)</span><br><span class="line">            ChangeFileAdd(filename);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choice3==<span class="number">2</span>)</span><br><span class="line">            ChangeFileDel(filename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ShowBitMap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要保存的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        save(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\qquad$这个switch结构提供个8个选择，对应8个功能。</p>
<h2 id="五-文件系统测试"><a href="#五-文件系统测试" class="headerlink" title="五 文件系统测试"></a>五 文件系统测试</h2><p>$\qquad$IO系统、文件系统和菜单系统完成之后需要对文件系统进行测试，下面是测试的详细过程。</p>
<h3 id="5-1-测试概述"><a href="#5-1-测试概述" class="headerlink" title="5.1 测试概述"></a>5.1 测试概述</h3><p>$\qquad$测试部分分别测试IO系统、文件系统对应的功能，测试计划如下所示：</p>
<table>
<thead>
<tr>
<th align="center">测试名称</th>
<th align="center">测试描述</th>
<th align="center">被测试模块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">保存磁盘文件测试</td>
<td align="center">将当前磁盘信息存入二进制文件</td>
<td align="center">IO系统磁盘写入文件功能、菜单系统等</td>
</tr>
<tr>
<td align="center">读取磁盘文件测试</td>
<td align="center">从文件系统中读取磁盘文件，装载到磁盘系统中</td>
<td align="center">IO系统磁盘写入文件功能、菜单系统等</td>
</tr>
<tr>
<td align="center">目录查看测试</td>
<td align="center">查看当前目录中存在的所有文件</td>
<td align="center">文件系统目录模块、文件描述符模块；<br>菜单系统</td>
</tr>
<tr>
<td align="center">文件创建测试</td>
<td align="center">创建新的文件</td>
<td align="center">文件系统目录模块、文件系统用户接口</td>
</tr>
<tr>
<td align="center">文件删除测试</td>
<td align="center">删除已有(不存在)文件</td>
<td align="center">文件系统目录模块、文件系统用户接口</td>
</tr>
<tr>
<td align="center">打开文件测试</td>
<td align="center">打开并查看文件内容</td>
<td align="center">文件系统用户接口</td>
</tr>
<tr>
<td align="center">修改文件测试</td>
<td align="center">修改文件内容</td>
<td align="center">文件系统目录模块、文件系统用户接口，IO系统</td>
</tr>
<tr>
<td align="center">查看位图测试</td>
<td align="center">查看当前磁盘位图信息</td>
<td align="center">IO系统位图模块，菜单系统</td>
</tr>
</tbody></table>
<h3 id="5-2-系统测试"><a href="#5-2-系统测试" class="headerlink" title="5.2 系统测试"></a>5.2 系统测试</h3><ol>
<li>保存磁盘文件测试 &amp; 文件创建测试</li>
</ol>
<ul>
<li>保存磁盘系统之前首先需要创建一个新的磁盘系统</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152201.jpg" width="400"></div>

<ul>
<li>在新的文件系统中创建文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152411.jpg" width="400"></div>

<blockquote>
<p>可以看到查看文件目录的时候看到刚刚创建的目录</p>
</blockquote>
<ul>
<li>给刚刚创建的文件添加一点内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152553.jpg" width="400"></div>

<blockquote>
<p>可以看到添加了内容之后内容保存到文中去</p>
</blockquote>
<ul>
<li>再次查看目录</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152726.jpg" width="400"></div>

<p>可以看到文件的长度确实发生了变化</p>
<ul>
<li>保存磁盘文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152830.jpg" width="400"></div>

<blockquote>
<p>将磁盘系统保存到test.dat中去</p>
</blockquote>
<ul>
<li>为了验证刚刚的磁盘信息确实保存了下来，使用xxd工具查看test.dat文件的内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153038.jpg" width="400"></div>

<blockquote>
<p>可以看到test.dat中前面是位图信息，共占用15个磁盘块，标志位’Y’,其他所有磁盘块状态为空闲，标志位’N’</p>
</blockquote>
<ul>
<li>再检索刚刚创建的文件是否存在</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153234.jpg" width="400"></div>

<blockquote>
<p>可以看到检索’Hello’和文件名’test’的时候都有对应内容，说明磁盘信息缺失保存了下来</p>
</blockquote>
<ol start="2">
<li>读取磁盘文件测试 &amp; 目录查看测试 &amp; 打开文件测试</li>
</ol>
<ul>
<li>打开上面测试中保存的<code>test.dat</code>文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153515.jpg" width="400"></div>

<blockquote>
<p>可以看到磁盘信息全部恢复了</p>
</blockquote>
<ul>
<li>打开文件内容具体查看一下，内容是否存在变化</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153724.jpg" width="400"></div>

<blockquote>
<p>可以看到文件内容没有发生改变</p>
</blockquote>
<ol start="3">
<li>文件删除测试</li>
</ol>
<ul>
<li>为了便于进行文件删除测试，首先先创建一个文件<code>test2.txt</code></li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153946.jpg" width="400"></div>

<ul>
<li>删除文件<code>test2.txt</code></li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154041.jpg" width="400"></div>

<ol start="4">
<li>修改文件测试</li>
</ol>
<p>$\qquad$修改文件测时候分为在原有文件的基础上增加内容和删除内容，我们这在<code>test.txt</code>的基础上进行增加和删除操作</p>
<ul>
<li>在<code>test.txt</code>上增加内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154448.jpg" width="400"></div>

<blockquote>
<p>可以看到在指定位置增加了指定的内容</p>
</blockquote>
<ul>
<li>在<code>test.txt</code>删除内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154628.jpg" width="400"></div>

<blockquote>
<p>可以看到指定位置的指定内容被删除了</p>
</blockquote>
<ol start="5">
<li>查看位图测试</li>
</ol>
<ul>
<li>文件系统在初始化之后应该有15个磁盘块被占用，其中2个用于存储位图，12个用于存储文件描述符，1个用于存储目录</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155003.jpg" width="400"></div>

<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155027.jpg" width="400"></div>

<blockquote>
<p>可以看到0号柱面的磁盘位图信息如上所示,总共使用14个磁盘块，其他全部空闲</p>
</blockquote>
<ul>
<li>增加一个文件之后，查看磁盘位图</li>
</ul>
<p>$\qquad$增加文件之后，当文件内容小于一个磁盘块大小时，暂时只分配一个磁盘块，所以应该只占用前个磁盘块</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155232.jpg" width="400"></div>

<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155252.jpg" width="400"></div>

<h2 id="六-实验总结"><a href="#六-实验总结" class="headerlink" title="六 实验总结"></a>六 实验总结</h2><p>$\qquad$通过本次实验收获到了许多的东西，也许到了很多知识。实验之前，看完整个实验要求之后没有一个整体的思路就开始编写程序，导致后期的时候很多地方考虑不够全面，各个系统中函数组织混乱，整个构架不够完整，本次实验收获到的第一点就是在进行实验之前一定要提前设计好实验的思路，最好做好整个概要设计；第二点收获就是对文件系统有了更加深刻的认知，实验从最底层的磁盘块开始模拟，一点一点到IO系统，再到文件系、目录等等，通过自己的实践更加深刻的了解了文件系统；最后一点 收获就是在编程能力上的收获，这次通过编写这个文件系统，再次巩固了自己对于C语言的掌握能力，并且了解到了以前所用的处理字符串的一系列函数的缺点，例如strcpy只能复制\0之前的内容，strcat只能连接两个字符换的可见内容等等，学会了新的函数memcpy，通过这个函数实现将结构体以二进制的形式存储到字符串中和将字符串再恢复到结构体中。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/lab4/" class="post-title-link" itemprop="url">页面置换算法实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:52:59" itemprop="dateCreated datePublished" datetime="2019-09-12T15:52:59+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>9.2k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>8 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验四-实验报告"><a href="#实验四-实验报告" class="headerlink" title="实验四 实验报告"></a><center>实验四 实验报告</center></h1><blockquote>
<center>孙汉武    16281047    16281047</center>
</blockquote>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab4" target="_blank" rel="noopener">实验源码链接:https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab4</a></p>
<h2 id="一-概要设计"><a href="#一-概要设计" class="headerlink" title="一 概要设计"></a>一 概要设计</h2><blockquote>
<p>实验源码请参考test.h</p>
</blockquote>
<h3 id="1-1-模块说明"><a href="#1-1-模块说明" class="headerlink" title="1.1 模块说明"></a>1.1 模块说明</h3><p>$\qquad$本实验共包含测试模块在内一共有7个模块，其中五个模块是算法模块，分别实现最佳置换算法、先入先出算法、最久未使用算法、改进的Clock算法、PBA页面缓冲算法和主模块。详细的细节如下：</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">文件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">测试模块</td>
<td align="center">test.h</td>
<td align="center">包含页面帧结构体的定义、随机访问序列的生成等测试函数</td>
</tr>
<tr>
<td align="center">最佳置换算法模块</td>
<td align="center">Optimal.h</td>
<td align="center">包含最佳置换算法函数</td>
</tr>
<tr>
<td align="center">先入先出算法模块</td>
<td align="center">FIFO.h</td>
<td align="center">包含先入先出算法函数</td>
</tr>
<tr>
<td align="center">最久未使用算法模块</td>
<td align="center">LRU.h</td>
<td align="center">包含最久未使用算法函数</td>
</tr>
<tr>
<td align="center">改进Clock算法模块</td>
<td align="center">Clock.h</td>
<td align="center">包含改进的Clock算法函数</td>
</tr>
<tr>
<td align="center">PBA页面缓冲算法模块</td>
<td align="center">PBA.h</td>
<td align="center">包含页面缓冲算法函数</td>
</tr>
<tr>
<td align="center">主模块</td>
<td align="center">main.cpp</td>
<td align="center">主函数</td>
</tr>
</tbody></table>
<h3 id="1-2-接口说明"><a href="#1-2-接口说明" class="headerlink" title="1.2 接口说明"></a>1.2 接口说明</h3><p>$\qquad$1.1 中所说的的各个模块中，测试模块是一个最基本的模块，它包含最基本的页面帧结构体的定义和随机访问序列生成函数等基本数据结构和函数。而六个算法模块都会引用测试模块中的数据结构和随机访问序列生成函数。而在主函数中进行对各个算法模块的调用。下面图示了各个模块之间的关系：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-123542.jpg" width="600"></div>

<h3 id="1-3-数据结构说明"><a href="#1-3-数据结构说明" class="headerlink" title="1.3 数据结构说明"></a>1.3 数据结构说明</h3><p>$\qquad$在本实验定一个很重要的表示页面帧的结构体，其成员变量及其作用如下图所示：</p>
<ol>
<li>WorkItem(表示帧结构体)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WorkItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">char</span> Used;</span><br><span class="line">    <span class="keyword">char</span> Modified;</span><br><span class="line">&#125;WorkItem;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">作用</th>
<th align="center">变量名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">seq</td>
<td align="center">访问的序列号</td>
<td align="center">priority</td>
<td align="center">优先级</td>
</tr>
<tr>
<td align="center">Used</td>
<td align="center">Clock中的使用位</td>
<td align="center">Modified</td>
<td align="center">Clock中的修改位</td>
</tr>
</tbody></table>
<ol start="2">
<li>MemSchedule(表示内存分配调度结构体)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemSchedule</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WorkItem* WorkSpace=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *VisitSeq=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">64</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//工作集大小</span></span><br><span class="line">    <span class="keyword">int</span> e=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//定义访问序列长度o</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="comment">//当前已使用物理块数</span></span><br><span class="line">    <span class="keyword">int</span> work_len=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//发生替换的物理块号</span></span><br><span class="line">    <span class="keyword">int</span> change=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> t,r;</span><br><span class="line"><span class="comment">//   队列长度</span></span><br><span class="line">    <span class="keyword">int</span> queue_free_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> queue_modified_len = <span class="number">0</span>;</span><br><span class="line">    WorkItem <span class="built_in">free</span>[<span class="number">2</span>];</span><br><span class="line">    WorkItem Modified[<span class="number">2</span>];</span><br><span class="line">&#125;MemSchedule;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">作用</th>
<th align="center">变量名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WorkSpace</td>
<td align="center">工作区间结构体数组</td>
<td align="center">VisitSeq</td>
<td align="center">访问序列数组</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">虚拟内存大小</td>
<td align="center">p</td>
<td align="center">工作集起始位置</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">工作区间大小</td>
<td align="center">m</td>
<td align="center">工作区间移动效率</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">访问序列长度</td>
<td align="center">work_len</td>
<td align="center">工作集中使用长度</td>
</tr>
<tr>
<td align="center">chang</td>
<td align="center">上一次发生替换的物理块号</td>
<td align="center">t,r</td>
<td align="center">随机访问序列算法参数</td>
</tr>
<tr>
<td align="center">queue_free_len</td>
<td align="center">PBA中的空闲队列长度</td>
<td align="center">queue_modifie_len</td>
<td align="center">PBA中修改队列长度</td>
</tr>
<tr>
<td align="center">free</td>
<td align="center">PBA中的空闲队列</td>
<td align="center">Modified</td>
<td align="center">PBA中的修改队列</td>
</tr>
</tbody></table>
<h3 id="1-4-随机访问序列生成算法"><a href="#1-4-随机访问序列生成算法" class="headerlink" title="1.4 随机访问序列生成算法"></a>1.4 随机访问序列生成算法</h3><p>$\qquad$实验中需要使用到随机访问序列，所以生成一个好的随机访问序列能很好的测试出各个算法的性能。下面是本实验中的随机算法访问序列生成算法的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemSchedule <span class="title">GeneVisitSeq</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MemSchedule schedule1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"是否设定调度算法参数(Y/N):"</span>);</span><br><span class="line">    <span class="keyword">char</span> flag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;flag);</span><br><span class="line">    <span class="keyword">if</span> (flag==<span class="string">'Y'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        schedule1=SetMemSchedule(schedule1);</span><br><span class="line">    &#125;</span><br><span class="line">	schedule1.t=rand()%<span class="number">1000</span>/<span class="number">1000.0</span>;</span><br><span class="line">    schedule1.VisitSeq=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(l*<span class="keyword">sizeof</span>(schedule1.m));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"生成随机内存访问序列：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;schedule1.m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            schedule1.VisitSeq[i*schedule1.m+j] = rand()%schedule1.e+schedule1.p;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,schedule1.VisitSeq[i*schedule1.m+j]);</span><br><span class="line">        &#125;</span><br><span class="line">        schedule1.r=rand()%<span class="number">1000</span>/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(schedule1.r&lt;schedule1.t)</span><br><span class="line">        &#123;</span><br><span class="line">            schedule1.p=(schedule1.p+<span class="number">1</span>)%schedule1.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    schedule1.length=l*schedule1.m;</span><br><span class="line">    schedule1.WorkSpace = (WorkItem *)<span class="built_in">malloc</span>(schedule1.e *<span class="keyword">sizeof</span>(WorkItem));</span><br><span class="line">    <span class="keyword">return</span> schedule1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是其流程图：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-125913.jpg" width="500"></div>

<p>其描述为：</p>
<ul>
<li>首先生成算法需要的N p e m t等基本参数</li>
<li>生成m个范围在p到p+e之间的随机数加入到序列中</li>
<li>生成随机小数r</li>
<li>比较t和r，如果t比r小；则取一个新的p值；否则p=p+1 mod N</li>
<li>如果需要继续加长访问序列，则返回第二部继续执行；否则结束</li>
</ul>
<h3 id="1-5-算法通用流程"><a href="#1-5-算法通用流程" class="headerlink" title="1.5 算法通用流程"></a>1.5 算法通用流程</h3><p>$\qquad$各个页面置换算法中，大部分流程是一致的，只是在选择要替换的页面的时候选择的算法不一样，下面是这些算法的通用流程，而每个算法选择替换页号的时候将在后面仔细解释。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-131355.jpg" width="600"></div>

<p>其描述为：</p>
<ul>
<li>在访问序列中取出下一个要访问的页号，序列为空的话结束。</li>
<li>查看分配的内存内存块中是否还有剩余空间，有的话进行第三步；没有进行第四步</li>
<li>查看要访问的页号在以装入内存中是否存在，存在的话直接去下一个要访问的页号，从第一步开始执行；不存在则将新的物理块装入内存</li>
<li>查看要访问的页号在以装入内存中是否存在，存在的话直接去下一个要访问的页号，从第二部开始执行；不存在则利用算法找到要替换的内存块号，并将其替换，返回第一步</li>
</ul>
<h2 id="二-最佳置换算法"><a href="#二-最佳置换算法" class="headerlink" title="二 最佳置换算法"></a>二 最佳置换算法</h2><blockquote>
<p>实验源码请参照github中Optimal.h</p>
</blockquote>
<ol>
<li>算法描述</li>
</ol>
<p>$\qquad$最佳置换算法是一个理想的算法，其选择淘汰的页面是以后用不使用的，或者在将来最长时间用不使用的页面。采用最佳置换算法通常可以保证最低的缺页率。</p>
<ol start="2">
<li><p>算法模拟</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>4</th>
<th>4</th>
<th>3</th>
<th>5</th>
<th>6</th>
<th>3</th>
<th>6</th>
<th>7</th>
<th>9</th>
<th>7</th>
<th>10</th>
<th>9</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>内存块1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>内存块2</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>内存块3</td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>12</td>
</tr>
<tr>
<td>内存块4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>内存块5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<p> 上面是算法执行过程中页面的替换过程</p>
</li>
<li><p>算法实现</p>
<p> $\qquad$在概要设计中给出了各个算法的通用算法流程，但是各个算法在选择替换的内存块号的时候是不一致的。下面的是最佳置换算法中的实现。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//min表示最小优先级的那个内存块号</span></span><br><span class="line">    <span class="keyword">int</span> min_pri=<span class="number">0xffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = SearchVisitSqe(s1.VisitSeq,i<span class="number">-1</span>,s1.WorkSpace[m].seq,<span class="number">0</span>,s1.length-s1.work_len+m);</span><br><span class="line">        s1.WorkSpace[m].priority = n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; min_pri)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.change = m;</span><br><span class="line">            min_pri = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示发生替换变化的块号s1.change</span></span><br><span class="line">    s1.WorkSpace[s1.change].seq = pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $\qquad$在这个代码片段中可以看到，通过<code>SearchVisitSeq</code>函数找到当前内存块中的页号下一次在访问序列中出现的距离，并将该距离最为优先级的值更新给每个内存块。最后判断哪个优先级小，说明那个物理块将来出现的时间越长，将替换它。</p>
</li>
<li><p>在主函数中调用最佳置换算法函数，会得到如下结果：</p>
</li>
</ol>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-132453.jpg" width="600"></div>

<blockquote>
<p>带有@符号的表示这是新替换的页面，带有@的一行说明发生了缺页</p>
</blockquote>
<ol start="5">
<li>算法性能评价</li>
</ol>
<p>$\qquad$程序设计中给出了两个评价算法性能的指标，分别是缺页率，下面将会给出在不同的虚拟内存和工作集的情况下两个指标的变化情况。</p>
<p>$\qquad$由于时间开销在算法中无法模拟，只能通过了理论的分析得到。下面只给出缺页率与工作集大小和虚拟内训大小之间的关系。</p>
<p>​    工作集大小与缺页率之间的关系：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-134926.jpg" width="400"></div>

<p>$\qquad$对应的曲线为：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-135121.jpg" width="400"></div> 

<p>$\qquad$对于这个曲线做出的解释如下：</p>
<ul>
<li>当工作集比较小的时候，频繁的发生缺页导致缺页率高</li>
<li>当工作集增大时，由于内存块数增多，减少页面的发生，缺页率减少。</li>
<li>当工作集再继续增大的时候，前面物理块空闲的时候页面装入也算做缺页，所以缺页率再次上升</li>
<li>当工作集大小达到一定程度的时候，缺页率会一直减小</li>
</ul>
<p>当工作集不变的时候，更改虚拟内存的时候分析缺页率的变化：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-143913.jpg" width="400"></div>

<p>其对应的曲线图为：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-141851.jpg" width="400"></div>

<h2 id="三-先入先出置换算法"><a href="#三-先入先出置换算法" class="headerlink" title="三  先入先出置换算法"></a>三  先入先出置换算法</h2><blockquote>
<p>实验源码请参考github中的FIFO.h</p>
</blockquote>
<ol>
<li><p>算法描述</p>
<p> 是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 </p>
</li>
<li><p>算法模拟</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>4</th>
<th>4</th>
<th>3</th>
<th>5</th>
<th>6</th>
<th>3</th>
<th>6</th>
<th>7</th>
<th>9</th>
<th>7</th>
<th>10</th>
<th>9</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>内存块1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>内存块2</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>内存块3</td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>内存块4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>12</td>
</tr>
<tr>
<td>内存块5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
</li>
<li><p>算法实现</p>
<p> 在概要设计中给出了各个算法的通用算法流程，但是各个算法在选择替换的内存块号的时候是不一致的。下面的是先入先出置换算法中的实现。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//min表示最小优先级的那个内存块号</span></span><br><span class="line">    <span class="keyword">int</span> min_pri=<span class="number">0xffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//和其他算法的区别只有优先级排序计算的方式不同</span></span><br><span class="line">        <span class="keyword">int</span> n = s1.WorkSpace[m].priority;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; min_pri)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.change = m;</span><br><span class="line">            min_pri = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示发生替换变化的块号s1.change</span></span><br><span class="line">    s1.WorkSpace[s1.change].seq = pointer;</span><br><span class="line">    <span class="comment">//设置新换入的页面优先级为work_len</span></span><br><span class="line">    s1.WorkSpace[s1.change].priority = s1.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $\qquad$在先入先出置换算法中每次新置换一个内存块将其优先级设置为工作区大小，之后每次运行一次，工作区中的所有内存块的优先级都减一，替换的时候找到优先级最小的替换就行了。</p>
</li>
<li><p>运行结果</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-142312.jpg" width="600"></div>

</li>
</ol>
<h2 id="四-最久未使用置换算法"><a href="#四-最久未使用置换算法" class="headerlink" title="四 最久未使用置换算法"></a>四 最久未使用置换算法</h2><blockquote>
<p>实验源码请参考github中的LRU.h文件</p>
</blockquote>
<ol>
<li><p>算法描述</p>
<p> 这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。</p>
</li>
<li><p>算法模拟</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>4</th>
<th>4</th>
<th>3</th>
<th>5</th>
<th>6</th>
<th>3</th>
<th>6</th>
<th>7</th>
<th>9</th>
<th>7</th>
<th>10</th>
<th>9</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>内存块1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>内存块2</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>内存块3</td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>内存块4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>12</td>
</tr>
<tr>
<td>内存块5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
</li>
<li><p>算法实现</p>
<p> 在概要设计中给出了各个算法的通用算法流程，但是各个算法在选择替换的内存块号的时候是不一致的。下面的是最久未使用置换算法中的实现。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//min表示最小优先级的那个内存块号</span></span><br><span class="line">    <span class="keyword">int</span> min_pri=<span class="number">-10000</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = SearchVisitSqe(s1.VisitSeq,i,s1.WorkSpace[m].seq,<span class="number">1</span>,i);</span><br><span class="line">        s1.WorkSpace[m].priority = n;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; min_pri)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.change = m;</span><br><span class="line">            min_pri = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示发生替换变化的块号s1.change</span></span><br><span class="line">    s1.WorkSpace[s1.change].seq = pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $\qquad$在LRU算法中，使用函数<code>SearchVisitSeq</code>向访问序列中已经访问过的序列反向查找与当前页号相同的页号的距离，并将其最为优先级赋值给内存块，每次替换前更新所有的内存块的优先级；替换的时候找到优先级最大的进行替换。</p>
</li>
<li><p>运行结果</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-144704.jpg" width="600"></div>

</li>
</ol>
<h2 id="五-改进的Clock置换算法"><a href="#五-改进的Clock置换算法" class="headerlink" title="五 改进的Clock置换算法"></a>五 改进的Clock置换算法</h2><ol>
<li><p>算法描述</p>
<p> $\qquad$LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。</p>
<p> $\qquad$简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p>
<p> $\qquad$CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p>
<ul>
<li><p>最近未被访问，也未被修改(u=0, m=0)</p>
</li>
<li><p>最近被访问，但未被修改(u=1, m=0)</p>
</li>
<li><p>最近未被访问，但被修改(u=0, m=1)</p>
</li>
<li><p>最近被访问，被修改(u=1, m=1)</p>
</li>
</ul>
</li>
</ol>
<pre><code>算法执行如下操作步骤：

+ 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。

+ 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。

+ 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</code></pre><ol start="2">
<li><p>算法模拟</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>4</th>
<th>4</th>
<th>3</th>
<th>5</th>
<th>6</th>
<th>3</th>
<th>6</th>
<th>7</th>
<th>9</th>
<th>7</th>
<th>10</th>
<th>9</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>内存块1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>12</td>
</tr>
<tr>
<td>内存块2</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>内存块3</td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>内存块4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>内存块5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
</li>
<li><p>算法实现</p>
<p> 改进的Clock算法比前几个算法来讲比较复杂，下面是其核心的实现过程，</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//表示内存块中没有出现过</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.WorkSpace[m].Used ==<span class="string">'N'</span> &amp;&amp; s1.WorkSpace[m].Modified ==<span class="string">'N'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1.change =m;</span><br><span class="line">                flag =<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.WorkSpace[m].Used ==<span class="string">'N'</span> &amp;&amp; s1.WorkSpace[m].Modified ==<span class="string">'Y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s1.change = m;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s1.WorkSpace[m].Used = <span class="string">'N'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    s1.WorkSpace[s1.change].seq = pointer;</span><br><span class="line">    s1.WorkSpace[s1.change].Used = <span class="string">'Y'</span>;</span><br><span class="line">    s1.WorkSpace[s1.change].Modified = <span class="string">'N'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过下面的流程图来解释该算法在选择替换物理块的时候的流程。</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-154625.jpg" width="600"></div>

<p> 算法描述：</p>
<ul>
<li>首先查找有没有(0，0)类型的页面，有的话替换该页面，没有的话进行第二步</li>
<li>查找有没有(0，1)类型的页面，有的话替换该页面，没有的话进行第三步</li>
<li>如果第一步第二步都没有找到的话就将所有页面的使用位都置为0然后重复第一步</li>
</ul>
</li>
<li><p>运行结果</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-145440.jpg" width="600"></div>

</li>
</ol>
<blockquote>
<p>运行结果中的的第一个’Y/N’表示使用位,第二个’Y/N’表示修改位，@表示是新置换的页面</p>
</blockquote>
<h2 id="六-页面缓冲算法PBA"><a href="#六-页面缓冲算法PBA" class="headerlink" title="六 页面缓冲算法PBA"></a>六 页面缓冲算法PBA</h2><blockquote>
<p>实验源码请参考github中的PBA.h</p>
</blockquote>
<ol>
<li><p>算法描述</p>
<p> $\qquad$严格意义上说PBA算法是一种页面缓冲算法，意义在于提高算法性能，减少从磁盘读取物理块到内存中的时间，提高算法的效率。而真正的页面置换算法采用的是前面所述的几种页面置换算法。本实验中采用的是FIFO置换算法。</p>
<p> $\qquad$在PBA算法中使用了两个队列，分别是使用空闲页面队列和修改页面队列。采用可变分配和基于先进先出的局部置换策略，并规定被淘汰页先不做物理移动，而是依据是否修改分别挂到空闲页面链表或已修改页面链表的末尾</p>
<p> $\qquad$空闲页面链表同时用于物理块分配。当已修改页面链表达到一定长度如Z个页面时，一起将所有已修改页面写回磁盘，故可显著减少磁盘I/O操作次数</p>
</li>
<li><p>算法模拟</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-160411.jpg" width="600"></div>
</li>
<li><p>算法实现</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//min表示最小优先级的那个内存块号</span></span><br><span class="line">    <span class="keyword">int</span> min_pri=<span class="number">0xffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> m=<span class="number">0</span>;m&lt;s1.work_len;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//和其他算法的区别只有优先级排序计算的方式不同</span></span><br><span class="line">        <span class="keyword">int</span> n = s1.WorkSpace[m].priority;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; min_pri)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.change = m;</span><br><span class="line">            min_pri = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示发生替换变化的块号s1.change</span></span><br><span class="line">    s1.WorkSpace[s1.change].seq = pointer;</span><br><span class="line">    <span class="comment">//设置新换入的页面优先级为work_len</span></span><br><span class="line">    s1.WorkSpace[s1.change].priority = s1.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> $\qquad$PBA 算法在页面置换的时候算法实现和FIFO一致。这里不再赘述</p>
</li>
<li><p>运行结果</p>
 <div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-05-27-160610.jpg" width="600"></div>


</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/lab3/" class="post-title-link" itemprop="url">进程实验二</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:52:08" itemprop="dateCreated datePublished" datetime="2019-09-12T15:52:08+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>40k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>37 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验三-实验报告"><a href="#实验三-实验报告" class="headerlink" title="实验三 实验报告"></a><center>实验三 实验报告</center></h1><blockquote>
<center>孙汉武    安全1601    16281047</center>
</blockquote>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab3" target="_blank" rel="noopener">实验源代码链接</a></p>
<h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><h3 id="1-1-实验要求"><a href="#1-1-实验要求" class="headerlink" title="1.1 实验要求"></a>1.1 实验要求</h3><p>$\qquad$通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。</p>
<h3 id="1-2-实验过程"><a href="#1-2-实验过程" class="headerlink" title="1.2 实验过程"></a>1.2 实验过程</h3><ol>
<li><p>实验源码</p>
<p><code>Task1.c</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sem_t</span> *P1_signal,*P2_signal,*P3_signal;</span><br><span class="line">	<span class="comment">//主函数中的进程是P1</span></span><br><span class="line">	<span class="keyword">pid_t</span> p2,p3,p4; </span><br><span class="line">	P1_signal=sem_open(<span class="string">"P1_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	P2_signal=sem_open(<span class="string">"P2_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	P3_signal=sem_open(<span class="string">"P3_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	p2=fork();<span class="comment">//创建进程P2</span></span><br><span class="line">	<span class="keyword">if</span>(p2&lt;<span class="number">0</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"创建进程p2出错！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p2==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(P1_signal);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I am the process P2!\n"</span>);</span><br><span class="line">		sem_post(P1_signal);</span><br><span class="line">		sem_post(P2_signal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p2&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p3=fork();</span><br><span class="line">		<span class="keyword">if</span>(p3&lt;<span class="number">0</span>)	</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"创建进程p出错！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p3==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sem_wait(P1_signal);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am the process P3!\n"</span>);</span><br><span class="line">			sem_post(P1_signal);</span><br><span class="line">			sem_post(P3_signal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p3&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am the process P1!\n"</span>);</span><br><span class="line">			sem_post(P1_signal);</span><br><span class="line">			p4=fork();</span><br><span class="line">			<span class="keyword">if</span>(p4&lt;<span class="number">0</span>)	</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"创建进程p4出错！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p4==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sem_wait(P2_signal);</span><br><span class="line">				sem_wait(P3_signal);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"I am the process P4!\n"</span>);</span><br><span class="line">				sem_post(P2_signal);</span><br><span class="line">				sem_post(P3_signal);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sem_close(P1_signal);</span><br><span class="line">	sem_close(P3_signal);</span><br><span class="line">	sem_close(P2_signal);</span><br><span class="line">	sem_unlink(<span class="string">"P1_signal"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"P2_signal"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"P3_signal"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原理解释</p>
<ul>
<li><p>前趋图</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172743.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<pre><code>前驱关系：`P1--&gt;P2`、`P1--&gt;P3`、`P2--&gt;P4`、`P3--&gt;P4`</code></pre><ul>
<li><p>前驱关系实现</p>
<p>题目要求产生的四个进程必须是P1最先执行，P2、P3在P1执行完后互斥执行，P4最后执行。于是根据要求有了上面的前驱关系和前驱图。但是如何实现这种进程间的前驱关系呢？比较自然的想到了是用信号量机制。如上面的代码所示，定义了三个信号量，P1_signal、P2_signal和P3_signal，其初值均为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1_signal=sem_open(<span class="string">"P1_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">   P2_signal=sem_open(<span class="string">"P2_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">   P3_signal=sem_open(<span class="string">"P3_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>P1进程执行完打印任务之后对P1_signal信号量进行V操作，产生一个资源让等待P1_signal的进程P2和P3其中之一可以执行。由于P2和P3都是等待P1_signal信号量，但是P1进程只产生一个单位的信号，所以P2和P3的执行是互斥的，这样就满足了题目要求。最后在P2和P3执行完打印任务后对信号量P2_signal和P3_signal进行V操作从各产生一个单位的信号量，而进程P4会等待P2_signal和P3_signal，所以知道当P2和P3进程都完成才能进行P4进程。通过控制这三个信号量，这四个进程之间的前驱关系就满足了题目要求。

![](http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173752.jpg)</code></pre><ul>
<li><p>进程产生实现</p>
<p>根据题目要求，通过fork的方式产生四个进程。fork函数会从当前位置复制进程，并且在父进程中返回的pid为复制进程的真实pid，在子进程中返回的pid为0。了解这些知识之后可以得到如下的流程图：</p>
<p>下面的流程图仅表示进程间的关系，前驱关系的实现请看上一小节.</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173757.jpg" alt></p>
</li>
<li><p>进程树</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173803.jpg" alt></p>
</li>
</ul>
<ol start="3">
<li><p>编译源码</p>
<p>通过下面的命令编译源码，得到可执行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g task1.c -o task1 -lpthrea</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-3-实验结果"><a href="#1-3-实验结果" class="headerlink" title="1.3 实验结果"></a>1.3 实验结果</h3><p>$\qquad$通过上面的实验已经得到满足实验要求的可执行程序task1,下面给出运行结果，经过多次测试，四个进程在屏幕上打印的顺序只有两种结果，分别如下：</p>
<ol>
<li><p>顺序1：<code>P1--&gt;P2--&gt;P3--&gt;P4</code></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173808.jpg" alt></p>
</li>
<li><p>顺序2：<code>P1--&gt;P3--P2--&gt;P4</code></p>
</li>
</ol>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173812.jpg" alt></p>
<h3 id="1-4-现象解释"><a href="#1-4-现象解释" class="headerlink" title="1.4 现象解释"></a>1.4 现象解释</h3><p>$\qquad$测试的实验结果中出现两种执行顺序，通过1.2 节中的分析不难解释这种现象，由于P1是P2和P3的前驱，所以P1一定会在P2和P3之前执行，但是P2和P3是互斥关系，这两个进程谁先获得P1产生的信号量谁就先执行另一个进程等待。最后等P2和P3都执行完了再执行P4，所以会出现上面的两种执行顺序。</p>
<h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="2-1-实验要求"><a href="#2-1-实验要求" class="headerlink" title="2.1 实验要求"></a>2.1 实验要求</h3><p>$\qquad$火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。</p>
<h3 id="2-2-实验过程"><a href="#2-2-实验过程" class="headerlink" title="2.2 实验过程"></a>2.2 实验过程</h3><h4 id="2-2-1未添加同步机制"><a href="#2-2-1未添加同步机制" class="headerlink" title="2.2.1未添加同步机制"></a>2.2.1未添加同步机制</h4><ol>
<li><p>实验源码</p>
<p><code>task2_1.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ticketCount=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">SaleThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"卖%d张票,剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		<span class="comment">//放弃CPU，强制切换到另外一个进程</span></span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp<span class="number">-1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RefundThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"退%d张票，剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp+<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请正确输入参数！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="comment">/* printf("%s %s",argv[1],argv[2]); */</span></span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,SaleThread,argv[<span class="number">1</span>]);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,RefundThread,argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最终票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>在main函数中创建两个线程，分别是模拟售票的线程<code>SaleThread</code>和模拟退票的线程<code>RefundThread</code>，两个进程并发执行，不添加任何的同步机制。</li>
<li>模拟票数的变量ticketCount是全局变量</li>
<li>程序运行需要输入两个参数，第一个是售票数量，第二个数退票数量</li>
</ul>
</li>
<li><p>程序运行结果</p>
<p>编译上述程序，得到可执行程序<code>task2_1</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g  task2_1.c -o task2_1 -lpthread</span><br></pre></td></tr></table></figure>

<p>多次测试运行，运行结果可以分为两种类型，一种是售票数量比退票数量多，另一种是售票数量比退票数量少。两种情况的结果分别如下：</p>
<ul>
<li><p>售票数量比退票数量多：</p>
<p>初始票数：1000      售票：100     退票：40</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173819.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>售票数量比退票数量少：</p>
<p>初始票数：1000    售票：50    退票：80</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173823.jpg" alt></p>
</li>
</ul>
<ol start="4">
<li><p>实验现象归纳</p>
<p>通过一系列的测试，归纳出的实现现象如下：</p>
<ul>
<li>当售票数量大于退票数量的时候，最终票数等于总票数减去售票数</li>
<li>当售票数量小于退票数量的时候，最终票数等于总票数加上退票数</li>
</ul>
</li>
</ol>
<h4 id="2-2-2-添加同步机制"><a href="#2-2-2-添加同步机制" class="headerlink" title="2.2.2 添加同步机制"></a>2.2.2 添加同步机制</h4><ol>
<li><p>实验源码</p>
<p><code>task2_2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> ticketCount=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">sem_t</span> *flag=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">SaleThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"卖%d张票,剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		sem_wait(flag);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		<span class="comment">//放弃CPU，强制切换到另外一个进程</span></span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp<span class="number">-1</span>;</span><br><span class="line">		ticketCount-=<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">		sem_post(flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RefundThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"退%d张票，剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		sem_wait(flag);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp+<span class="number">1</span>;</span><br><span class="line">		ticketCount+=<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">		sem_post(flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请正确输入参数！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flag=sem_open(<span class="string">"flag"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s %s"</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,SaleThread,argv[<span class="number">1</span>]);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,RefundThread,argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最终票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	sem_close(flag);</span><br><span class="line">	sem_unlink(<span class="string">"flag"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li><p>task2_2.c在task2_1.c的基础上增加了同步机制，其他部分完全一致，通过信号量flag的控制，让售票线程和退票线程一次只能执行一个，在一个没有执行完成之前另一个不能进入执行，这样就保证了售票操作和退票操作的原子性，避免了脏数据的读取。</p>
</li>
<li><p>flag初始值为设置为1，表示每次只允许一个线程操作ticketCount这个数据</p>
</li>
<li><p>售票线程和退票线程在进入操作之前都要sem_wait(flag)，等待信号量，在完成操作之后要sem_post(flag)，下图是售票线程中增加了信号量的操作：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173828.jpg" alt></p>
</li>
</ul>
</li>
<li><p>程序运行结果</p>
<p>编译上述程序，得到可执行程序task2_2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task2_2.c -o task2_2 -lpthread</span><br></pre></td></tr></table></figure>

<p>多次测试运行，测试主要分为两种类型，一种是售票数量比退票数量多，另一种是售票数量比退票数量少。两种情况的结果分别如下：</p>
<ul>
<li><p>售票数量比退票数量多：</p>
<p>初始票数：1000      售票：100     退票：40</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173833.jpg" alt></p>
</li>
<li><p>退票数量比售票数量多：</p>
<p>初始票数：1000    售票：50    退票：80</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173838.jpg" alt></p>
</li>
</ul>
</li>
<li><p>实验现象归纳</p>
<ul>
<li><p>在第一个测试样例中，初始票数为1000，售票100并且退票40，最终总票数为940，结果正确；</p>
</li>
<li><p>在第二个测试样例中，初始票数为1000，售票50并且退票80，最终总票数为1030，结果正确。</p>
</li>
</ul>
<ul>
<li><p>通过上面的测试结果可以看出，不论是售票数量比退票数量多还是少，都不会发生类似前面2.2.1的问题，最终的票数是期待得到的结果。</p>
</li>
<li><p>上面的实验证实了增加了同步机制之后的多线程并发程序有效的解决了脏数据的读取问题</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p> 通过2.2节的对比实验可以看出，在执行多进程并发程序的时候，由于多进程的切换可能发生在某个进程的中间，会导致在一个进程处理的数据未写入ticketCount之前另外一个进程读取该数据，这样就导致了脏数据的读取，导致最终结果的不正确。</p>
<p>在2.2节的后半部分通过怎加同步机制，保证售票进程和退票进程的的原子性，就是指在某个进程操作的时候，在它完成操作之前另外一个进程无法操作共享变量ticketCount,这样就避免了脏数据的发生，得到了预期的正确结果。</p>
<h3 id="2-4-现象解释"><a href="#2-4-现象解释" class="headerlink" title="2.4 现象解释"></a>2.4 现象解释</h3><h4 id="2-4-1-现象解释1"><a href="#2-4-1-现象解释1" class="headerlink" title="2.4.1 现象解释1"></a>2.4.1 现象解释1</h4><p>在2.2.1节的实验中，以售票线程为例（代码如下图所示），没有添加同步机制，并且在进行<code>temp=temp-1</code>和<code>temp=ticketCount</code>的后面均加上了pthread_yield，这个函数的作用是放弃对CPU的使用权，切换到其他进程中，本实验中就是切换到退票进程中。</p>
<p>这样就能解释为什么2.2.1节中的实验现象，在2.2.1节中，不论售票数多还是退票数多，最终结果都是总票数加上或减去值比较大的那个数。通过分析可以得出解释，售票进程和退票进程同时进行，初始票数均为1000，售票进程完成一次是票数为999，售票进程开始下一次售票，但是在运行<code>temp=ticketCount</code>之前，退票进程处理的数据还没有写入到内存中，导致售票进程读取的还是自己之前计算的ticketCount值，而不是全局的值。退票进程也是同理。</p>
<p>但是为什么刚好就是总票数加上或减去值比较大的那个呢？按照道理来说因该售票进程执行temp=ticketCount在退票进程写入ticketCount值之前发生是存在一定概率的，但是在目前为止的所有测试结果全部都是在写入之前读取ticketCount值，对此的解释是由于ticketCount=temp和temp=ticketCount之间没有加pthread_yield操作，而现代的处理器运算速度足够快，在退票进程放弃CPU控制权的那个时间片已经完成了这两步操作，所以相当于售票进程读取的ticketCount一直是自己本身的值，退票进程处理的数据对售票进程并没有影响。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173844.jpg" alt></p>
<p>为了验证上面的猜想，在=如下图所示代码，在ticketCount之后增加一行代码，pthread_yield，放弃当前进程对CPU的控制权，即售票进程放弃对CPU的控制权转而交给退票进程，这个时候退票进程处理的数据就能写入到内存中，而当售票进程再次处理temp=ticketCount的时候，读取的就是退票进程已经写入的数据。如果猜想正确的话，期待的最终票数因该还会发生错误，但并不是像第一中那种恰好等于总票数加减数值大的那个数。</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173849.jpg" alt></p>
<p>得到的结果如下，发现最终的票数不在是1000+50=1050，而是分布在1000~1050之间的数值。猜想得到验证。</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173854.jpg" alt></p>
<p>针对上面的猜想（CPU运算速度过快，导致ticketCount=temp和temp=ticketCount两步操作在一个进程的时间片内完成导致的数据错误），另外的一种验证方式是将初始票数和售票退票数设置的足够大，当数据足够大的时候，就会存在一定概率出现在一个进程的ticketCount=temp和temp=ticketCount两步操作之间切换进程的问题，得到的结果就不会类似2.2.1中的那样，而是类似在ticketCount=temp下面加了pthread_yield那样。</p>
 <div align="center">
     <img src width="600" div align="center"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173858.jpg" alt></p>
<p>再次运行，可以看到如下的实验结果：</p>
<div align="center">      <img src width="600" div align="center"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173903.jpg" alt></p>
<h4 id="2-4-2-现象解释2"><a href="#2-4-2-现象解释2" class="headerlink" title="2.4.2 现象解释2"></a>2.4.2 现象解释2</h4><p>在2.2.2节中，当给售票进程和退票进程都加上同步机制后，保证了每个线程操作的原子性，每个线程操作的过程中其他的线程不能对共享的ticketCount变量进程修改，这样的话最终的结果就是正确的结果。</p>
<h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="3-1-实验要求"><a href="#3-1-实验要求" class="headerlink" title="3.1 实验要求"></a>3.1 实验要求</h3><p>$\qquad$一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。</p>
<h3 id="3-2-实验过程"><a href="#3-2-实验过程" class="headerlink" title="3.2 实验过程"></a>3.2 实验过程</h3><ol>
<li><p>实验源码</p>
<p><code>task3.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">sem_t</span> *empty=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sem_t</span> *full=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		<span class="comment">/* fflush(stdin); */</span></span><br><span class="line">		<span class="comment">/* printf("输入："); */</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;buf[i]);</span><br><span class="line">		sem_post(full);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(full);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输出：%c\n"</span>,buf[i]);</span><br><span class="line">		sem_post(empty);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i=<span class="number">-1</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">"empty_"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">"full_"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,worker1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,worker2,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	sem_close(empty);</span><br><span class="line">	sem_close(full);</span><br><span class="line">	sem_unlink(<span class="string">"empty_"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"full_"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>work1是输入线程调用的函数，worker2是输出线程调用的函数。</li>
<li>设置两个信号量empty和ful来控制程序的执行，其中empty信号量用于保证输入线程在写入数据到缓存的时候缓存中还有空余的位置，保证写入线程后写入的数据不会把前面写入但是为输出的数据给覆盖掉，其初始值为10，表示最开始缓存中有10个空余的位置供给写入线程写入数据；full信号量是用于保证输出线程有数据输出，避免在写入线程还没有写入数据的情况下输出线程输出随机数据，其初始值为0，表示初始状态下缓存中没有数据可以输出</li>
<li>输入线程在写入一个数据前要等待empty信号量，进入后便消耗一个信号量；完成写入数据操作之后post一个full信号量，通知输出线程输出数据。</li>
<li>输出线程在输出一个数据之前哟啊等待full信号量，进出输出操作后便消耗一个full信号量；完成输出操作后post一个empty信号量，通知写入线程缓存又多一个空余位置以供写入数据。</li>
<li>输出线程每输出一个字符等待一秒钟，方便实验结果的查看。</li>
</ul>
</li>
<li><p>编译源代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task3.c -o task3 -lpthread</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-3-实验结果"><a href="#3-3-实验结果" class="headerlink" title="3.3 实验结果"></a>3.3 实验结果</h3><h4 id="3-3-1-实验运行现象"><a href="#3-3-1-实验运行现象" class="headerlink" title="3.3.1 实验运行现象"></a>3.3.1 实验运行现象</h4><ol>
<li><p>随机输入字母和数字（10个以内）：124365abc</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173913.jpg" alt></p>
</li>
<li><p>随机输入字母和数字(10个以上)：123456789abcdefg</p>
</li>
</ol>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173917.jpg" alt></p>
<ol start="3">
<li><p>不间断输入：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173920.jpg" alt></p>
<p>通过观察上面的实验现象，可以看到已经满足了实验题目的要求。</p>
</li>
</ol>
<h4 id="3-3-2-实验现象解释"><a href="#3-3-2-实验现象解释" class="headerlink" title="3.3.2 实验现象解释"></a>3.3.2 实验现象解释</h4><ul>
<li><p>在第一种类型的测试中，输入数据不大于10个字符的时候，由于empty的信号量初始值为10，所以输入进程会一直连续不断的向缓存中写入数据，每写入一个数据，便post一个full信号量，输出线程便能按序输出字符。</p>
</li>
<li><p>在第二种类型的测试中，输入数据大于10个字符的时候，由于empty的初始值为10，所以输入的字符中开始的时候只有前10个字符被写入缓存中，其他的在I/O缓冲区等待输入，当输出线程接收到输入线程post的信号量的时候便会开始输出，每输出一个字符便会post一个empty信号量，当输入线程接收到empty信号量的时候有开始从I/O缓冲区读取数据写入到缓存中。</p>
</li>
<li><p>第三种测试和第二种类似，在输出的过程中间输入数据，原理其实是一样的。</p>
</li>
</ul>
<h2 id="Task-4"><a href="#Task-4" class="headerlink" title="Task 4"></a>Task 4</h2><h3 id="4-1-实验要求"><a href="#4-1-实验要求" class="headerlink" title="4.1 实验要求"></a>4.1 实验要求</h3><ol>
<li><p>通过实验测试，验证共享内存的代码中，receiver能否正确读出sender发送的字符串？如果把其中互斥的代码删除，观察实验结果有何不同？如果在发送和接收进程中打印输出共享内存地址，他们是否相同，为什么？</p>
</li>
<li><p>有名管道和无名管道通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？</p>
</li>
<li><p>消息通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？</p>
</li>
</ol>
<h3 id="4-2-实验过程"><a href="#4-2-实验过程" class="headerlink" title="4.2 实验过程"></a>4.2 实验过程</h3><blockquote>
<p>实验过程根据实验要求的三个部分，对应的过程也分为三个部分，具体如下所示</p>
</blockquote>
<h4 id="4-2-1-内存共享"><a href="#4-2-1-内存共享" class="headerlink" title="4.2.1 内存共享"></a>4.2.1 内存共享</h4><ol>
<li><p>实验源码</p>
<blockquote>
<p>内存内存共享实验的源码分为两个部分，分别是Sender.c和Receive.c,</p>
</blockquote>
<p><code>Sender.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filename: Sender.c</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span>  key;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.Product the key</span></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">//2. Creat semaphore for visit the shared memory</span></span><br><span class="line">    sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. init the semaphore, sem=0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line">    <span class="keyword">char</span> *shm_ptr;</span><br><span class="line">    shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. Operation procedure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;      <span class="comment">//first sem(index=0)</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;           <span class="comment">//Increase 1,make sem=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"semop"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shm_ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Receiver.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span>  key;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.Product the key</span></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">//2. Creat semaphore for visit the shared memory</span></span><br><span class="line">    sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. init the semaphore, sem=0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line">    <span class="keyword">char</span> *shm_ptr;</span><br><span class="line">    shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. Operation procedure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;      <span class="comment">//first sem(index=0)</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;           <span class="comment">//Increase 1,make sem=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nNow, receive message process running:\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tThe message is : %s\n"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"semop"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nExit the receiver process now!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shm_ptr);</span><br><span class="line">    <span class="comment">//7. delete the shared memory</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8. delete the semaphore</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == semctl(sem_id, <span class="number">0</span>, IPC_RMID))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<blockquote>
<p>下面以sender.c为例解释一下如何创建共享内存并通过信号量机制实现互斥访问从而达到进程间通信的目的。</p>
</blockquote>
<ul>
<li><p>创建一个共享内存的ID,就是代码中的key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">key_t</span>  key;</span><br><span class="line">key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 通过ftok函数创建一个key_t类型的变量，作为共享内存的key，ftok函数的两个参数分别是文档名(一个存在的路径),上例中的路径是<code>.</code>表示当前路径，另一个参数是子序号</p>
</blockquote>
</li>
<li><p>创建并初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sem_id;</span><br><span class="line">sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"semget"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"semctl"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过semget()函数创建一个信号量，初始值为1，再通过semctl()函数初始化该信号量</p>
</blockquote>
</li>
<li><p>创建共享内存并挂载在进程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"shmget"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line"><span class="keyword">char</span> *shm_ptr;</span><br><span class="line">shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"shmat"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这部分代码中，首先通过shmget()函数创建了一个大小为1000B的共享内存，然后通过shmat函数，将刚刚创建的共享内存以可读写的方式挂载在进程上，并且指定系统将自动选择一个合适的地址给共享内存，将挂载的共享内存地址赋值给char型指针shm_ptr</p>
</blockquote>
</li>
<li><p>Sender主循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主循环中首先判断表示共享内存访问情况的信号量是否为0(为0表示共享内存空闲)，如果为0的话提示用户输入想要输入的消息，并将用户输入的消息写入共享内存中，写完后通过semop函数将信号量加一，通知receiver读取消息。并且定义一个<code>end</code>命令表示退出当前进程。循环退出的时候取消共享内存的挂载</p>
</blockquote>
</li>
<li><p>Receiver主循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nNow, receive message process running:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tThe message is : %s\n"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit the receiver process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主循环中首先判断表示共享内存访问情况的信号量是否为1(为1表示共享内存已经写入消息，可以读取)，如果为1的话输出该消息，输出后通过semop函数将信号量减1，通知Sender可以再次写入消息。并且定义一个<code>end</code>命令表示退出当前进程。循环退出的时候取消共享内存的挂载</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实验现象</p>
<p>将上述源码编译后进行测试，得到下面的结果。</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173932.jpg" alt></p>
<blockquote>
<p>可以看到sender进程发出的消息receiver进程均准确无误的收到</p>
</blockquote>
</li>
<li><p>删除互斥访问相关的代码</p>
<p>程序主要的代码没有变化，只是在Sender和Receiver进程的主循环中将用于控制互斥访问共享内存的相关代码删除，注释后的结果如下：</p>
<p><code>Sender_2.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Receiver_2.c:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\nNow, receive message process running:\n&quot;);</span><br><span class="line">    printf(&quot;\tThe message is : %s\n&quot;, shm_ptr);</span><br><span class="line"></span><br><span class="line">    //if enter &quot;end&quot;, then end the process</span><br><span class="line">    if(0 == (strcmp(shm_ptr ,&quot;end&quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\nExit the receiver process now!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后加一个sleep(1)用于控制打印的速度，便于观察现象</p>
</blockquote>
</li>
<li><p>删除互斥访问后的实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173937.jpg" alt></p>
<blockquote>
<p>实验现象解释：当删除互斥访问之后，两个进程便没有限制的访问共享内存，Sender进程由于受限于用户输入的速度，会停留一直等待用户输入数据，但是Receiver进程会一直输出共享内存中的消息。</p>
</blockquote>
</li>
<li><p>打印Sender和Receiver进程中共享内存的地址</p>
<p>在原始代码的基础上修改，具体代码文件分别是<code>Sender_3.c</code>和<code>Receiver_3.c</code>，具体修改就是如下：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173942.jpg" alt></p>
<p>在挂载共享内存后打印挂载后的地址</p>
</li>
<li><p>打印共享内存地址实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173945.jpg" alt></p>
<blockquote>
<p>可以看到实验现象，在两个进程中共享内存的地址不一样</p>
</blockquote>
<p>==<strong>现象解释：</strong>==</p>
<p>通过上面的现象可以看到共享内存在不同进程中是不相同的，总结有以下的原因导致共享内存在不同进程中的地址不一样：</p>
<ul>
<li>进程在挂载内存的时候使用的<code>shmat()</code>函数中的第二个参数使用的是NULL，NULL参数的含义是进程让系统分配给共享内存合适的地址。在<code>shmat()</code>函数中，第二个参数有三种选择，分别是：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数值</th>
<th align="center">NULL</th>
<th align="center">addr</th>
<th align="center">addr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">系统将自动选择一个合适的地址</td>
<td align="center">如果shmaddr非0 并且指定了SHM_RND 则此段连接到shmaddr -（shmaddr mod SHMLAB)所表示的地址上。</td>
<td align="center">第三个参数如果在flag中指定了SHM_RDONLY位，则以只读方式连接此段，否则以读写的方式连接此 段。</td>
</tr>
</tbody></table>
<p>​    可以看到，当addr有具体的值的时候，便将共享内存挂载到指定的地址上</p>
<ul>
<li>现代操作系统中都存在ASLR(地址空间随机化)，ASLR是⼀种针对缓冲区溢出的安全保护机制，具有ASLR机制的操作系统每次加载到内存的程序起始地址会随机变化。系统的这个随机化操作可能导致共享内存的地址不一致。</li>
</ul>
<p>==<strong>验证：</strong>==</p>
<ol>
<li><p>指定Sender_4.c和Receiver_4.c中共享内存的挂载地址为<code>0x7fcc2c0bb000</code></p>
<ul>
<li><p>修改具体的代码如下：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173951.jpg" alt></p>
</li>
<li><p>运行结果：</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173955.jpg" alt></p>
<blockquote>
<p>实验结果结果佐证了上面的现象解释，通过指定挂载共享内存的地址，可以使共享内存的地址一致，可以随意指定改地址</p>
</blockquote>
</li>
</ul>
</li>
<li><p>关闭系统的ASLR操作</p>
</li>
</ol>
<ul>
<li>具体的关闭命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   sudo su</span><br><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>+ 运行结果：

  &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;&quot; width=&quot;800&quot; /&gt;&lt;/div&gt;

  ![](http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174000.jpg)

  &gt; 这个实验现象也佐证了系统的ASLR也对导致挂载的共享内存地址不一样</code></pre><h4 id="4-2-2-管道通信"><a href="#4-2-2-管道通信" class="headerlink" title="4.2.2 管道通信"></a>4.2.2 管道通信</h4><h5 id="（1）无名管道"><a href="#（1）无名管道" class="headerlink" title="（1）无名管道"></a>（1）无名管道</h5><ol>
<li><p>实验源码</p>
<p><code>pipe.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     //for pipe()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;     //for memset()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     //for exit()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pipe(fd))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd[<span class="number">1</span>], <span class="string">"hello,world"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(fd[<span class="number">0</span>], buf, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The message is: %s\n"</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>通过pipe函数创建管道，函数传递一个整形数组fd，fd的两个整形数表示的是两个文件描述符，其中第一个用于读取数据，第二个用于写数据。两个描述符相当远管道的两端，一段负责写数据，一段负责读数据。</li>
<li>pipe管道是半双工的工作模式，某一时刻只能读或者只能写</li>
<li>读写管道就和读写普通文件一样，使用write和read</li>
</ul>
</li>
<li><p>实验现象</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174009.jpg" alt></p>
</li>
<li><p>无名管道同步机制验证</p>
<blockquote>
<p>为了验证无名管道的同步机制，在上述代码的基础上进行修改，得到如下的代码</p>
</blockquote>
<p><code>pipe_2.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     //for pipe()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;     //for memset()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     //for exit()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == pipe(fd))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	child=fork();</span><br><span class="line">	<span class="keyword">if</span>(child==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="string">"EXIT_FAILURE"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭子进程中不需要的写描述符</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf))&gt;<span class="number">0</span>)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"子进程接收的消息是:%s\n"</span>,buf);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"子进程:管道中没有数据\n"</span>);</span><br><span class="line">			sleep(<span class="number">2</span>);		</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"end"</span>)==<span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(child&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"父进程中-请输入消息:"</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">			write(fd[<span class="number">1</span>],buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"end"</span>)==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于上述代码做出如下解释：父进程是消息的发送者，在父进程中创建了两个文件描述符，fork一个子进程的时候会复制这两个管道文件描述符，因此父进程和子进程都会将自己的那个用不到的文件描述符关闭。父进程中会持续向管道中写入用户输入的消息，子进程会一直输出管道中的消息，如果管道中没有消息就会阻塞等待。</p>
</blockquote>
</li>
<li><p>无名管道同步机制实验现象</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174012.jpg" alt></p>
<blockquote>
<p>可以看到输出进程是按照输入进程输入的顺序输出数据，并且当输入进程没有数据输入，即管道中没有数据的时候，输出进程会阻塞。因此无名管道通信系统调用的时候已经yijing实现了同步机制</p>
</blockquote>
</li>
<li><p>无名管道同步机制原理</p>
<p>通过上面的实验和查阅相关资料，得到无名管道如下的同步机制：</p>
<ul>
<li><p>管道的读写通过两个系统调用write和read实现</p>
</li>
<li><p>发送者在向管道内存中写入数据之前，首先<strong>检查内存是否被读进程锁定</strong>和<strong>内存中是否还有剩余空间</strong>，如果这两个要求都满足的话write函数会对内存上锁，然后进行写入数据，写完之后解锁；否则就会等待(阻塞)。</p>
</li>
<li><p>写进程在读取管道中的数据之前，也会<strong>检查内存是否被读进程锁定</strong>和<strong>管道内存中是否有数据</strong>，如果满足这两个条件，read函数会对内存上锁，读取数据后在解锁；否则会等到(阻塞)</p>
</li>
</ul>
</li>
</ol>
<h5 id="（2）有名管道"><a href="#（2）有名管道" class="headerlink" title="（2）有名管道"></a>（2）有名管道</h5><ol>
<li><p>实验代码</p>
<blockquote>
<p>有名管道实验中设计两个代码文件<code>fifo_send.c</code>和<code>fifo_rcv.c</code></p>
</blockquote>
<p><code>fifo_send.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"./my_fifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"hello,world"</span>;</span><br><span class="line">    <span class="comment">//1. check the fifo file existed or not</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = access(FIFO, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)    <span class="comment">//file /tmp/my_fifo existed</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="number">-1</span> == mkfifo(FIFO, <span class="number">0766</span>))</span><br><span class="line">    	&#123;</span><br><span class="line">    	    perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">    	    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.Open the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> fifo_fd;</span><br><span class="line">    fifo_fd = open(FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. write the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = write(fifo_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="keyword">sizeof</span>(buf))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write the message ok!\n"</span>);</span><br><span class="line"></span><br><span class="line">    close(fifo_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fifo_rcv.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *File: fifo_rcv.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"./my_fifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`. check the fifo file existed or not</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = access(FIFO, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)    <span class="comment">//file /tmp/my_fifo existed</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==mkfifo(FIFO,<span class="number">0766</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo"</span>); </span><br><span class="line">            <span class="built_in">exit</span>(<span class="string">"EXIT_FAILURE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	2.Open the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> fifo_fd;</span><br><span class="line">    fifo_fd = open(FIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. read the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = read(fifo_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Read %d words: %s\n"</span>, num, buf);</span><br><span class="line">    close(fifo_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>写进程fifo_send分为四个步骤执行，首先判断当前目录下是否已经存在my_fifo文件，不存在的话在当前目录下通过mkfifo()函数创建FIFO类型的文件my_fifo；再通过open()函数打开my_fifo文件，最后向文件中写入消息；</li>
<li>读进程的过程和写进程的类似，只没有了创建fifo文件的过程而已</li>
</ul>
</li>
<li><p>实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174019.jpg" alt></p>
<blockquote>
<p>现象描述：在仅仅只运行fifo_send进程的时候，没有任何输出，进程一直阻塞，直到fifo_rcv进程运行，两个进程才开始输出信息。</p>
</blockquote>
<p>当写进程和读进程都设置成阻塞状态的时候，不论先执行那个进程，先执行的进程都会阻塞等待，待另一个进程执行后两个进程才正常执行。</p>
</li>
<li><p>探究有名管道的同步和阻塞机制</p>
<p>通过<code>fifo_fd=open(FIFO,O_RDONLY | O_NONBLOCK)</code>设置为非阻塞状态，<code>fifo_fd=open(FIFO,O_RDONLY)</code>设置为阻塞状态，对应四个进程分别为fifo_send(阻塞)、fifo_rcv(阻塞)、fifo_send_1(非阻塞)、fifo_rcv_1(非阻塞)</p>
<ul>
<li><p>读进程阻塞、写进程阻塞</p>
<ul>
<li><p>先执行fifo_send后执行fifo_rcv，结果正确</p>
<p>截图请见上面的实验现象</p>
</li>
<li><p>先执行fifo_rcv后执行fifo_send，结果正确</p>
</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174023.jpg" alt></p>
<p>具体的原因是读进程在open FIFO的时候由于没有s</p>
<p>通过查阅资料得到了FIFO管道的阻塞机制如下：</p>
<p>对于设置了阻塞的读进程而言：</p>
<blockquote>
<ol>
<li>读进程阻塞的原因有三种：FIFO 中没有数据、有其他的读进程正在读取这些数据、没有写进程打开FIFO文件</li>
<li>不论是哪种原因引起的阻塞，解开阻塞的原因都是FIFO有新的数据写入</li>
<li>如果一个读进程有多个read操作，那么只会阻塞第一个read，其他的不会发生阻塞</li>
</ol>
</blockquote>
<p>对于设置了阻塞的写进程而言：</p>
</li>
</ul>
<blockquote>
<ol>
<li>当写入的数据量小于PIPE_BUF时，Linux保证写入原子性。如果此时管道中的空闲位置不足以容纳要写入的数据，泽写进程阻塞，直到管道中空间足够，一次性写入所有数据</li>
<li>当写入的数据量大于PIPE_BUF时，Linux不再保证写入的原子性。一旦管道中有空闲位置便尝试写入数据，直到所有数据写入完成后返回。</li>
</ol>
</blockquote>
<ul>
<li><p>读进程阻塞，写进程非阻塞</p>
<ul>
<li>先执行fifo_send_1后执行fifo_rcv，写进程open函数返回-1</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174026.jpg" alt></p>
<ul>
<li>先执行fifo_rcv后执行fifo_send_1，结果正常</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174030.jpg" alt></p>
</li>
<li><p>读进程非阻塞，写进程阻塞</p>
<ul>
<li>先执行fifo_send后执行fifo_rcv_1,结果正常</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174035.jpg" alt></p>
<ul>
<li>先执行fifo_rcv_1后执行fifo_send，程序崩溃</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174039.jpg" alt></p>
</li>
<li><p>读写进程都是非阻塞</p>
<ul>
<li>先执行fifo_send_1后执行fifo_rcv_1</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174043.jpg" alt></p>
<ul>
<li>先执行fifo_rcv_1后执行fifo_send_1</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174046.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<h4 id="4-2-3-消息队列"><a href="#4-2-3-消息队列" class="headerlink" title="4.2.3 消息队列"></a>4.2.3 消息队列</h4><ol>
<li><p>实验代码</p>
<blockquote>
<p>本实验代码文件分为Server.c和Client.c两个</p>
</blockquote>
<p><code>Server.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Rebuild the strcut (must be)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. creat a mseg queue</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgId;</span><br><span class="line">    </span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    msgId = msgget(key, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgId)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process (%s) is started, pid=%d\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm(<span class="number">0</span>);</span><br><span class="line">        alarm(<span class="number">600</span>);     <span class="comment">//if doesn't receive messge in 600s, timeout &amp; exit</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">rcvBuf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;rcvBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(struct msgbuf));</span><br><span class="line">        msgrcv(msgId, &amp;rcvBuf, BUF_SIZE, <span class="number">1</span>, <span class="number">0</span>);                </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Receive msg: %s\n"</span>, rcvBuf.mtext);</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sndBuf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;sndBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sndBuf));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncpy</span>((sndBuf.mtext), (rcvBuf.mtext), <span class="built_in">strlen</span>(rcvBuf.mtext)+<span class="number">1</span>);</span><br><span class="line">        sndBuf.mtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == msgsnd(msgId, &amp;sndBuf, <span class="built_in">strlen</span>(rcvBuf.mtext)+<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//if scanf "end~", exit</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"end~"</span>, rcvBuf.mtext))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d exit~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Rebuild the strcut (must be)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. creat a mseg queue</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgId;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d started~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line"></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    msgId = msgget(key, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgId)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. creat a sub process, wait the server message</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (pid = fork()))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"vfork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//In child process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            alarm(<span class="number">0</span>);</span><br><span class="line">            alarm(<span class="number">100</span>);     <span class="comment">//if doesn't receive messge in 100s, timeout &amp; exit</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">rcvBuf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;rcvBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(struct msgbuf));</span><br><span class="line">            msgrcv(msgId, &amp;rcvBuf, BUF_SIZE, <span class="number">2</span>, <span class="number">0</span>);                </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Server said: %s\n"</span>, rcvBuf.mtext);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//parent process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sndBuf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;sndBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sndBuf));</span><br><span class="line">            <span class="keyword">char</span> buf[BUF_SIZE] ;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nInput snd mesg: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">strncpy</span>(sndBuf.mtext, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">            sndBuf.mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == msgsnd(msgId, &amp;sndBuf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">//if scanf "end~", exit</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"end~"</span>, buf))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d exit~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li><p>程序分为服务器端和客户端，客户端向服务器发起通信，服务器端收到数据后将一模一样的数据返回</p>
</li>
<li><p>通过mgsrcv函数读取客户端传过来的消息，msgrcv的参数列表见下面。</p>
<p><code>int msgrcv(int msqid, void  *ptr, size_t  length, long  type, int  flag);</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">msgid</th>
<th align="center">ptr</th>
<th align="center">length</th>
<th align="center">type</th>
<th align="center">flag</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">消息队列标识符</td>
<td align="center">消息缓冲区指针</td>
<td align="center">消息数据长度</td>
<td align="center">决定从队列中返回那一条下消息</td>
<td align="center">阻塞与否</td>
</tr>
<tr>
<td align="center">备注</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">=0 返回消息队列中第一条消息<br>&gt;0 返回消息队列中等于mtype 类型的第一条消息。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&lt;0 返回mtype&lt;=type 绝对值最小值的第一条消息。</td>
<td align="center">msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>通过msgsnd函数向消息队列中加入消息，msgsnd的参数列表见下面。</li>
</ul>
<p><code>int msgsnd(int  msqid, const  void   *ptr, size_t    length, int   flag);</code></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">msgid</th>
<th align="center">ptr</th>
<th align="center">length</th>
<th align="center">flag</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">消息队列标识符</td>
<td align="center">消息缓冲区指针</td>
<td align="center">消息数据长度</td>
<td align="center">阻塞与否</td>
</tr>
<tr>
<td align="center">备注</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式</td>
</tr>
</tbody></table>
<ul>
<li>客户端的子进程主要负责消息的接受，父进程主要负责消息的发送；</li>
<li>通过分析上面的代码可以知道，客户端和服务器端都是以阻塞的方式读取和写入消息</li>
</ul>
</li>
<li><p>程序运行结果</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174053.jpg" alt></p>
</li>
<li><p>探究消息队列的同步和阻塞机制</p>
<blockquote>
<p>通过上面的程序解释中可以看出，消息队列通过msgrcv和msgsnd两个函数的flag参数控制是否阻塞，将其设置为IPC_NOWAIT表示不阻塞；如果客户端和服务器端都设置阻塞话，就可以达到同步的目的</p>
</blockquote>
<p>现在做出如下探究：</p>
<ul>
<li>客服端不阻塞(代码为Client_1.c),服务器端阻塞，得到结果如下。</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174058.jpg" alt></p>
<blockquote>
<p>可以看到当客户端不阻塞的话在客户端接受服务器端消息的时候会无限制的打印消息队列中的空消息，哪怕消息队列中没有任何消息</p>
</blockquote>
<ul>
<li>客户端阻塞，服务器端不阻塞(代码为Server_1.c)</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174105.jpg" alt></p>
<blockquote>
<p>可以看到当服务器端没有设置阻塞的时候，服务器端会一直接受消息队列中的空消息并向客户端转发。 </p>
</blockquote>
</li>
</ol>
<h2 id="Task-5"><a href="#Task-5" class="headerlink" title="Task 5"></a>Task 5</h2><blockquote>
<p>本实验分析进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。</p>
</blockquote>
<p>我们首先从<code>devices/timer.c</code>文件中的timer_sleep函数开始 分析，下面是该函数的具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sleeps for approximately TICKS timer ticks.  Interrupts must</span></span><br><span class="line"><span class="comment">   be turned on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_sleep</span> <span class="params">(<span class="keyword">int64_t</span> ticks)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> start = timer_ticks ();</span><br><span class="line">  ASSERT (intr_get_level () == INTR_ON);</span><br><span class="line">  <span class="keyword">while</span> (timer_elapsed (start) &lt; ticks) </span><br><span class="line">    thread_yield ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始逐行分析这个函数，第5行的<code>timer_ticks</code>函数也在timer.c文件中，跳转到该函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the number of timer ticks since the OS booted. */</span></span><br><span class="line"><span class="keyword">int64_t</span> timer_ticks (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">int64_t</span> t = ticks;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timer_ticks</code>函数中第4行涉及一个名为intr_disable()的函数，该函数的具体定义在<code>devices/interrupt.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disables interrupts and returns the previous interrupt status. */</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_level <span class="title">intr_disable</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_get_level ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable interrupts by clearing the interrupt flag.</span></span><br><span class="line"><span class="comment">     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable</span></span><br><span class="line"><span class="comment">     Hardware Interrupts". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"cli"</span> : : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> old_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看看返回值<code>intr_level</code>是个什么结构,代码在<code>devices/interrupt.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts on or off? */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level </span><br><span class="line">  &#123;</span><br><span class="line">    INTR_OFF,             <span class="comment">/* Interrupts disabled. */</span></span><br><span class="line">    INTR_ON               <span class="comment">/* Interrupts enabled. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，intr_level这个枚举类型表示的是是否允许中断。于是分析得到<code>intr_disable</code>函数做了两件事。1. 调用<code>intr_old_level</code>函数 2. 直接执行汇编代码保证这个线程不能被中断。之后返回调用<code>intr_old_level</code>函数的返回值。</p>
<p>再看看<code>intr_get_level</code>函数的实现细节，该函数的定义也在<code>devices/interrupt.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current interrupt status. */</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_level <span class="title">intr_get_level</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line">  <span class="comment">/* Push the flags register on the processor stack, then pop the</span></span><br><span class="line"><span class="comment">     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"</span></span><br><span class="line"><span class="comment">     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware</span></span><br><span class="line"><span class="comment">     Interrupts". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"pushfl; popl %0"</span> : <span class="string">"=g"</span> (flags))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> flags &amp; FLAG_IF ? INTR_ON : INTR_OFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释信息和分析汇编代码可以知道，<code>intr_get_level</code>这个函数的作用是返回当前的中断状态。<code>intr_get_level</code>函数弄清楚了之后，返回上一层函数中，到了<code>intr_disable</code>函数中，这样就可以清楚的知道<code>intr_disable</code>函数的作用：</p>
<ul>
<li>获取当前中断状态</li>
<li>将当前中断状态更改为不可中断</li>
<li>返回先前的中断状态</li>
</ul>
<p>弄清楚了<code>intr_disable</code>函数，接着看<code>timer_ticks</code>函数的5、6、7行</p>
<ul>
<li><p>第5行通过一个int64_t类型的变量t获取全局变量ticks的值；</p>
</li>
<li><p>第6行<code>intr_set_level(old_level)</code>表示将当前中断状态设置为之前的中断状态。</p>
</li>
<li><p>第7行返回t</p>
</li>
</ul>
<p>这样，函数<code>timer_ticks</code>的含义也就弄清楚了。其实<code>timer_ticks</code>函数的作用很简单，就是想获取当前系统的ticks值而已，而上面通过这么大篇幅的介绍<code>timer_ticks</code>函数的4、6两行的作用，原因是第4行和第6行通过先关闭中断，待t获取到ticks值之后载恢复之前的中断状态，来保证操作的原子性，简单的说就是在t获取全局变量ticks的值的时候，不能被打断。</p>
<p>然后接着分析<code>timer_sleep</code>函数的第6行<code>ASSERT (intr_get_level () == INTR_ON);</code>这里是一个断言，当<code>intr_get_lvel</code>函数获取的当前中断状态不是<code>INTR_ON</code>的时候发生警告且退出。</p>
<p><code>timer_sleep</code>函数剩下的就是一个循环了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (timer_elapsed (start) &lt; ticks) </span><br><span class="line">    thread_yield ();</span><br></pre></td></tr></table></figure>

<p>通过分析不难得出<code>timer_elapsed()</code>函数的作用是计算当前的系统ticks减去之前得到的start的差值，如果这个差值小于函数参数ticks的话一直执行thread_yield()函数。</p>
<p>再看看<code>thread_yield</code>函数的具体定义（在<code>thread/thread.c文件中</code>），分析一下该函数的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Yields the CPU.  The current thread is not put to sleep and</span></span><br><span class="line"><span class="comment">   may be scheduled again immediately at the scheduler's whim. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_yield</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">if</span> (cur != idle_thread) </span><br><span class="line">    list_push_back (&amp;ready_list, &amp;cur-&gt;elem);</span><br><span class="line">  cur-&gt;status = THREAD_READY;</span><br><span class="line">  schedule ();</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thread_yield</code>函数第5行顾名思义，作用就是返回当前正在运行的线程，通过一个thread类型的结构体指针接受该函数返回值。</p>
<p><code>thread_yield</code>函数的第7行通过断言的方式判断中断类型，如果是由于I/O等引起的硬中断则退出，如果是软中断的话正常运行。</p>
<p>再看第8行和第13行的之前也分析过，这是保证9-12行操作的原子性。</p>
<p>再分析9-12行：</p>
<ul>
<li>9-10行：如何当前线程不是空闲的线程就调用list_push_back把当前线程的元素扔到就绪队列里面， </li>
<li>11行：把线程改成THREAD_READY状态</li>
<li>12行：调用schedule函数</li>
</ul>
<p>再深入<code>schedule</code>函数(<code>thread/thread.c文件</code>)看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Schedules a new process.  At entry, interrupts must be off and</span></span><br><span class="line"><span class="comment">   the running process's state must have been changed from</span></span><br><span class="line"><span class="comment">   running to some other state.  This function finds another</span></span><br><span class="line"><span class="comment">   thread to run and switches to it.</span></span><br><span class="line"><span class="comment">   It's not safe to call printf() until thread_schedule_tail()</span></span><br><span class="line"><span class="comment">   has completed. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span> = <span class="title">next_thread_to_run</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line">  ASSERT (cur-&gt;status != THREAD_RUNNING);</span><br><span class="line">  ASSERT (is_thread (next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur != next)</span><br><span class="line">    prev = switch_threads (cur, next);</span><br><span class="line">  thread_schedule_tail (prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>schedule</code>函数首先获取当前正在运行的线程指针cur和下一个运行的线程next，之后是三个断言。</p>
<ul>
<li><code>ASSERT (intr_get_level () == INTR_OFF)</code>：保证中断状态是开启的</li>
<li><code>ASSERT (cur-&gt;status != THREAD_RUNNING)</code>：保证当前运行的线程是RUNNING_THREAD的</li>
<li><code>ASSERT (is_thread (next))</code>：保证下一个线程有效</li>
</ul>
<p>17-18行的作用是：如果当前线程和下一个要跑的线程不是同一个的话调用switch_threads返回给prev</p>
<p>下面再看看<code>switch_threads</code>函数(在<code>threads/switch.S</code>中)这是一个完全由汇编语言编写的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;threads/switch.h&quot;</span><br><span class="line"></span><br><span class="line">#### struct thread *switch_threads (struct thread *cur, struct thread *next);</span><br><span class="line">####</span><br><span class="line">#### Switches from CUR, which must be the running thread, to NEXT,</span><br><span class="line">#### which must also be running switch_threads(), returning CUR in</span><br><span class="line">#### NEXT&apos;s context.</span><br><span class="line">####</span><br><span class="line">#### This function works by assuming that the thread we&apos;re switching</span><br><span class="line">#### into is also running switch_threads().  Thus, all it has to do is</span><br><span class="line">#### preserve a few registers on the stack, then switch stacks and</span><br><span class="line">#### restore the registers.  As part of switching stacks we record the</span><br><span class="line">#### current stack pointer in CUR&apos;s thread structure.</span><br><span class="line"></span><br><span class="line">.globl switch_threads</span><br><span class="line">.func switch_threads</span><br><span class="line">switch_threads:</span><br><span class="line">	# Save caller&apos;s register state.</span><br><span class="line">	#</span><br><span class="line">	# Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,</span><br><span class="line">	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See</span><br><span class="line">	# [SysV-ABI-386] pages 3-11 and 3-12 for details.</span><br><span class="line">	#</span><br><span class="line">	# This stack frame must match the one set up by thread_create()</span><br><span class="line">	# in size.</span><br><span class="line">	pushl %ebx</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line"></span><br><span class="line">	# Get offsetof (struct thread, stack).</span><br><span class="line">.globl thread_stack_ofs</span><br><span class="line">	mov thread_stack_ofs, %edx</span><br><span class="line"></span><br><span class="line">	# Save current stack pointer to old thread&apos;s stack, if any.</span><br><span class="line">	movl SWITCH_CUR(%esp), %eax</span><br><span class="line">	movl %esp, (%eax,%edx,1)</span><br><span class="line"></span><br><span class="line">	# Restore stack pointer from new thread&apos;s stack.</span><br><span class="line">	movl SWITCH_NEXT(%esp), %ecx</span><br><span class="line">	movl (%ecx,%edx,1), %esp</span><br><span class="line"></span><br><span class="line">	# Restore caller&apos;s register state.</span><br><span class="line">	popl %edi</span><br><span class="line">	popl %esi</span><br><span class="line">	popl %ebp</span><br><span class="line">	popl %ebx</span><br><span class="line">        ret</span><br><span class="line">.endfunc</span><br><span class="line"></span><br><span class="line">.globl switch_entry</span><br><span class="line">.func switch_entry</span><br><span class="line">switch_entry:</span><br><span class="line">	# Discard switch_threads() arguments.</span><br><span class="line">	addl $8, %esp</span><br><span class="line"></span><br><span class="line">	# Call thread_schedule_tail(prev).</span><br><span class="line">	pushl %eax</span><br><span class="line">.globl thread_schedule_tail</span><br><span class="line">	call thread_schedule_tail</span><br><span class="line">	addl $4, %esp</span><br><span class="line"></span><br><span class="line">	# Start thread proper.</span><br><span class="line">	ret</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure>

<p>分析这段汇编代码，首先将4个寄存器的值压栈保护寄存器状态，这四个寄存器的值是<code>switch_threads_frame</code>的成员，<code>switch_threads_frame</code>结构的具体定义如下(<code>thread/switch.h</code>中定义)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* switch_thread()'s stack frame. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">switch_threads_frame</span> </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> edi;               <span class="comment">/*  0: Saved %edi. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> esi;               <span class="comment">/*  4: Saved %esi. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;               <span class="comment">/*  8: Saved %ebp. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;               <span class="comment">/* 12: Saved %ebx. */</span></span><br><span class="line">    <span class="keyword">void</span> (*eip) (<span class="keyword">void</span>);         <span class="comment">/* 16: Return address. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span>;</span>         <span class="comment">/* 20: switch_threads()'s CUR argument. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span>;</span>        <span class="comment">/* 24: switch_threads()'s NEXT argument. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>全局变量<code>thread_stack_ofs</code>记录线程和栈之间的间隙，下面我们来看线程切换中保存现场的过程。</p>
<ul>
<li><p>35-36行：先把当前的线程指针放到eax中， 并把线程指针保存在相对基地址偏移量为edx的地址中</p>
</li>
<li><p>40-41: 切换到下一个线程的线程栈指针， 保存在ecx中， 再把这个线程相对基地址偏移量edx地址（上一次保存现场的时候存放的）放到esp当中继续执行。</p>
<blockquote>
<p>这里ecx, eax起容器的作用， edx指向当前现场保存的地址偏移量。简单来说就是保存当前线程状态， 恢复新线程之前保存的线程状态。</p>
</blockquote>
</li>
</ul>
<p>由此我们可以看出<code>schedule</code>函数是先将当前线程放入就绪队列，如果下一个线程和当前线程不一样的话切换到下一个线程。</p>
<p>再看看<code>shcedule</code>函数最后一行执行的操作，最后一行调用<code>thread_schedule_tail</code>函数，下面详细分析一下这个函数（<code>thread/thread.c</code>文件中）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_schedule_tail</span> <span class="params">(struct thread *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  </span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark us as running. */</span></span><br><span class="line">  cur-&gt;status = THREAD_RUNNING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start new time slice. */</span></span><br><span class="line">  thread_ticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USERPROG</span></span><br><span class="line">  <span class="comment">/* Activate the new address space. */</span></span><br><span class="line">  process_activate ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the thread we switched from is dying, destroy its struct</span></span><br><span class="line"><span class="comment">     thread.  This must happen late so that thread_exit() doesn't</span></span><br><span class="line"><span class="comment">     pull out the rug under itself.  (We don't free</span></span><br><span class="line"><span class="comment">     initial_thread because its memory was not obtained via</span></span><br><span class="line"><span class="comment">     palloc().) */</span></span><br><span class="line">  <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread) </span><br><span class="line">    &#123;</span><br><span class="line">      ASSERT (prev != cur);</span><br><span class="line">      palloc_free_page (prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是获得当前线程的的cur(切换之后的线程)，然后将cur的状态改为<code>THREAD_RUNNING</code>，然后thread_ticks清零开始新的线程切换时间片。然后调用diaoyong<code>process_activate</code>函数申请新的地址空间，再分析<code>process_active</code>函数(在<code>useruserprog/process.c</code>文件中定义)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sets up the CPU for running user code in the current</span></span><br><span class="line"><span class="comment">   thread.</span></span><br><span class="line"><span class="comment">   This function is called on every context switch. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_activate</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="comment">/* Activate thread's page tables. */</span></span><br><span class="line">  pagedir_activate (t-&gt;pagedir);</span><br><span class="line">  <span class="comment">/* Set thread's kernel stack for use in processing</span></span><br><span class="line"><span class="comment">     interrupts. */</span></span><br><span class="line">  tss_update ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的就是<code>pagedir_activate()</code>函数和<code>tss_update</code>函数，这两个函数分别位于<code>userprog/pagedir.c</code>和<code>userprog/tss.c</code>文件中</p>
<p>下面再进入<code>pagedir_activate()</code>函数中查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Loads page directory PD into the CPU's page directory base</span></span><br><span class="line"><span class="comment">   register. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagedir_activate</span> <span class="params">(<span class="keyword">uint32_t</span> *pd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    pd = init_page_dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the physical address of the page directory into CR3</span></span><br><span class="line"><span class="comment">     aka PDBR (page directory base register).  This activates our</span></span><br><span class="line"><span class="comment">     new page tables immediately.  See [IA32-v2a] "MOV--Move</span></span><br><span class="line"><span class="comment">     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base</span></span><br><span class="line"><span class="comment">     Address of the Page Directory". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%cr3"</span> : : <span class="string">"r"</span> (vtop (pd)) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个汇编指令将当前线程的页目录指针存储到CR3（页目录表物理内存基地址寄存器）中，也就是说这个函数更新了现在的页目录表</p>
<p>再进入<code>tss_update</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sets the ring 0 stack pointer in the TSS to point to the end</span></span><br><span class="line"><span class="comment">   of the thread stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tss_update</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (tss != <span class="literal">NULL</span>);</span><br><span class="line">  tss-&gt;esp0 = (<span class="keyword">uint8_t</span> *) thread_current () + PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tss指的是 task state segment， 叫任务状态段， 任务（进程）切换时的任务现场信息。这里其实是把TSS的一个栈指针指向了当前线程栈的尾部， 也就是更新了任务现场的信息和状态。</p>
<p>到此<code>process_activate</code>函数的分析完毕，它做了两件事：</p>
<ul>
<li>更新页目录表</li>
<li>更新任务现场信息（tss）</li>
</ul>
<p>在继续看<code>thread_schedule_tail</code>函数的最后4行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread) </span><br><span class="line">&#123;</span><br><span class="line">    ASSERT (prev != cur);</span><br><span class="line">    palloc_free_page (prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是说如果我们切换的线程状态是THREAD_DYING（代表欲要销毁的线程）的话， 调用palloc_free_page（<code>thread/palloc.c</code>文件中定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Frees the page at PAGE. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">palloc_free_page</span> <span class="params">(<span class="keyword">void</span> *page)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  palloc_free_multiple (page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单而言作用就是释放PAGE参数中的页面</p>
<p>到此，<code>thread_schedule_tail</code>函数分析完毕，其作用就是分配恢复之前执行的状态和现场， 如果当前线程死了就清空资源。</p>
<p><code>schedule</code>函数的作用就是拿下一个线程切换过来继续运行。<code>thread_yield</code>函数的作用是shi把当前进程放在就绪队列里，调用<code>schedule</code>切换到下一个进程。</p>
<p>最后返回到最顶层的<code>timer_sleep</code>函数，他的作用就是在ticks的时间内nei，如果线程处于running状态就不断的把它放在就绪队列不让它执行。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/lab2/" class="post-title-link" itemprop="url">进程实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:47:04" itemprop="dateCreated datePublished" datetime="2019-09-12T15:47:04+08:00">2019-09-12</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>3.8k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>3 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验二实验报告"><a href="#实验二实验报告" class="headerlink" title="实验二实验报告"></a>实验二实验报告</h1><blockquote>
<p>孙汉武    16281047    安全1601</p>
</blockquote>
<h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><h3 id="1-1-实验步骤"><a href="#1-1-实验步骤" class="headerlink" title="1.1 实验步骤"></a>1.1 实验步骤</h3><ol>
<li><p>打开一个vi进程</p>
</li>
<li><p>通过ps命令找到名字为vi的进程，命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -auxc | grep vi$</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171938.jpg" width="600">

<p>这里对该命令中的参数做出解释</p>
<ul>
<li><code>-aux</code>:    显示所有进程</li>
<li><code>-c</code>:            将command列输出更改为可执行文件名而不是命令名称</li>
<li><code>grep</code>         正则表达式搜索</li>
<li><code>vi$</code>           匹配结尾为vi字符串    </li>
</ul>
<p>这里对ps命令的输出结果每一列的含义做出解释，<code>ps -aux</code>命令的输出结果一共有十一列，从左往右分别是：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>列名</th>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>进程所属用户名</td>
<td>进程ID</td>
<td>占用CPU百分比</td>
<td>占用内存百分比</td>
<td>虚拟大小</td>
<td>驻留中页的数量</td>
</tr>
<tr>
<td>示例</td>
<td>ubuntu</td>
<td>13716</td>
<td>0.0</td>
<td>0.5</td>
<td>40384</td>
<td>10144</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>列名</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>终端ID</td>
<td>进程状态</td>
<td>开始时间</td>
<td>累计CPU时间</td>
<td></td>
</tr>
<tr>
<td>实例</td>
<td>pts/2</td>
<td>S+</td>
<td>20:33</td>
<td>0:00</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li><p>寻找vi的父进程，直到init进程为止</p>
<p>使用如下命令查看指定进程的父进程的PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.&lt;pid&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<ol>
<li><code>-eo</code>    表示按照指定格式输出，这里指定的格式是pid,ppid,user,command</li>
<li>&lt;pid&gt;     是要查询的pid号</li>
</ol>
</blockquote>
<p>&lt;pid&gt;填写查询进程的pid.</p>
<ul>
<li><p>通过步骤2可知vi的pid为13716，所以查询vi的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w 13716</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171945.jpg" width="600">

<p>由图可知，vi的父进程的pid是7854</p>
</li>
<li><p>查询7854的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.7854</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171948.jpg" width="600">

<p>由图可知，7854的父进程的pid是7745</p>
</li>
<li><p>查询7745的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.7745</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171955.jpg" width="600">

<p>由图可知，7745的父进程的pid是1</p>
</li>
<li><p>查询1的父进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w 1</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171958.jpg" width="600">

</li>
</ul>
<p>综上所述，可以得到如下结果：</p>
<table>
<thead>
<tr>
<th>进程号</th>
<th>父进程号</th>
<th>所属用户</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>13716</td>
<td>7854</td>
<td>ubuntu</td>
<td>vi</td>
</tr>
<tr>
<td>7854</td>
<td>7745</td>
<td>ubuntu</td>
<td>-zsh</td>
</tr>
<tr>
<td>7745</td>
<td>1</td>
<td>ubuntu</td>
<td>tmux</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>root</td>
<td>init</td>
</tr>
</tbody></table>
<ol start="4">
<li>将步骤三得到的进程树和pstree得到的进程树比较</li>
</ol>
<p>通过<code>pstree</code>命令得到如下结果：</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172002.jpg" width="600">

<p>左边的虚线代表init进程，可以看到两种方式得到的进程树是相同的。</p>
<p>两种方式各自的优点如下：</p>
<ul>
<li><code>pstree</code>:<ul>
<li>进程树比较直观，一目了然</li>
<li>能一次显示所有的进程的进程树</li>
</ul>
</li>
<li><code>ps</code>命令查询出的进程树<ul>
<li>能查看每个中间进程的详细信息</li>
<li>ps命令自主性比较好，可以由用户自定义参数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="2-1-实验步骤"><a href="#2-1-实验步骤" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ul>
<li>实验代码如下：</li>
</ul>
<img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1a82h4avqj31370u0436.jpg" width="600">

<ul>
<li><p>编译并运行程序</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172008.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172011.jpg" width="600">
</li>
<li><p>查看vi进程和父进程的状态</p>
<ul>
<li>vi进程</li>
</ul>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172015.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172020.jpg" width="600">

<p>​    可以看到vi进程的进程号为12703,父进程pid为12702，占用CPU和MEM分别为0.5%和0.6%</p>
<ul>
<li><p>vi进程父进程</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172027.jpg" width="600">
</li>
</ul>
</li>
<li><p>对所有进程按照CPU占用率排序</p>
<ul>
<li><p>方法一：使用htop命令，自动按照CPU占用率对进程排序</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172032.jpg" width="600">
</li>
<li><p>方法二：使用top命令按照CPU占用率对进程排序</p>
<p>​        <img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172037.jpg" width="600"></p>
<p>​        </p>
</li>
</ul>
</li>
</ul>
<h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="2-1-实验步骤-1"><a href="#2-1-实验步骤-1" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ol>
<li><p>实验源码</p>
<img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1a83mqnwoj30uk0u0gr4.jpg" width="600">    

<p>对上述源码的分析包含以下几个方面：</p>
<ul>
<li>fork函数的功能和返回值：<ul>
<li>fork的功能是从当前行开始复制父进程，创建一个和父进程一样的子进程</li>
<li>fork的返回值在父进程中大于0，在子进程中等于0，如果创建子进程发生错误返回-1</li>
</ul>
</li>
<li>程序流程如下：</li>
</ul>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172042.jpg" width="600">

<ul>
<li><p>程序解释：</p>
<p>结合上面的程序流程图，可以看到程序执行最初的那个进程就是父进程A，在一开始就通过fork函数创建一个子进程B，并用p1接受fork的返回值，由于p1在进程A和进程B的值不同，所以两个进程接下来执行的代码部分并不相同。进程A执行p1&gt;0的部分代码，并且在p1&gt;0的那部分代码中，进程A再次通过fork创建了一个子进程C。随后进程A和进程C分别打印自己的pid和ppid(父进程id)。在来看进程B，在p1==0的那部分代码中，进程B也是通过fork创建了一个子进程D,并将fork的返回值交给p2，在父进程B中，p2的值大于0，所以父进程B还创建了一个子进程E,而在子进程D中，p2==0，所以不执行p2&gt;0代码块里面的语句，直接打印pid和ppid，之后分别是进程E和B打印pid和ppid。到此满足实验要求的进程树创建完毕。</p>
</li>
</ul>
</li>
<li><p>编译执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task3.c -o task3</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172048.jpg" width="600">
</li>
<li><p>调试分析</p>
<p>由于涉及的进程数比较多，所以通过调试的方式分析比较直观，所以下面利用gdb调试器进行调试。</p>
<p>首先是调试前的准备,在gcc编译的时候加上-g 参数以支持gdb调试:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g task3.c -o task3</span><br></pre></td></tr></table></figure>

<p>通过<code>gdb task3</code>命令进入调试器，首先是配置成多进程调试模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在gdb中按照如下命令设置，可以设置成对进城调试模式</span><br><span class="line">set follow-fork-mode parent</span><br><span class="line">set detach-on-fork off</span><br></pre></td></tr></table></figure>

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172052.jpg" width="600">

<p>设置断点，在含有fork函数的所有地方设置断点</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172056.jpg" width="600">

<p>开始调试，首先通过<code>r</code>命令进入第一个进程开始调试，这里称此进程为A :</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172100.jpg" width="600">

<p>通过调试结果可以看出来进程A的进程号是28608，进程A的父进程pid是28570，并且p1=28613大于0，说明进程A走的是<code>if (p1&gt;0)</code>下面的那个分支。</p>
<p>分析源码可知，进程A在第6行和第7行分别创建了一个子进程，我分别称之为进程B和进程C.</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172113.jpg" width="600">

<p>下面切换到进程B中调试：</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172117.jpg" width="600">

<p>通过输出的调试信息可以看出，此时的p1的值为0，说明进程B执行的是<code>P1==0</code>下面的代码,而<code>P2&gt;0</code>说明此时进程B执行了<code>if (p2&gt;0)</code>后面的fork函数。最后得到进程B的pid为28613，进程B的父进程是进程A，其pid是28608，这与上面的进程A的pid是一直的。</p>
<p>在调试信息中可以看到，当进程B运行到13行和15行的时候分别创建了两个新的子进程，我们称这两个进程为进程D和进程E</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172121.jpg" width="600">

<p>接着对进程C进程分析，进程C是进程A在26行复制得到，并且后面没有创建任何其他的子进程。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172123.jpg" width="600">

</li>
</ol>
<p>​    通过调试信息可以看出，进程C的pid为28615，其父进程pid为28606,父进程为A，这与上面的信息一致。</p>
<p>​    再对进程D进程分析：</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172128.jpg" width="600">

<p>​    通过上面分析可知，p1和p2均为0,所以说明进程D是进程B在13行创建的子进程，进程D的spid为28740，其父进程pid为28613，和前面的信息一致。</p>
<p>​    最后分析进程E：</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172131.jpg" width="600">

<p>​    通过输出的信息可以看到p1=0,p2&gt;0，分析可知进程E是进程B在15行创建的子进程。进程E的pid是28741，其父进程pid是28613,恰好是进程B的pid</p>
<p>​    分析上面可知，在本次调试过程中，得到的进程信息如下所示：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pid</td>
<td align="center">28608</td>
<td align="center">28613</td>
<td align="center">28615</td>
<td align="center">28740</td>
<td align="center">28741</td>
</tr>
<tr>
<td align="center">ppid</td>
<td align="center">28570</td>
<td align="center">28608</td>
<td align="center">28608</td>
<td align="center">28613</td>
<td align="center">28613</td>
</tr>
</tbody></table>
<p>​    于是可以得到这五个进程的进程树如下(与实验要求一致)：</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172138.jpg" width="500">        

<ol start="4">
<li><p>遇到的问题及解决办法</p>
<ul>
<li><p>问题</p>
<p>刚开始的时候由于没有考虑到父进程会在子进程之前结束的问题，导致所有的子进程在getppid()的时候父进程已经结束了，得到的是init进程的pid=1，所以在代码中加入sleep(1)，让父进程等待一秒钟再结束，等待子进程获取了其pid。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172141.jpg" width="600">
</li>
<li><p>解决办法</p>
<p>在代码中中加入sleep(1),再次编译执行即可得到正确结果。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h2><ol>
<li><p>实验源码</p>
<img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1a85bo9v3j316u06y3z9.jpg" width="600">

<p>代码和Task3中的代码基本一致，只是将输出信息编程循环输出，并且没打印一次后sleep一秒钟</p>
</li>
<li><p>打印进程树</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172147.jpg" width="600">

<p>可以看到进程树信息如上图所示</p>
</li>
<li><p>终止进程p2</p>
<ul>
<li><p>采用<code>kill -9</code>的方式终止进程p2</p>
<p>删除之p2的子进程p4和p5挂载init上面。然后进程p1,p2,p3还是原来的进程，进程p2虽然被杀死，但是变成Z+的状态，成为退出状态进程的僵尸进程。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172148.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172155.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172151.jpg" width="600">

<p>查看输出信息，发现进程p2的输出已经没有了</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172158.jpg" width="600">
</li>
<li><p>采用<code>exit()</code>正常退出进程</p>
<ul>
<li><p>实验源码如下：</p>
<img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1a85yjcijj313e0lmdi6.jpg" width="600">
</li>
<li><p>实验步骤</p>
<p>下面是进程p2在exit之前的进程树</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172202.jpg" width="600">

<p>代码中可以看到，进程p2在输出10次之后就会正常退出。下面是进程p2退出之后的进程树。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172205.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172208.jpg" width="600">

<p>再查看进程p2的详细信息，得知进程p2的状态也变成了Z+，成为即将退出的僵尸进程。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172212.jpg" width="600">



</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>采用段错误退出</p>
<ul>
<li><p>实验代码</p>
<img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1a86kbwu9j313g0patbj.jpg" width="600">

<p>实验代码如上，在进程p2的进程段里面定义一个野指针，野指针没有初始化会产生段错误导致进程退出。</p>
</li>
<li><p>实验步骤</p>
<p>下面是进程p2在退出之前的的进程树</p>
</li>
</ul>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172216.jpg" width="600">

<p>​    下面在p2进程退出之后的进程出，进程p2的子进程p4,p5挂载在init上，然后p2进程变成了状态为Z+ 的僵尸进程。</p>
<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172220.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172223.jpg" width="600">

<img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172226.jpg" width="600">

<p>综上所述，三种方式的终止进程都会将进程变成僵尸进程，进程在退出的过程中，系统回收资源，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。这也是为什么进程p2终止之后在进程树中还能看到进程p2的信息等。</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/02/pintos-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/02/pintos-install/" class="post-title-link" itemprop="url">pintos操作系统安装</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-02T00:00:00+08:00">2019-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 15:58:20" itemprop="dateModified" datetime="2019-09-12T15:58:20+08:00">2019-09-12</time>
              </span>
            
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>276</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>1 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="在QEMU虚拟机中安装pintos"><a href="#在QEMU虚拟机中安装pintos" class="headerlink" title="在QEMU虚拟机中安装pintos"></a>在QEMU虚拟机中安装pintos</h1><ol>
<li><p>下载pintos源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http://cs140.stanford.edu/pintos.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/pintos/src/threads</span><br><span class="line">make</span><br><span class="line">../utils/pintos --qemu -- run alarm-multiple</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改utils/pintos 脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my (@cmd) = ('/usr/local/src/qemu/bin/qemu');</span><br></pre></td></tr></table></figure>

<p>将pintos脚本中第622行修改成如上图所示，引号中的内容是qemu可执行程序的绝对路径。</p>
</li>
<li><p>出现下面的截图说明正确安装好了</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174153.jpg" alt></p>
</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/02/qemu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/02/qemu/" class="post-title-link" itemprop="url">qemu虚拟机的安装</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-02T00:00:00+08:00">2019-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 15:56:58" itemprop="dateModified" datetime="2019-09-12T15:56:58+08:00">2019-09-12</time>
              </span>
            
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>578</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>1 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="QEMU虚拟安装"><a href="#QEMU虚拟安装" class="headerlink" title="QEMU虚拟安装"></a>QEMU虚拟安装</h1><ol>
<li><p>下载源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.qemu.org/git/qemu.git</span><br><span class="line">cd qemu</span><br><span class="line">git checkout v2<span class="number">.10</span><span class="number">.0</span> <span class="comment"># 使用2.10.0版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl2-dev libsdl2-gfx-dev libsdl2-image-dev libsdl2-mixer-dev  libsdl2-net-dev libsdl2-ttf-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential flex bison cmake automake libtool gcc-multilib g++-multilib libpixman-dev libfdt-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装i386版本虚拟机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=/usr/local/src/qemu --target-list="i386-softmmu" --enable-debug --python=/usr/bin/python2</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加软连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/qemu/bin/</span><br><span class="line">sudo ln -s qemu-system-i386 qemu</span><br></pre></td></tr></table></figure>


</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/02/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/02/thread/" class="post-title-link" itemprop="url">Pintos实验一全解</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-02T00:00:00+08:00">2019-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 15:55:44" itemprop="dateModified" datetime="2019-09-12T15:55:44+08:00">2019-09-12</time>
              </span>
            
          

          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>19k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>18 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统Pintos-实验一-Thread-全解"><a href="#操作系统Pintos-实验一-Thread-全解" class="headerlink" title="操作系统Pintos 实验一 Thread 全解"></a>操作系统Pintos 实验一 Thread 全解</h1><p>孙汉武    2019.04.02</p>
<hr>
<h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>操作系统课程的必修内容是实现斯坦福大学开发的pintos操作系统。通过对pintos的开发与运行，实现对操作系统各个部分的理解与深入。</p>
<p>本实验一律采用Ubuntu 16.04 Server版作为运行环境。</p>
<p>本教程旨在记录使用pintos实验一的全过程，涉及到安装、调试、开发等等方面，将持续进行更新，希望大家多多支持。</p>
<h3 id="组员"><a href="#组员" class="headerlink" title="组员"></a>组员</h3><ul>
<li>刘    欢    16281044    计科1601</li>
<li>孙汉武    16281047    安全1601</li>
<li>杨涵晨    16281052    计科1601</li>
<li>王晗炜    16281049    计科1601</li>
<li>邢飞龙    16281050    计科1601</li>
<li>谭天云    16281048    计科1601</li>
</ul>
<h3 id="Pintos的安装与简介"><a href="#Pintos的安装与简介" class="headerlink" title="Pintos的安装与简介"></a>Pintos的安装与简介</h3><blockquote>
<p>安装准备：git，bochs，git和bochs的详细安装教程请自行google。</p>
<p><code>sudo apt-get install git</code></p>
<p>提醒bochs使用<code>make</code>命令前，请使用 <code>./configure --enable-gdb-stub --with-nogui</code>命令安装命令行版的bochs工具。</p>
</blockquote>
<p>pintos的源代码下载安装：</p>
<ol>
<li><p>pintos源码下载：<code>git clone http://cs140.stanford.edu/pintos.git</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1o30dzekbj30ov01tmxj.jpg" alt></p>
</li>
<li><p>当前目录将出现<code>pintos</code>文件夹</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1o31g08wej30f6013q33.jpg" alt></p>
</li>
<li><p>源码下载完毕后，目录结构(<code>pintos/src</code>)如下图所示</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1o33qub3ej30cg0avwfd.jpg" alt></p>
</li>
</ol>
<blockquote>
<p>文件夹功能说明：</p>
<ol>
<li>threads:为基核准备的源代码，在实验一中我们会进行修改。</li>
<li>userprog:为装载用户程序的源代码，在实验二我们会进行修改。</li>
<li>vm:基本上空的目录，在实验三我们实现虚拟内存。</li>
<li>filesys:基本文件系统的源代码，从实验二开始使用，实验四开始修改。</li>
<li>devices:键盘、定时器、硬盘等等IO设备的接口源代码，在实验一中我们会修改定时器。其他情况我们不会进行修改。</li>
<li>lib:标准C库的子集实现。这个目录中的代码被编译到内核中，并且从实验二开始，用户程序也会在其下运行。在内核代码和用户程序中，我们可以使用<code>#include&lt;...&gt;</code>的方式引用这个目录中的<code>header</code>文件。我们基本上不用修改本目录中的源代码。</li>
<li>lib/kernal:这个目录中的代码仅被内核使用。还包含在内核代码中可以自由使用的一些数据类型的实现：位图、双向链表和哈希表。在内核代码中，我们可以使用<code>#include&lt;...&gt;</code>的方式引用这个目录中的<code>header</code>文件。</li>
<li>lib/user:这个目录中的代码仅被用户程序使用。在用户程序中，我们可以使用<code>#include&lt;...&gt;</code>的方式引用这个目录中的<code>header</code>文件。</li>
<li>test:每个项目的测试。如果它可以帮助您测试提交用例，可以自行修改。</li>
<li>examples:从实验二开始使用的示例用户程序。</li>
<li>misc &amp; utils:如果尝试在自己的计算机上运行Pintos才会用到这些文件。<strong>请在当前用户目录下的<code>.zshrc</code>或<code>.bashrc</code>文件中添加<code>utils</code>文件夹的环境变量。</strong></li>
</ol>
</blockquote>
<ol start="4">
<li><p>编译Pintos，进入到threads目录，使用<code>make</code>命令</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1o4r82f27j30jr01at95.jpg" alt></p>
<p>此时目录中将会出现一个<code>build</code>文件夹，里面包含了<code>Makefile</code>和一些子目录，随后在其中构建内核。在此我们分析一下<code>build</code>文件夹中的内容。</p>
</li>
</ol>
<blockquote>
<p><code>build</code>文件夹内容分析：</p>
<ol>
<li>Makefile：pintos/src/Makefile.build的复制。它描述了如何构建内核。</li>
<li>kernel.o:整个内核的对象文件。这是将各个单独内核源文件编译目标文件链接到单个目标文件的结果。</li>
<li>kernel.bin:内核的内存映像，即加载到内存中运行Pintos内核的二进制文件。是被剥离调试信息的kernel.o，这节省了大量空间，使得内核不会被内核加载器512KB容量所限制。</li>
<li>loader.bin:内核加载器的内存映像，使用汇编语言编写的小块代码，用于将内核从磁盘读出内存并启动它。它刚好是512字节长度，大小被PC BIOS所固定。</li>
<li>构建的文件夹中同样包含子文件夹，子文件夹中的内容由<code>.o</code>与<code>.d</code>文件组成，分别对应编译器生成的目标文件与依赖项文件。依赖项告诉make在更改其他源文件或头文件时，需要重新编译哪些源文件。</li>
</ol>
</blockquote>
<ol start="5">
<li><p>运行pintos，使用命令<code>pintos -v -- run alarm-multiple</code>测试pintos样例</p>
<blockquote>
<p>参数详解：</p>
<p>​    -v 关闭VGA显示</p>
<p>​    -- 参数引导头</p>
<p>​    run 调用运行命令</p>
<p>​    alarm-multiple 内置测试样例    </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1oh5hjlvyj30ra08pdkj.jpg" alt></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1oh8fev3tj30tc07zgqn.jpg" alt></p>
<p>中途无报错即为安装成功。最后使用<code>Control + c</code>退出程序。</p>
<blockquote>
<p>特别提醒，安装过程中非常容易出现各种各样的库缺失的报错现象，请大家按照报错提示，自行google处理。我遇到的问题是一个叫做<code>warning: can&#39;t find squish-pty, so terminal input will fail</code>的问题。解决方案是在<code>pintos/src/utils</code>目录中执行<code>make</code>命令后，使用<code>sudo ln squish-pty /usr/local/bin/</code>解决。</p>
</blockquote>
<p>在安装成功pintos系统并通过基本的测试用例后，我们可以开始正式的实验了，接下来我将通过分模块的方式，依次记录各个实验的详细的步骤。如果你在安装过程中遇到了问题，并无法通过google解决，欢迎在文章下方留言，我会尽快回复。</p>
</li>
</ol>
<h3 id="Mission-1-ALARM-CLOCK"><a href="#Mission-1-ALARM-CLOCK" class="headerlink" title="Mission 1    ALARM CLOCK"></a>Mission 1    ALARM CLOCK</h3><h4 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h4><p>重新实现<code>timer_sleep()</code>，在<code>devices / timer.c</code>中定义。虽然当前代码提供了一个工作实现，但是它的实现方式我们称为“忙等待”，即它在循环中检查当前时间是否已经过去<code>ticks</code>个时钟，并循环调用<code>thread_yield()</code>直到循环结束。<strong>重新实现它以避免繁忙的等待。</strong></p>
<p>暂停执行调用<code>timer_sleep()</code>的线程，暂停<code>ticks</code>个时钟。除非系统处于空闲状态，线程不需要在<code>ticks</code>个刻度之后唤醒，而将它放在就绪队列中。 <code>timer_sleep()</code>对于实时操作的线程很有用，例如每秒闪烁一次光标。<code>timer_sleep()</code>的参数以<strong>计时器刻度</strong>表示，而不是以毫秒或任何其他单位表示。每秒有<code>TIMER_FREQ</code>计时器刻度，其中<code>TIMER_FREQ</code>是在<code>devices / timer.h</code>中定义的宏。默认值为100，不建议更改此值，因为任何更改都可能导致许多测试失败。</p>
<p>在<code>timer.c</code>中，还存在<code>timer_msleep()</code>、<code>timer_usleep()</code>、<code>timer_nsleep()</code>函数，用于实现睡眠特定的毫秒、微秒和纳秒，但是它们会在必要时候调用<code>timer_sleep()</code>我们无需修改它们。</p>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><p>首先阅读源代码的<code>timer_sleep()</code>函数的实现原理：</p>
<p><img src="https://i.loli.net/2019/05/06/5ccff5e403e02.png" alt></p>
<p>当前执行进程调用<code>timer_sleep(ticks)</code>时，函数通过判断循环条件<strong>当前时间是否已经大于或等于了ticks个计数器刻度</strong>，如果条件不满足，则会调用<code>thread_yield()</code>函数，将当前进程直接加入到<strong>就绪队列</strong>，并调用进程切换的相关函数将CPU让给在就绪队列中的进程(如果就绪队列中有的话)。</p>
<p>可以发现，调用<code>timer_sleep()</code>的进程，在<strong>CPU就绪队列</strong>及<strong>CPU运行队列</strong>间来回切换，即尽管没有到<code>ticks</code>个计数器刻度，但CPU仍会通过激活改进程，以通过循环的方式来判断是否进程还需要再次执行<code>thread_yield()</code>，这个过程中，浪费了进程反复切换之间需要的CPU时间。</p>
<p>深入思考这个问题产生的原因，是尽管进程阻塞要求时间未到，但在该进程<strong>未被重新调度完成前</strong>，操作系统本身不知道到底进程被阻塞了多少计数器刻度。而解决这个问题的合理方式，我们也自然可以想到，在操作系统中描述进程的是<code>struct thread</code>，只要我们在这个<strong>进程PCB中记录了当前阻塞的时间和总共要被阻塞的时间或还要被阻塞多长时间</strong>，我们就可以在不切换进程前确认进程是否应该被加入就绪队列。</p>
<p>修改后的<code>timer_sleep()</code>函数如下：</p>
<p> <img src="https://i.loli.net/2019/05/06/5cd0050ba748e.png" alt></p>
<p>我们在函数中，将要sleep的时间<code>ticks</code>传入到进程PCB中的<code>ticks_blocked</code>用于记录当前PCB指示的进程还需要阻塞多长时间。通过<code>thread_block()</code>函数，设置进程的阻塞状态，并调用进程切换。</p>
<p>既然引入了<code>ticks_block</code>这个变量，我们需要在结构体<code>struct thread</code>中加入对其的声明，并在进程创建函数<code>thread_creade()</code>加入对<code>ticks_block</code>赋初值0的操作。随后我们要做的就是在每个时钟中断时检查，哪些进程使block状态并且休眠时间还有剩余。值得注意的是，这里必须要求<strong>同时满足两个条件</strong>，因为操作系统中存在进程因为等待锁而阻塞的状态，这些进程并非因为主动调用<code>timer_sleep()</code>函数而阻塞。</p>
<p>所以接下来的工作就变成了，在系统时钟中断处理函数中加入进程检查函数，对因为<code>timer_sleep()</code>而阻塞的进程，执行阻塞时间自减或加入CPU就绪队列操作。首先寻找CPU时钟中断处理函数，在<code>timer.c</code>文件中：</p>
<p><img src="https://i.loli.net/2019/05/06/5cd026bf4116d.png" alt></p>
<p>首先，通过<code>pit_configure_channel (0, 2, TIMER_FREQ)</code>函数，向8254定时器设置了每秒执行<code>TIMER_FREQ</code>计时器刻度次的周期定时，使用的通道是<strong>0通道</strong>，计数方式是<strong>mode2</strong>即周期性脉冲。根据硬件编程，实现了计数器0向8259A芯片0号管脚发送中断请求的操作。由于CPU将0-15号中断向量占用，所以通过<code>pic_init()</code>函数，将中断0-15传送到32-47，具体的代码及注释如下。它在Boot引导完毕前执行完毕。</p>
<p><img src="https://i.loli.net/2019/05/06/5cd02e312ffee.png" alt></p>
<p>随后，通过<code>intr_register_ext (0x20, timer_interrupt, &quot;8254 Timer&quot;)</code>函数，我们向32中断向量注册了<code>timer_interrupt()</code>函数，这个函数就是每秒执行<code>TIMER_FREQ</code>次的时钟中断处理函数。即我们需要在这个函数中实现我们之前设计的逻辑。原函数如下图所示：</p>
<p><img src="https://i.loli.net/2019/05/06/5cd0301bba810.png" alt></p>
<p>实现的功能一是CPU时钟计数自加。二是用户进程时间片用完后，当出现外部中断时，中断服务程序处理完毕后，阻塞进程执行(调用<code>thread_yield()</code>函数)。详细代码在<code>interrupt.c</code>的<code>intr_handler()</code>函数中。</p>
<p><img src="https://i.loli.net/2019/05/06/5cd035cd83202.png" alt></p>
<p>我们在时钟中断处理函数中，加入一行即可，实现对每个进程都调用<code>blocked_thread_check</code>函数：</p>
<p><img src="https://i.loli.net/2019/05/06/5cd0360f80917.png" alt></p>
<p>最后再实现<code>blocked_thread_check</code>函数，实现具体对传入进程的上述逻辑功能。</p>
<p><img src="https://i.loli.net/2019/05/06/5cd0370e3ca35.png" alt></p>
<p>当当前待检进程为阻塞状态并且阻塞时间剩余大于0个计时器刻度时执行，剩余刻度自减。若减为0，调用<code>thread_unblock</code>函数将当前进程加入到就绪队列。</p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>我们到<code>/src/thread</code>目录下执行<code>make check</code>，可以进行测试。</p>
<p>至此，MISSION_1    ALARM CLOCK编写完毕，执行测试有如下结果：</p>
<p><img src="https://i.loli.net/2019/05/06/5cd03a9de326b.png" alt></p>
<h3 id="Mission-2-PRIORITY-SCHEDULING"><a href="#Mission-2-PRIORITY-SCHEDULING" class="headerlink" title="Mission 2    PRIORITY SCHEDULING"></a>Mission 2    PRIORITY SCHEDULING</h3><h4 id="实验说明及过程"><a href="#实验说明及过程" class="headerlink" title="实验说明及过程"></a>实验说明及过程</h4><p>本实验主要涉及的是进程的优先级调度问题，这里我们先找到线程结构的定义<code>struct thread</code>:</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508214307.png" alt></p>
<p>我们可以看到这里已经定义了线程优先级的数据成员：<code>priority</code>，这是进行优先级调度的基础，那么我们现在可以思考如何实现这一机制。</p>
<p>pintos中给出的调度函数<code>schedule()</code>中使用了<code>next_thread_to_run()</code>函数获取下一个需要调度执行的进程，当就绪队列中还存在进程则返回队列的首元素，而这个队列是怎么维护的呢？我们通过查找<code>thread.c</code>源程序中的与<code>ready_list</code>相关的函数我们可以发现有以下三个函数来向队列中添加成员：</p>
<ul>
<li><code>init_thread()</code></li>
<li><code>thread_unblock()</code></li>
<li><code>thread_yield()</code></li>
</ul>
<p>它们都调用了函数<code>list_push_back</code>来增加队列中的成员，在<code>list.c</code>中我们可以找到此函数的具体实现：直接在队列的队尾插入。</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508214443.png" alt></p>
<p>如此一番调研之后我们就完全搞清楚了pintos的原始调度机制：<strong>先来先服务</strong>。这与我们所需要的优先级调度还存在较大差别，而在此基础上我们其实不难想出改进的方法：原始的线程结构体中已经给出了整数类型的优先级大小成员，我们只要能够通过比较各个线程的优先级大小维护一个优先级<strong>从大到小的优先级队列</strong>就能完成此种调度。</p>
<p>至此我们又有了两种思路：</p>
<ul>
<li>每次调度之前对就绪队列根据优先级大小进行一次排序</li>
<li>每次插入成员之时按照优先级大小进行插入</li>
</ul>
<p>很容易看出这两种方式都能达到目的，但后一种方式的效率要远远高于第一种方式。因此我们便开始着手实现第二种方式，而当我们继续浏览<code>list.c</code>文件时可以发现其中已经存在<code>list_sort</code>和<code>list_insert_ordered</code>函数，其功能分别为将列表排序和按序插入列表，我们在此自然选择使用其后一个插入函数，根据其传入的参数可知我们只需要重新实现一个比较函数（<code>list_less_func *less</code>）就可调用此函数完成优先级队列的维护。</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508220621.png" alt></p>
<p>下面给出优先级比较函数，根据传入的成员优先级大小返回一个布尔值。</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508220817.png" alt></p>
<p>至此我们初步完成了优先级队列的维护，这也是实现优先级调度的第一步。</p>
<p>继续阅读pintos官方文档种的优先级调度要求，我们可以看见如下一段话：</p>
<blockquote>
<p>Implement priority scheduling in Pintos. When a thread is added to the ready list that has a higher priority than the currently running thread, the current thread should immediately yield the processor to the new thread. Similarly, when threads are waiting for a lock, semaphore, or condition variable, the highest priority waiting thread should be awakened first. A thread may raise or lower its own priority at any time, but lowering its priority such that it no longer has the highest priority must cause it to immediately yield the CPU.</p>
</blockquote>
<p>这段话中提到当就绪队列中存在一个优先级比当前线程优先级更高的线程时，系统要立刻进行调度，先执行优先级较高的线程，当优先级较高的线程存在的时候，优先级较低的线程一定会放弃CPU。</p>
<p>根据此要求结合我们阅读过的<code>thread.c</code>中的源代码，我们可以发现系统当前并不会对优先级大小的变化做到<strong>即时敏感</strong>：当有新的线程创建或者已有的线程优先级发生改变时系统并不会马上进行分析并调度，其中当创建新线程时它只会维护就绪队列，而队列中或当前线程优先级发生变化之时并不会有其它操作随之产生。</p>
<p>针对这一问题我们其实很快就能想出解决的方案：当任何与线程优先级改变相关的操作发生时，进行一个判断分析，若操作之后产生的新优先级高于当前线程的优先级，调用<code>thread_yield</code>函数进行线程调度并维护优先级队列，实现线程的<strong>抢占式调度</strong>。</p>
<p>根据此思路我们从源码中找出与优先级变化相关的函数，经过查找分析我们可以看到只有以下两个函数符合条件：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508214629.png" alt></p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508214916.png" alt></p>
<p>其中<code>init_thread</code>是初始化线程的函数，这属于我们分析的第一种情况：有新的线程产生，此时因为在函数的最后已经有对就绪队列维护的操作，因此我们只需判断其优先级大小是否高于当前线程，若高于则用<code>thread_yield</code>函数使当前线程放弃CPU。(因为函数在初始化时的状态为阻塞，需要在<code>thread_create</code>中调用unblock函数将其置于Ready状态，在这之后我们才能对其进行调度，因此此调度模块补充在<code>thread_create</code>函数中)</p>
<p>而<code>thread_set_priority</code>函数的作用使改变当前线程的优先级，而当优先级发生改变时影响就绪队列的情况十分常见，此时我们只需直接调用<code>thread_yield</code>函数便可完成对就绪队列的维护和线程的优先级调度。</p>
<p>下面给出修改之后这两个函数的代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215018.png" alt></p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215126.png" alt></p>
<p>完成了抢占式调度的涉及，我们接着分析pintos官方文档中的<strong>mission 2</strong>的任务指示，主要在2.2.3节中。</p>
<p>分析之后它主要提出了三个问题，我们先来看看这几个问题</p>
<blockquote>
<p>When threads are waiting for a lock, semaphore, or condition variable, the highest priority waiting thread should be awakened first. A thread may raise or lower its own priority at any time, but lowering its priority such that it no longer has the highest priority must cause it to immediately yield the CPU.</p>
</blockquote>
<p> 总结来说就是，<strong>在有锁或者信号量的时候，我们如何安排进程优先级？</strong></p>
<p>在目前的pintos中 ，锁的申请机制较为简单，只涉及信号量的PV操作并设置锁的拥有线程，这里先给出<code>lock_acquire</code>的源码：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508222049.png" alt></p>
<p>对于其他申请该锁的线程，并未在相关线程中记录，只是在信号量中维持了一个等待队列。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508222906.png" alt></p>
<p>我们可以进一步探究这个队列的维护机制，查找与成员waiters相关的函数，我们可以发现只在信号量的PV操作中会对其进行操作，实现的机制和就绪队列一致：先来先服务。这无疑也不符合优先级调度的要求，我们需要在之后的实验中进行改进。</p>
<p>我们接着阅读官方给出的实验指导书：</p>
<blockquote>
<p>One issue with priority scheduling is “priority inversion”. Consider high, medium, and low priority threads H, M, and L, respectively. If H needs to wait for L (for instance, for a lock held by L), and M is on the ready list, then H will never get the CPU because the low priority thread will not get any CPU time. A partial fix for this problem is for H to “donate” its priority to L while L is holding the lock, then recall the donation once L releases (and thus H acquires) the lock.</p>
</blockquote>
<p>这里涉及到的问题就是线程优先级的捐赠，我们通过以下案例分析对其进行说明：</p>
<ol>
<li>刚开始有一个进程P_low 占用了CPU，并且申请了一个lock锁。这时有一个 P_med 进程进入了就绪队列，优先级比较高的进程, 根据<code>thread_yield ()</code>，P_low会让出cpu给P_med</li>
</ol>
<p><img src="https://jackyanghc-picture.oss-cn-beijing.aliyuncs.com/20190507200607.png" alt></p>
<ol start="2">
<li><p>P_med 占用cpu，P_low放入等待队列ready_list,其还保存着对应的lock占用</p>
<p><img src="https://jackyanghc-picture.oss-cn-beijing.aliyuncs.com/20190507200450.png" alt></p>
</li>
<li><p>此时P_high就绪，根据优先级调度其开始对CPU占用，P_med和P_low按序回到就绪队列中</p>
<p><img src="https://jackyanghc-picture.oss-cn-beijing.aliyuncs.com/20190507201630.png" alt></p>
</li>
</ol>
<ol start="4">
<li>那么，现在就会造成死锁。死锁存在于<code>P_low-&gt;S_1-&gt;P_high</code>之间。</li>
</ol>
<p>至此我们可以得出结论：直接按照优先级调度的方式切换线程可能会造成死锁，结合就绪队列的调度机制会继续导致优先级处于二者之间的所有线程也被锁住。</p>
<p>死锁无疑造成操作系统的崩溃，因此必须给出一个解决的方案来破解。略经思考我们发现最高效的解决方案就是先运行其中一个线程，但这个操作也不能违背线程调度的优先级和锁机制。根据以上要求我们开始引入优先级捐赠机制。</p>
<p><img src="https://jackyanghc-picture.oss-cn-beijing.aliyuncs.com/20190508082122.png" alt></p>
<p>根据实验指导书，优先级捐赠的机制如下：当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。而当被捐赠线程释放该锁之后其优先级需要恢复至原始的优先级。</p>
<p>继续阅读余下的指导书。</p>
<blockquote>
<p>You will need to account for all different situations in which priority donation is required. Be sure to handle multiple donations, in which multiple priorities are donated to a single thread. You must also handle nested donation: if H is waiting on a lock that M holds and M is waiting on a lock that L holds, then both M and L should be boosted to H’s priority.</p>
</blockquote>
<p>这简短的一段话又给我们抛出了两个在优先级捐赠中会出现的问题：</p>
<ul>
<li>如何实现多个线程对单个线程的优先级捐赠</li>
<li>如何实现多个线程之间的递归优先级捐赠</li>
</ul>
<p>第一点的情况较为容易理解，我们在这里使用一个简单的案例介绍递归捐赠：</p>
<p>P_Low正在占用锁Lock1,P_Med正在占用锁Lock2，P_Med正在申请Lock1，此时便会进行优先级的捐赠，P_Low的优先级变为Med，此时P_High开始申请Lock2,P_Med的优先级则会变为High，通过递归捐赠，P_Low的优先级也会变为High。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190509002540.png" alt></p>
<p>以上两点其实并不属于当前调度过程中存在的问题，需要我们在实现优先级捐赠时注意。</p>
<p>经过上面的问题分析，和对应的源代码分析，我们对这个任务余下的待实现需求做一个总结：</p>
<ul>
<li>优先级队列<ul>
<li>维持一个ready_list 优先级排队队列</li>
<li>将condition的waiters队列实现为优先级队列。</li>
<li>将信号量的等待队列实现为优先级队列。</li>
</ul>
</li>
<li>单锁实现<ul>
<li>当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</li>
<li>释放锁的时候若优先级改变则可以发生抢占。</li>
</ul>
</li>
<li>多锁实现<ul>
<li>如果一个线程被多个线程捐赠， 维持当前优先级为捐赠优先级中的最大值（acquire和release之时）</li>
<li>lock 锁被释放的时候， 高进程应该收回优先级捐赠，并且停止unblock状态。</li>
<li>在对一个线程进行优先级设置的时候， 如果这个线程处于被捐赠状态， 则对base_priority进行设置， 然后如果设置的优先级大于当前优先级， 则改变当前优先级， 否则在捐赠状态取消的时候恢复base_priority。</li>
<li>在释放锁对一个锁优先级有改变的时候应考虑其余被捐赠优先级和当前优先级。</li>
</ul>
</li>
<li>捐赠时间<ul>
<li>线程处于ready_list中等待时</li>
<li>线程处于sleep状态，也就是block状态时，也可以改变优先级</li>
</ul>
</li>
</ul>
<p><img src="https://jackyanghc-picture.oss-cn-beijing.aliyuncs.com/20190508083127.png" alt></p>
<p>基于以上需求，我们开始对pintos中的源码进行修改。</p>
<p>在上文的分析中我们就可以得知：若存在优先级的捐赠则必然会存在释放锁后被被捐赠线程的优先级恢复，因此单单在<code>thread</code>结构体中使用一个成员<code>priority</code>是无法完成的，我们需要一个额外的成员来储存线程在被捐赠之前的优先级，也就是<code>base_priority</code>。经过以上的实验我们也可发现原始<code>thread</code>结构体中并未设计与锁相关的成员变量（原l始的锁和信号量队列与优先级无关，和就绪队列一样属于先来先服务，不需要在结构体中添加这些），因此我们还需要在线程的结构体中添加两个成员变量：locks和lock_waiting，分别代表线程已经拥有的锁和正在申请的锁，前者为一个队列，后者只需设置为锁类型（lock）的变量，下面给修改后的<code>thread</code>结构体：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215225.png" alt></p>
<p>既然线程结构体中缺乏与锁相关的成员，自然锁结构体中也缺乏与线程相关的成员，我们找到<code>lock</code>的源码可以发现其中只存在两个成员：<code>holder</code>和<code>semaphore</code>，即拥有者和信号量，这对于实现优先级调度和优先级捐赠来说肯定是不够的，我们需要继续增加两个成员变量：<code>elem</code>和<code>max_priority</code>。这两个成员代表的意义也很好理解：前者是当前线程在信号量队列中位置（在原始的队列中，当前线程一定位于队列的首部），后者则是表示该锁的信号量队列中线程的最高优先级（用于优先级的捐赠），下面也给出修改过后的<code>lock</code>结构体代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215255.png" alt></p>
<p>有了这些修改过后的结构体我们就可以开始实现与锁相关的优先级调度程序。</p>
<p>因为前面涉及到了结构体的修改，那么我们势必要对其初始化函数进行修改，所以我们先对<code>lock_init</code>和<code>init_thread</code>进行修改，完成以上几项的初始化：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508234751.png" alt></p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215344.png" alt></p>
<p>接下来我们不妨分析以下涉及锁的线程调度过程，根据之前阅读的代码，可以用以下流程图来梳理我们需要实现的过程：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt></p>
<p>根据流程图，我们首先着眼于<code>lock_acquire</code>函数，在锁的申请时我们首先考虑的就是锁是否已经被线程占用，若锁未被占用则直接将此线程占用该锁，对信号量进行P操作，而当该锁存在线程占用时，我们就需要将该锁的最大优先级和此线程的优先级进行比较，若此线程的优先级高则要进行优先级的捐赠，随后在被插入信号量的等待队列中。</p>
<p>所以我们这里需要先实现一个优先级捐赠函数<code>thread_donate_priority</code>，它的功能其实只有两个：</p>
<ul>
<li>改变线程当前的优先级</li>
<li>若该线程处于就绪队列中需要对就绪队列重排</li>
</ul>
<p>第一个任务很容易使我们想到之前实现抢占式调度时修改过的<code>thread_set_priority</code>函数，但仔细分析后我们可以发现此函数的逻辑并不适用与此：当前线程的优先级大小不仅和其本身的优先级相关，还与捐赠线程的优先级大小相关，之前修改的函数的本意其实是修改当前运行线程（这就意味着线程的状态一定为RUNNING，因此修改过后我们可以根据调整的优先级大小直接判断其是否调用<code>thread_yield</code>）的<code>base_priority</code>而非<code>priority</code>，且在原来的设置中，并不能指定任意线程进行修改。因此我们需要再次编写一个函数对任意线程的当前优先级进行更新，不过再次之前我们无疑要再次对<code>thread_set_priority</code>函数进行修改，设置<code>base_priority</code>并判断是是否满足重新调度的条件（<strong>没有锁约束或当前优先级发生改变</strong>），下面给出修改后的代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215446.png" alt></p>
<p>之后我们定义一个<code>thread_update_priority</code>函数来更新线程的当前优先级（我们目前只认为线程的当前优先级只会在捐赠优先级的条件下发生改变），此函数的功能也较为简单：将线程的<code>base_priority</code>和其所有锁的最大优先级进行比较，将当前优先级设置为其中的最大值。如此实现的优先级捐赠适用于<strong>多个线程对单个线程的优先级</strong>捐赠，而这里我们唯一的难点就是如何获取其所有锁的最大优先级的最大值，但稍加分析我们也能依照之前的方法简单实现：将locks（线程的锁队列）维护成一个优先级有序队列再取出第一个成员的优先级即可，维护的方法和就绪队列稍有不同，使用了前文提到的<code>list_sort</code>方式（此队列优先级改变的情况较为复杂，用插入的方式容易出现问题），下面一并给出排序函数和优先级更新函数的代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215531.png" alt></p>
<p>拥有锁的线程不一定是当前正在占用CPU的线程，因此我们还需考虑一种情况：此线程正处于优先队列之中，完成了更新之后我们必须重新对就绪队列进行维护。至此我们的捐赠函数的逻辑就完全设计完成 了，下面给出其完整代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215631.png" alt></p>
<p>至此我们退回<code>lock_acquire</code>函数，这里我们还需注意的是优先级的捐赠是一个递归的问题，我们需要将其关联的每一层锁的拥有线程调整为不比此线程低的优先级，这里我们会用一个while结构加以实现。解决了优先级捐赠的问题，我们可以开始进行信号量的P操作，这也不用太多赘述，我们只需再原有基础上将信号量的队列也维护成优先级有序队列，实现方式和就绪队列一致。</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215657.png" alt></p>
<p>获取锁的最后一步就是将此线程变为锁的拥有者，但这一过程也并能沿用当前的方式，因为这会涉及到锁的最大优先级的改变：当一个线程拥有一个锁时，其优先级一定为此锁的最大优先级（包括优先级捐赠的情况）。接着我们还需要把该锁插入至线程的锁队列中，并修改锁的holder成员为当前线程。基于以上逻辑编写了函数<code>thread_hold_the_lock</code>。至此<code>lock_acquire</code>的编写随之完成，以下为两个函数的源码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215742.png" alt></p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215830.png" alt></p>
<p>这里我们完成了获取锁的全部逻辑，接着只要补全释放锁的逻辑即可。相较于<code>lock_acquire</code>，<code>lock_release</code>的逻辑显得更简单一些，这里我们只需做三件事：</p>
<ul>
<li>将对应锁从线程的锁队列中清除（线程脱离锁）</li>
<li>将锁设置为不被任何线程占用（锁脱离线程）</li>
<li>进行信号量的V操作</li>
</ul>
<p>这三步都较为简单，第一步这里编写了一个``thread_remove_lock`函数来实现，主要功能也很容易想到：将该所从其锁队列中移除，更新线程的优先级（若处于被捐赠的状态，还回此锁捐赠的优先级），实现代码如下：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215916.png" alt></p>
<p>第二步就更为简单，只需将lock的holder成员设置为NULL即可。</p>
<p>对于第三步，我们则要对原始的<code>sema_up</code>函数进行修改，其与<code>sema_down</code>函数的唯一不同点在于在对信号量序列中的最高优先级线程进行了unblock操作并改变信号量值之后需要马上使用<code>thread_yield</code>函数来保证抢占式调度。下面给出<code>sema_up</code>和<code>lock_release</code>函数的源代码：</p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508215955.png" alt></p>
<p><img src="https://anjinggufa.oss-cn-beijing.aliyuncs.com/20190508220027.png" alt></p>
<p>以上就完成了mission2的全部代码编写，下面可以开始对其进行测试：</p>
<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><p>我们到<code>/src/thread</code>目录下执行<code>make check</code>，可以进行测试。</p>
<p>至此，MISSION_2    PRIOTITY SCHEDULING编写完毕，执行测试有如下结果：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508235853.png" alt></p>
<h3 id="Mission-3-ADVANCED-SCHEDULER"><a href="#Mission-3-ADVANCED-SCHEDULER" class="headerlink" title="Mission 3    ADVANCED SCHEDULER"></a>Mission 3    ADVANCED SCHEDULER</h3><h4 id="实验说明-1"><a href="#实验说明-1" class="headerlink" title="实验说明"></a>实验说明</h4><p>实现类似于BSD调度程序的多级反馈队列调度程序，以减少在系统上运行作业的平均响应时间。</p>
<p>与优先级调度调度程序一样，高级调度程序同样基于进程的优先级来调度进程。但是高级调度程序<strong>不会</strong>执行优先级捐赠。必须编写必要的代码，以允许在Pintos启动时选择调度算法策略。 默认情况下，优先级调度程序必须处于活动状态，但必须能够使用<code>-mlfqs</code>内核选项选择4.4BSD调度程序。 在<code>main()</code>函数中<code>parse_options()</code>解析选项时，传递此选项会将<code>threads / thread.h</code>中声明的<code>thread_mlfqs</code>设置为<code>true</code>。</p>
<p>启用4.4BSD调度程序后，线程不再直接控制自己的优先级。 应忽略<code>thread_create()</code>的优先级参数，以及对<code>thread_set_priority()</code>的任何调用，并且<code>thread_get_priority()</code>应返回调度程序设置的线程的当前优先级。 高级调度程序不会在以后的任何项目中使用。</p>
<blockquote>
<p><strong>非常重要</strong>：可以在附录B中找到关于BSD调度程序的详细说明，这是我们编程的唯一指导基础。</p>
</blockquote>
<h4 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a>实验指导</h4><p>通用调度程序的目标是平衡线程的不同调度需求。 执行<strong>大量I / O的线程</strong>需要快速响应时间以保持输入和输出设备忙，但需要很少的CPU时间。 另一方面，<strong>绑定计算的线程</strong>需要花费大量CPU时间来完成其工作，但不需要快速响应时间。 <strong>其他线程</strong>介于两者之间，I / O周期被计算周期打断，因此需求随时间变化。 精心设计的调度程序通常可以同时满足具有所有这些要求的线程。</p>
<p>对于项目1，必须实现附录B中描述的调度程序。 调度程序类似于[McKusick]中描述的调度程序，它是多级反馈队列调度程序的一个示例。 这种类型的调度程序维护几个可立即运行的线程队列，其中每个队列包含具有不同优先级的线程。 在任何给定时间，调度程序从最高优先级的非空队列中选择一个线程。 如果最高优先级队列包含多个线程，则它们以“循环”顺序运行。 </p>
<p>调度程序的多个方面需要在一定数量的计时器滴答之后更新数据。 在每种情况下，这些更新应该在任何普通内核线程有机会运行之前发生，这样内核线程就不可能看到新增的<code>timer_ticks()</code>值而是旧的调度程序数据值。 4.4BSD调度程序<strong>不包括优先捐赠</strong>。</p>
<h5 id="Niceness"><a href="#Niceness" class="headerlink" title="Niceness"></a>Niceness</h5><p>线程优先级由调度程序使用下面给出的公式动态确定。 但是，每个线程还有一个整数<code>nice</code>值，用于确定线程对其他线程的“好”程度。<code>nice</code>值为0不会影响线程优先级。 <code>nice</code>值从1至20，会降低线程的优先级，并导致它放弃一些原本会收到的CPU时间。 另一种情况，<code>nice</code>值从-20到-1，往往会从其他线程中抢占CPU时间。 </p>
<p>初始线程<code>nice</code>值为0。 其他线程初始值从其父线程继承<code>nice</code>值。 必须实现下面描述的功能，供测试程序使用。 在<code>threads / thread.c</code>中为它们提供了框架定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前进程的nice值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_get_nice</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前进程的nice值为new_nice，并重新计算进程的优先级，若正在运行的进程不再是最高优先级，则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_set_nice</span> <span class="params">(<span class="keyword">int</span> new_nice)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="计算-Priority"><a href="#计算-Priority" class="headerlink" title="计算 Priority"></a>计算 Priority</h5><p>我们的调度程序有64个优先级，因此有64个就绪队列，编号为0（PRI_MIN）到63（PRI_MAX）。 较低的数字对应较低的优先级。因此优先级0是最低优先级，优先级63是最高优先级。 线程优先级最初在线程初始化时计算。 对于每个线程，<strong>每四个时钟周期也会重新计算一次</strong>。 在任何一种情况下，都由公式确定<br>$$<br>priority=PRI_MAX-(recent_cpu/4)-(nice*2)<br>$$<br><code>recent_cpu</code>是线程最近使用的CPU时间的估计值（见下文），而且公式中的<code>nice</code>值为当前进程的<code>nice</code>值。 结果应向下舍入到最接近的整数（截断）。 <code>recent_cpu</code>和<code>nice</code>的系数<code>1/4</code>和<code>2</code>，分别被发现在实践中很好地工作但缺乏更深的含义。 计算得到的优先级始终为位于PRI_MIN到PRI_MAX的有效范围内。 </p>
<p>此公式为线程重新计算优先级提供了依据。 这是防止饥饿的关键：最近没有收到任何CPU时间的线程的<code>recent_cpu</code>值为0，除非有一个很高的<code>nice</code>值，否则它会很快就会收到CPU运行时间。</p>
<h5 id="计算-recent-cpu"><a href="#计算-recent-cpu" class="headerlink" title="计算 recent_cpu"></a>计算 recent_cpu</h5><p>我们希望<code>recent_cpu</code>可以表征每个进程“最近”收到多少CPU运行时间。此外，作为一种改进，最新收到的CPU时间应该比其之前的CPU时间权重更大。 一种方法是使用n个元素的数组来跟踪在最后n秒的每一个中接收的CPU时间。 然而，这种方法每线程需要<code>O(n)</code>空间，并且每次计算新加权平均值需要<code>O(n)</code>时间。</p>
<p>相反，我们使用指数加权移动平均线，它采用这种一般形式：<br>$$<br>x(0)=f(0),\x(t)=ax(t-1)+(1-a)f(t),\a=k/(k+1)<br>$$<br>其中<code>x(t)</code>是整数时间t≥0的移动平均值，<code>f(t)</code>是被平均的函数，k &gt; 0控制衰减速率。我们可以通过以下几个步骤迭代公式：<br>$$<br>x(1)=f(1),\x(2)=af(1)+f(2),\.\.\.\x(5)=a^4f(1)+a^3f(2)+a^2f(3)+af(2)+f(5)<br>$$<br><code>f(t)</code>的值在时间 t 的权重为1，在时间 t + 1 的权重为 a，在时间 t + 2 的权重为 2，等等。我们还可以将<code>x(t)</code>与 k 相关联：<code>f(t)</code>在时间 t + k 具有大约 1 / e 的权重，在时间 t + 2k 具有大约1 / e<sup>2</sup> 等等。从相反方向，<code>f(t)</code>在时间 t + log<sub>a</sub> w 衰减到 <code>f(t)*w</code>。</p>
<p>在创建的第一个线程中，<code>recent_cpu</code>的初始值为0，或者在其他新线程中为其父进程值。 每次发生定时器中断时，除非空闲线程正在运行，否则<code>recent_cpu</code>仅对正在运行的线程递增1。 此外，每秒一次，使用以下公式为每个线程（无论是运行，准备还是阻塞）重新计算<code>recent_cpu</code>的值：<br>$$<br>recent_cpu=(2<em>load_avg)/(2</em>load_avg+1)<em>recent_cpu+nice，<br>$$<br>其中<code>load avg</code>是准备运行的线程数的移动平均值（见下文）。 如果<code>load avg</code>为 1 ，表示单个线程正在竞争CPU，那么<code>recent_cpu</code>的当前值在log<sub>2 / 3</sub> 0.1 ≈ 6秒内衰减到原值的 0.1。 如果<code>load_avg</code>为2，则衰减到原值的 0.1需要 log<sub>3 / 4</sub> 0.1 ≈ 8秒。 结果是<code>recent_cpu</code>估计了线程“最近”收到的CPU时间量，*</em>衰减率与竞争CPU的线程数成反比**。</p>
<p>某些测试所做的假设要求在系统计数器每达到一秒完全重新计算<code>recent_cpu</code>，即条件<code>timer_ticks () % TIMER_FREQ == 0</code>成立。</p>
<p>对于具有负<code>nice</code>值的线程，<code>recent_cpu</code>的值可能为负。 不要将负的<code>recent_cpu</code>设置为0。</p>
<p>需要考虑此公式中的计算顺序。先计算<code>recent_cpu</code>的系数，然后再做乘法，否则可能会产生溢出。</p>
<p>必须实现在<code>threads/thread.c</code>中的<code>thread_get_recent_cpu()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前线程recent_cpu值的100倍，四舍五入到最接近的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_get_recent_cpu</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="计算-load-avg"><a href="#计算-load-avg" class="headerlink" title="计算 load_avg"></a>计算 load_avg</h5><p>最后，<code>load_avg</code>（通常称为系统负载平均值）估计在过去一分钟内，在准备队列中的平均线程数。 像<code>recent_cpu</code>一样，它也是指数加权移动平均。 与<code>priority</code>和<code>recent_cpu</code>不同，<code>load_avg</code>是系统范围的，而不是特定于线程的。 在系统启动时，它被初始化为0。此后每秒一次，根据以下公式更新：<br>$$<br>load_avg=(59/60)<em>load_avg+(1/60)</em>ready_threads，<br>$$<br><code>ready_thread</code>是在更新时运行或准s备运行的线程数（不包括空闲线程）。</p>
<p>有些测试假设当计时器达到1秒倍数时，即当<code>timer_ticks()%TIMER_FREQ == 0</code>时，必须要重新更新<code>load_avg</code>，而不是在其它时间。必须实现位于<code>threads/thread.c</code>中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前系统 load_avg 的100倍，四舍五入到最接近的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_get_load_avg</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以下公式总结了实现高级调度程序所需的计算。 它们不是调度程序要求的完整描述。 </p>
<p>每个线程在-20和20之间具有<code>nice</code>值。 每个线程也有一个优先级，介于0(<code>PRI_MIN</code>)到63(<code>PRI_MAX</code>)之间，每四个滴答使用以下公式重新计算：<br>$$<br>priority=PRI_MAX-(recent_cpu/4)-(nice<em>2).<br>$$<br><code>recent_cpu</code>测量一个线程“最近”收到的CPU时间量。在每个CPU时钟中，正在运行的线程的<code>recent_cpu</code>增加1。每秒一次，每个线程的<code>rencent_cpu</code>以这种方式更新：<br>$$<br>recent_cpu=(2</em>load_avg)/(2<em>load_avg+1)</em>recent_cpu+nice.<br>$$<br><code>load_avg</code>估计在过去一分钟内准备运行的平均线程数。 它在启动时初始化为0，并按每秒重新计算一次，如下所示：<br>$$<br>load_avg=(59/60)<em>load_avg+(1/60)</em>ready_threads.<br>$$<br><code>ready_threads</code>是在更新时运行或准备运行的线程数（不包括空闲线程）。</p>
<h4 id="定点小数及其计算"><a href="#定点小数及其计算" class="headerlink" title="定点小数及其计算"></a>定点小数及其计算</h4><p>在上面的公式中，<code>priority</code>、<code>nice</code>和<code>ready_thread</code>是整数，但是<code>recent_cpu</code>和<code>load_avg</code>是实数。 但是，Pintos不支持内核中的浮点运算，因为它会使内核变得复杂和变慢。 出于同样的原因，真正的内核通常具有相同的限制。 这意味着必须使用整数模拟实数的计算。 本节介绍基础知识。</p>
<p>其基本思想是将整数的最右边的几位视为表示分数。例如，我们可以将带符号的32位整数的最低14位指定为小数位，这样整数x代表实数 x/2<sup>14</sup> 。这个叫做 17.14 定点数，最大能够表示 (2<sup>31</sup>-1)/2<sup>14</sup> ，近似 131071.999 。</p>
<p>假设我们使用 p.q 的定点数格式，并且设 f=2<sup>q</sup> 。根据上面的定义，我们可以通过乘以 f 将整数或实数转换为 p.q 格式。例如，基于17.14 格式的定点数转换 59/60 ，(59/60)2<sup>14</sup> = 16110。将定点数转换为整数则除以 f 。</p>
<blockquote>
<p>C中的“/”运算符向零舍入，也就是说，它将正数向下舍入，向负数向上舍入。要舍入到最近，将 f / 2 先与正数相加再除，或者先在负数中减去 f / 2 再除。</p>
</blockquote>
<p>下表总结了如何在C中实现定点算术运算。在表中，x和y是定点数，n是整数，定点数是带符号的p.q格式，其中p + q = 31，和f是1 &lt;&lt; q：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508203900.png" alt></p>
<h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><p>根据实验说明，我们可以知道<code>bool</code>变量<code>thread_mlfqs</code>指示是否启用高级调度程序，并且高级调度程序不应包含优先级捐赠的内容，所以，在Mission_2中实现的优先级捐赠代码，需要使用<code>if</code>判断以保证在使用高级调度程序时，不启用优先级捐赠。随后，我们可以根据实验指导中的详细说明一步步完成本次实验。</p>
<p>首先，根据上述给定点数的计算方法，编写定点数的计算方法，实现 16.15 格式定点数计算方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic definitions of fixed point. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">fixed_t</span>;</span><br><span class="line"><span class="comment">/* 16 LSB used for fractional part. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_SHIFT_AMOUNT 16</span></span><br><span class="line"><span class="comment">/* Convert a value to fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_CONST(A) ((fixed_t)(A &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Add two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ADD(A,B) (A + B)</span></span><br><span class="line"><span class="comment">/* Add a fixed-point value A and an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ADD_MIX(A,B) (A + (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Substract two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_SUB(A,B) (A - B)</span></span><br><span class="line"><span class="comment">/* Substract an int value B from a fixed-point value A */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_SUB_MIX(A,B) (A - (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Multiply a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_MULT_MIX(A,B) (A * B)</span></span><br><span class="line"><span class="comment">/* Divide a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_DIV_MIX(A,B) (A / B)</span></span><br><span class="line"><span class="comment">/* Multiply two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_MULT(A,B) ((fixed_t)(((int64_t) A) * B &gt;&gt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Divide two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_DIV(A,B) ((fixed_t)((((int64_t) A) &lt;&lt; FP_SHIFT_AMOUNT) / B))</span></span><br><span class="line"><span class="comment">/* Get integer part of a fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_INT_PART(A) (A &gt;&gt; FP_SHIFT_AMOUNT)</span></span><br><span class="line"><span class="comment">/* Get rounded integer of a fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ROUND(A) (A &gt;= 0 ? ((A + (1 <span class="meta-string">&lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT) \</span></span></span><br><span class="line">        : ((A - (<span class="number">1</span> &lt;&lt; (FP_SHIFT_AMOUNT - <span class="number">1</span>))) &gt;&gt; FP_SHIFT_AMOUNT))</span><br></pre></td></tr></table></figure>

<p>由于本实验涉及到的公式均与时钟中断有关，所以，我们将上述的公式迭代计算的相关代码，写入我们在Mission_1中详细介绍过的<code>timer_interrupt()</code>时钟中断处理函数中。其原函数为：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508205418.png" alt></p>
<p>之前已经接介绍过，本实验在<code>thread_mlfqs</code>变量为<code>true</code>的情况下进行。所以，我们需要通过<code>if</code>对此条件进行判断，以免影响其他实验的正常运行。</p>
<p>包括，每个时钟中断都更新的<code>recent_cpu</code>、每一秒更新的<code>load_avg</code>、每四个时钟更新一次的<code>priority</code>，如下图所示。接下来，我们分别介绍这些函数。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508205709.png" alt></p>
<p>首先是<code>thread_mlfqs_increase_recent_cpu_by_one(void)</code>，若当前进程不是空闲进程则当前进程加1，注意<strong>定点数加法</strong>。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508210037.png" alt></p>
<p>接下来是<code>thread_mlfqs_update_load_avg_and_recent_cpu(void)</code>函数，首先根据就绪队列的大小计算<code>load_avg</code>的值，随后根据<code>load_avg</code>的值，更新所有进程的<code>recent_cpu</code>值及<code>priority</code>值。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508210351.png" alt></p>
<p>最后，通过<code>thread_mlfqs_update_priority (struct thread *t)</code>函数，更新当前进程的<code>priority</code>值，注意，一定要保证每个线程的<strong>优先级介于0(<code>PRI_MIN</code>)到63(<code>PRI_MAX</code>)之间</strong>。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508210806.png" alt></p>
<p>最后到了收尾工作，我们要在<code>struct thread</code>结构体中加入<code>nice</code>和<code>recent_cpu</code>这两个变量，其完整的定义如下：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508211421.png" alt></p>
<p>并在<code>init_thread()</code>线程初始化时，将<code>nice</code>与<code>recent_cpu</code>置零。注意<code>recent_cpu</code>是<strong>定点数0</strong>。我们需要在<code>thread.c</code>中定义全局变量<code>load_avg</code>，注意是<strong>定点数类型</strong>。在<code>thread_start()</code>函数中初始化为0。</p>
<p>根据上述指导内容，在<code>thread.c</code>中将需要我们实现的函数全部写入。</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508212239.png" alt></p>
<h4 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h4><p>我们到<code>/src/thread</code>目录下执行<code>make check</code>，可以进行测试。</p>
<p>至此，MISSION_3    ADVANCED SCHEDULER编写完毕，执行测试有如下结果：</p>
<p><img src="https://emrick.oss-cn-beijing.aliyuncs.com/img/20190508213515.png" alt></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>撰写本文的目的在于记录小组pintos实验一过程，</p>
<p><a href="https://courses.cs.vt.edu/cs4284/spring2013/pintos/doc/pintos.pdf" target="_blank" rel="noopener">斯坦福官方实验指导书</a>，</p>
<p><a href="https://www.cnblogs.com/laiy/p/pintos_project1_thread.html" target="_blank" rel="noopener">Pintos-斯坦福大学操作系统Project详解</a></p>
<p>在此特别感谢以上作者。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sun</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code!</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    
    <span title="Symbols count total">113k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    
    <span title="Reading time total">1:43</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  

  

</body>
</html>
