<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Talk is cheap, show me the code!">
<meta property="og:type" content="website">
<meta property="og:title" content="SunPages">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="SunPages">
<meta property="og:description" content="Talk is cheap, show me the code!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SunPages">
<meta name="twitter:description" content="Talk is cheap, show me the code!">
  <link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>SunPages</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SunPages</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-about"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-categories"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/21/lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/21/lab3/" class="post-title-link" itemprop="url">进程实验二</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-03-21 20:10:33" itemprop="dateCreated datePublished" datetime="2019-03-21T20:10:33+08:00">2019-03-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-12 17:34:23" itemprop="dateModified" datetime="2019-09-12T17:34:23+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统实验/" itemprop="url" rel="index"><span itemprop="name">操作系统实验</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>41k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>37 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验三-实验报告"><a href="#实验三-实验报告" class="headerlink" title="实验三 实验报告"></a><center>实验三 实验报告</center></h1><blockquote>
<center>孙汉武    安全1601    16281047</center>

</blockquote>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab3" target="_blank" rel="noopener">实验源代码链接</a></p>
<h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><h3 id="1-1-实验要求"><a href="#1-1-实验要求" class="headerlink" title="1.1 实验要求"></a>1.1 实验要求</h3><p>$\qquad$通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。</p>
<h3 id="1-2-实验过程"><a href="#1-2-实验过程" class="headerlink" title="1.2 实验过程"></a>1.2 实验过程</h3><ol>
<li><p>实验源码</p>
<p><code>Task1.c</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sem_t</span> *P1_signal,*P2_signal,*P3_signal;</span><br><span class="line">	<span class="comment">//主函数中的进程是P1</span></span><br><span class="line">	<span class="keyword">pid_t</span> p2,p3,p4; </span><br><span class="line">	P1_signal=sem_open(<span class="string">"P1_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	P2_signal=sem_open(<span class="string">"P2_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	P3_signal=sem_open(<span class="string">"P3_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	p2=fork();<span class="comment">//创建进程P2</span></span><br><span class="line">	<span class="keyword">if</span>(p2&lt;<span class="number">0</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"创建进程p2出错！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p2==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(P1_signal);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I am the process P2!\n"</span>);</span><br><span class="line">		sem_post(P1_signal);</span><br><span class="line">		sem_post(P2_signal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p2&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p3=fork();</span><br><span class="line">		<span class="keyword">if</span>(p3&lt;<span class="number">0</span>)	</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"创建进程p出错！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p3==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sem_wait(P1_signal);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am the process P3!\n"</span>);</span><br><span class="line">			sem_post(P1_signal);</span><br><span class="line">			sem_post(P3_signal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p3&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am the process P1!\n"</span>);</span><br><span class="line">			sem_post(P1_signal);</span><br><span class="line">			p4=fork();</span><br><span class="line">			<span class="keyword">if</span>(p4&lt;<span class="number">0</span>)	</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"创建进程p4出错！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p4==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sem_wait(P2_signal);</span><br><span class="line">				sem_wait(P3_signal);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"I am the process P4!\n"</span>);</span><br><span class="line">				sem_post(P2_signal);</span><br><span class="line">				sem_post(P3_signal);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sem_close(P1_signal);</span><br><span class="line">	sem_close(P3_signal);</span><br><span class="line">	sem_close(P2_signal);</span><br><span class="line">	sem_unlink(<span class="string">"P1_signal"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"P2_signal"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"P3_signal"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原理解释</p>
<ul>
<li><p>前趋图</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172743.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<pre><code> 前驱关系：`P1--&gt;P2`、`P1--&gt;P3`、`P2--&gt;P4`、`P3--&gt;P4`
</code></pre><ul>
<li><p>前驱关系实现</p>
<p>题目要求产生的四个进程必须是P1最先执行，P2、P3在P1执行完后互斥执行，P4最后执行。于是根据要求有了上面的前驱关系和前驱图。但是如何实现这种进程间的前驱关系呢？比较自然的想到了是用信号量机制。如上面的代码所示，定义了三个信号量，P1_signal、P2_signal和P3_signal，其初值均为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1_signal=sem_open(<span class="string">"P1_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">   P2_signal=sem_open(<span class="string">"P2_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">   P3_signal=sem_open(<span class="string">"P3_signal"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code> P1进程执行完打印任务之后对P1_signal信号量进行V操作，产生一个资源让等待P1_signal的进程P2和P3其中之一可以执行。由于P2和P3都是等待P1_signal信号量，但是P1进程只产生一个单位的信号，所以P2和P3的执行是互斥的，这样就满足了题目要求。最后在P2和P3执行完打印任务后对信号量P2_signal和P3_signal进行V操作从各产生一个单位的信号量，而进程P4会等待P2_signal和P3_signal，所以知道当P2和P3进程都完成才能进行P4进程。通过控制这三个信号量，这四个进程之间的前驱关系就满足了题目要求。

 ![](http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173752.jpg)
</code></pre><ul>
<li><p>进程产生实现</p>
<p>根据题目要求，通过fork的方式产生四个进程。fork函数会从当前位置复制进程，并且在父进程中返回的pid为复制进程的真实pid，在子进程中返回的pid为0。了解这些知识之后可以得到如下的流程图：</p>
<p>下面的流程图仅表示进程间的关系，前驱关系的实现请看上一小节.</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173757.jpg" alt></p>
</li>
<li><p>进程树</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173803.jpg" alt></p>
</li>
</ul>
<ol>
<li><p>编译源码</p>
<p>通过下面的命令编译源码，得到可执行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g task1.c -o task1 -lpthrea</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1-3-实验结果"><a href="#1-3-实验结果" class="headerlink" title="1.3 实验结果"></a>1.3 实验结果</h3><p>$\qquad$通过上面的实验已经得到满足实验要求的可执行程序task1,下面给出运行结果，经过多次测试，四个进程在屏幕上打印的顺序只有两种结果，分别如下：</p>
<ol>
<li><p>顺序1：<code>P1--&gt;P2--&gt;P3--&gt;P4</code></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173808.jpg" alt></p>
</li>
<li><p>顺序2：<code>P1--&gt;P3--P2--&gt;P4</code></p>
</li>
</ol>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173812.jpg" alt></p>
<h3 id="1-4-现象解释"><a href="#1-4-现象解释" class="headerlink" title="1.4 现象解释"></a>1.4 现象解释</h3><p>$\qquad$测试的实验结果中出现两种执行顺序，通过1.2 节中的分析不难解释这种现象，由于P1是P2和P3的前驱，所以P1一定会在P2和P3之前执行，但是P2和P3是互斥关系，这两个进程谁先获得P1产生的信号量谁就先执行另一个进程等待。最后等P2和P3都执行完了再执行P4，所以会出现上面的两种执行顺序。</p>
<h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="2-1-实验要求"><a href="#2-1-实验要求" class="headerlink" title="2.1 实验要求"></a>2.1 实验要求</h3><p>$\qquad$火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。</p>
<h3 id="2-2-实验过程"><a href="#2-2-实验过程" class="headerlink" title="2.2 实验过程"></a>2.2 实验过程</h3><h4 id="2-2-1未添加同步机制"><a href="#2-2-1未添加同步机制" class="headerlink" title="2.2.1未添加同步机制"></a>2.2.1未添加同步机制</h4><ol>
<li><p>实验源码</p>
<p><code>task2_1.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ticketCount=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">SaleThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"卖%d张票,剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		<span class="comment">//放弃CPU，强制切换到另外一个进程</span></span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp<span class="number">-1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RefundThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"退%d张票，剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp+<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请正确输入参数！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="comment">/* printf("%s %s",argv[1],argv[2]); */</span></span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,SaleThread,argv[<span class="number">1</span>]);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,RefundThread,argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最终票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>在main函数中创建两个线程，分别是模拟售票的线程<code>SaleThread</code>和模拟退票的线程<code>RefundThread</code>，两个进程并发执行，不添加任何的同步机制。</li>
<li>模拟票数的变量ticketCount是全局变量</li>
<li>程序运行需要输入两个参数，第一个是售票数量，第二个数退票数量</li>
</ul>
</li>
<li><p>程序运行结果</p>
<p>编译上述程序，得到可执行程序<code>task2_1</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g  task2_1.c -o task2_1 -lpthread</span><br></pre></td></tr></table></figure>
<p>多次测试运行，运行结果可以分为两种类型，一种是售票数量比退票数量多，另一种是售票数量比退票数量少。两种情况的结果分别如下：</p>
<ul>
<li><p>售票数量比退票数量多：</p>
<p>初始票数：1000      售票：100     退票：40</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173819.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>售票数量比退票数量少：</p>
<p>初始票数：1000    售票：50    退票：80</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173823.jpg" alt></p>
</li>
</ul>
<ol>
<li><p>实验现象归纳</p>
<p>通过一系列的测试，归纳出的实现现象如下：</p>
<ul>
<li>当售票数量大于退票数量的时候，最终票数等于总票数减去售票数</li>
<li>当售票数量小于退票数量的时候，最终票数等于总票数加上退票数</li>
</ul>
</li>
</ol>
<h4 id="2-2-2-添加同步机制"><a href="#2-2-2-添加同步机制" class="headerlink" title="2.2.2 添加同步机制"></a>2.2.2 添加同步机制</h4><ol>
<li><p>实验源码</p>
<p><code>task2_2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> ticketCount=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">sem_t</span> *flag=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">SaleThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"卖%d张票,剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		sem_wait(flag);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		<span class="comment">//放弃CPU，强制切换到另外一个进程</span></span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp<span class="number">-1</span>;</span><br><span class="line">		ticketCount-=<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">		sem_post(flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RefundThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num,temp;</span><br><span class="line">	num=atoi(arg);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">10</span> ==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"退%d张票，剩余%d张票\n"</span>,i,ticketCount);</span><br><span class="line">		sem_wait(flag);</span><br><span class="line">		temp=ticketCount;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		temp=temp+<span class="number">1</span>;</span><br><span class="line">		ticketCount+=<span class="number">1</span>;</span><br><span class="line">		pthread_yield();</span><br><span class="line">		ticketCount=temp;</span><br><span class="line">		sem_post(flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请正确输入参数！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flag=sem_open(<span class="string">"flag"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s %s"</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,SaleThread,argv[<span class="number">1</span>]);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,RefundThread,argv[<span class="number">2</span>]);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最终票数为：%d\n"</span>,ticketCount);</span><br><span class="line">	sem_close(flag);</span><br><span class="line">	sem_unlink(<span class="string">"flag"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li><p>task2_2.c在task2_1.c的基础上增加了同步机制，其他部分完全一致，通过信号量flag的控制，让售票线程和退票线程一次只能执行一个，在一个没有执行完成之前另一个不能进入执行，这样就保证了售票操作和退票操作的原子性，避免了脏数据的读取。</p>
</li>
<li><p>flag初始值为设置为1，表示每次只允许一个线程操作ticketCount这个数据</p>
</li>
<li><p>售票线程和退票线程在进入操作之前都要sem_wait(flag)，等待信号量，在完成操作之后要sem_post(flag)，下图是售票线程中增加了信号量的操作：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173828.jpg" alt></p>
</li>
</ul>
</li>
<li><p>程序运行结果</p>
<p>编译上述程序，得到可执行程序task2_2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task2_2.c -o task2_2 -lpthread</span><br></pre></td></tr></table></figure>
<p>多次测试运行，测试主要分为两种类型，一种是售票数量比退票数量多，另一种是售票数量比退票数量少。两种情况的结果分别如下：</p>
<ul>
<li><p>售票数量比退票数量多：</p>
<p>初始票数：1000      售票：100     退票：40</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173833.jpg" alt></p>
</li>
<li><p>退票数量比售票数量多：</p>
<p>初始票数：1000    售票：50    退票：80</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173838.jpg" alt></p>
</li>
</ul>
</li>
<li><p>实验现象归纳</p>
<ul>
<li><p>在第一个测试样例中，初始票数为1000，售票100并且退票40，最终总票数为940，结果正确；</p>
</li>
<li><p>在第二个测试样例中，初始票数为1000，售票50并且退票80，最终总票数为1030，结果正确。</p>
</li>
</ul>
<ul>
<li><p>通过上面的测试结果可以看出，不论是售票数量比退票数量多还是少，都不会发生类似前面2.2.1的问题，最终的票数是期待得到的结果。</p>
</li>
<li><p>上面的实验证实了增加了同步机制之后的多线程并发程序有效的解决了脏数据的读取问题</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p> 通过2.2节的对比实验可以看出，在执行多进程并发程序的时候，由于多进程的切换可能发生在某个进程的中间，会导致在一个进程处理的数据未写入ticketCount之前另外一个进程读取该数据，这样就导致了脏数据的读取，导致最终结果的不正确。</p>
<p>在2.2节的后半部分通过怎加同步机制，保证售票进程和退票进程的的原子性，就是指在某个进程操作的时候，在它完成操作之前另外一个进程无法操作共享变量ticketCount,这样就避免了脏数据的发生，得到了预期的正确结果。</p>
<h3 id="2-4-现象解释"><a href="#2-4-现象解释" class="headerlink" title="2.4 现象解释"></a>2.4 现象解释</h3><h4 id="2-4-1-现象解释1"><a href="#2-4-1-现象解释1" class="headerlink" title="2.4.1 现象解释1"></a>2.4.1 现象解释1</h4><p>在2.2.1节的实验中，以售票线程为例（代码如下图所示），没有添加同步机制，并且在进行<code>temp=temp-1</code>和<code>temp=ticketCount</code>的后面均加上了pthread_yield，这个函数的作用是放弃对CPU的使用权，切换到其他进程中，本实验中就是切换到退票进程中。</p>
<p>这样就能解释为什么2.2.1节中的实验现象，在2.2.1节中，不论售票数多还是退票数多，最终结果都是总票数加上或减去值比较大的那个数。通过分析可以得出解释，售票进程和退票进程同时进行，初始票数均为1000，售票进程完成一次是票数为999，售票进程开始下一次售票，但是在运行<code>temp=ticketCount</code>之前，退票进程处理的数据还没有写入到内存中，导致售票进程读取的还是自己之前计算的ticketCount值，而不是全局的值。退票进程也是同理。</p>
<p>但是为什么刚好就是总票数加上或减去值比较大的那个呢？按照道理来说因该售票进程执行temp=ticketCount在退票进程写入ticketCount值之前发生是存在一定概率的，但是在目前为止的所有测试结果全部都是在写入之前读取ticketCount值，对此的解释是由于ticketCount=temp和temp=ticketCount之间没有加pthread_yield操作，而现代的处理器运算速度足够快，在退票进程放弃CPU控制权的那个时间片已经完成了这两步操作，所以相当于售票进程读取的ticketCount一直是自己本身的值，退票进程处理的数据对售票进程并没有影响。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173844.jpg" alt></p>
<p>为了验证上面的猜想，在=如下图所示代码，在ticketCount之后增加一行代码，pthread_yield，放弃当前进程对CPU的控制权，即售票进程放弃对CPU的控制权转而交给退票进程，这个时候退票进程处理的数据就能写入到内存中，而当售票进程再次处理temp=ticketCount的时候，读取的就是退票进程已经写入的数据。如果猜想正确的话，期待的最终票数因该还会发生错误，但并不是像第一中那种恰好等于总票数加减数值大的那个数。</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173849.jpg" alt></p>
<p>得到的结果如下，发现最终的票数不在是1000+50=1050，而是分布在1000~1050之间的数值。猜想得到验证。</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173854.jpg" alt></p>
<p>针对上面的猜想（CPU运算速度过快，导致ticketCount=temp和temp=ticketCount两步操作在一个进程的时间片内完成导致的数据错误），另外的一种验证方式是将初始票数和售票退票数设置的足够大，当数据足够大的时候，就会存在一定概率出现在一个进程的ticketCount=temp和temp=ticketCount两步操作之间切换进程的问题，得到的结果就不会类似2.2.1中的那样，而是类似在ticketCount=temp下面加了pthread_yield那样。</p>
 <div align="center">
     <img src width="600" div align="center"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173858.jpg" alt></p>
<p>再次运行，可以看到如下的实验结果：</p>
<div align="center">      <img src width="600" div align="center"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173903.jpg" alt></p>
<h4 id="2-4-2-现象解释2"><a href="#2-4-2-现象解释2" class="headerlink" title="2.4.2 现象解释2"></a>2.4.2 现象解释2</h4><p>在2.2.2节中，当给售票进程和退票进程都加上同步机制后，保证了每个线程操作的原子性，每个线程操作的过程中其他的线程不能对共享的ticketCount变量进程修改，这样的话最终的结果就是正确的结果。</p>
<h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="3-1-实验要求"><a href="#3-1-实验要求" class="headerlink" title="3.1 实验要求"></a>3.1 实验要求</h3><p>$\qquad$一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。</p>
<h3 id="3-2-实验过程"><a href="#3-2-实验过程" class="headerlink" title="3.2 实验过程"></a>3.2 实验过程</h3><ol>
<li><p>实验源码</p>
<p><code>task3.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">sem_t</span> *empty=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sem_t</span> *full=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		<span class="comment">/* fflush(stdin); */</span></span><br><span class="line">		<span class="comment">/* printf("输入："); */</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;buf[i]);</span><br><span class="line">		sem_post(full);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(full);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输出：%c\n"</span>,buf[i]);</span><br><span class="line">		sem_post(empty);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i=<span class="number">-1</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">"empty_"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">"full_"</span>,O_CREAT,<span class="number">0666</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,worker1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,worker2,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	sem_close(empty);</span><br><span class="line">	sem_close(full);</span><br><span class="line">	sem_unlink(<span class="string">"empty_"</span>);</span><br><span class="line">	sem_unlink(<span class="string">"full_"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>work1是输入线程调用的函数，worker2是输出线程调用的函数。</li>
<li>设置两个信号量empty和ful来控制程序的执行，其中empty信号量用于保证输入线程在写入数据到缓存的时候缓存中还有空余的位置，保证写入线程后写入的数据不会把前面写入但是为输出的数据给覆盖掉，其初始值为10，表示最开始缓存中有10个空余的位置供给写入线程写入数据；full信号量是用于保证输出线程有数据输出，避免在写入线程还没有写入数据的情况下输出线程输出随机数据，其初始值为0，表示初始状态下缓存中没有数据可以输出</li>
<li>输入线程在写入一个数据前要等待empty信号量，进入后便消耗一个信号量；完成写入数据操作之后post一个full信号量，通知输出线程输出数据。</li>
<li>输出线程在输出一个数据之前哟啊等待full信号量，进出输出操作后便消耗一个full信号量；完成输出操作后post一个empty信号量，通知写入线程缓存又多一个空余位置以供写入数据。</li>
<li>输出线程每输出一个字符等待一秒钟，方便实验结果的查看。</li>
</ul>
</li>
<li><p>编译源代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task3.c -o task3 -lpthread</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-实验结果"><a href="#3-3-实验结果" class="headerlink" title="3.3 实验结果"></a>3.3 实验结果</h3><h4 id="3-3-1-实验运行现象"><a href="#3-3-1-实验运行现象" class="headerlink" title="3.3.1 实验运行现象"></a>3.3.1 实验运行现象</h4><ol>
<li><p>随机输入字母和数字（10个以内）：124365abc</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173913.jpg" alt></p>
</li>
<li><p>随机输入字母和数字(10个以上)：123456789abcdefg</p>
</li>
</ol>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173917.jpg" alt></p>
<ol>
<li><p>不间断输入：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173920.jpg" alt></p>
<p>通过观察上面的实验现象，可以看到已经满足了实验题目的要求。</p>
</li>
</ol>
<h4 id="3-3-2-实验现象解释"><a href="#3-3-2-实验现象解释" class="headerlink" title="3.3.2 实验现象解释"></a>3.3.2 实验现象解释</h4><ul>
<li>在第一种类型的测试中，输入数据不大于10个字符的时候，由于empty的信号量初始值为10，所以输入进程会一直连续不断的向缓存中写入数据，每写入一个数据，便post一个full信号量，输出线程便能按序输出字符。</li>
<li><p>在第二种类型的测试中，输入数据大于10个字符的时候，由于empty的初始值为10，所以输入的字符中开始的时候只有前10个字符被写入缓存中，其他的在I/O缓冲区等待输入，当输出线程接收到输入线程post的信号量的时候便会开始输出，每输出一个字符便会post一个empty信号量，当输入线程接收到empty信号量的时候有开始从I/O缓冲区读取数据写入到缓存中。</p>
</li>
<li><p>第三种测试和第二种类似，在输出的过程中间输入数据，原理其实是一样的。</p>
</li>
</ul>
<h2 id="Task-4"><a href="#Task-4" class="headerlink" title="Task 4"></a>Task 4</h2><h3 id="4-1-实验要求"><a href="#4-1-实验要求" class="headerlink" title="4.1 实验要求"></a>4.1 实验要求</h3><ol>
<li><p>通过实验测试，验证共享内存的代码中，receiver能否正确读出sender发送的字符串？如果把其中互斥的代码删除，观察实验结果有何不同？如果在发送和接收进程中打印输出共享内存地址，他们是否相同，为什么？</p>
</li>
<li><p>有名管道和无名管道通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？</p>
</li>
<li>消息通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？</li>
</ol>
<h3 id="4-2-实验过程"><a href="#4-2-实验过程" class="headerlink" title="4.2 实验过程"></a>4.2 实验过程</h3><blockquote>
<p>实验过程根据实验要求的三个部分，对应的过程也分为三个部分，具体如下所示</p>
</blockquote>
<h4 id="4-2-1-内存共享"><a href="#4-2-1-内存共享" class="headerlink" title="4.2.1 内存共享"></a>4.2.1 内存共享</h4><ol>
<li><p>实验源码</p>
<blockquote>
<p>内存内存共享实验的源码分为两个部分，分别是Sender.c和Receive.c,</p>
</blockquote>
<p><code>Sender.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filename: Sender.c</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span>  key;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.Product the key</span></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">//2. Creat semaphore for visit the shared memory</span></span><br><span class="line">    sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. init the semaphore, sem=0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line">    <span class="keyword">char</span> *shm_ptr;</span><br><span class="line">    shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. Operation procedure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;      <span class="comment">//first sem(index=0)</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;           <span class="comment">//Increase 1,make sem=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"semop"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shm_ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Receiver.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span>  key;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.Product the key</span></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">//2. Creat semaphore for visit the shared memory</span></span><br><span class="line">    sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. init the semaphore, sem=0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line">    <span class="keyword">char</span> *shm_ptr;</span><br><span class="line">    shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. Operation procedure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;      <span class="comment">//first sem(index=0)</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;           <span class="comment">//Increase 1,make sem=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nNow, receive message process running:\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\tThe message is : %s\n"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"semop"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nExit the receiver process now!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shm_ptr);</span><br><span class="line">    <span class="comment">//7. delete the shared memory</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8. delete the semaphore</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == semctl(sem_id, <span class="number">0</span>, IPC_RMID))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<blockquote>
<p>下面以sender.c为例解释一下如何创建共享内存并通过信号量机制实现互斥访问从而达到进程间通信的目的。</p>
</blockquote>
<ul>
<li><p>创建一个共享内存的ID,就是代码中的key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">key_t</span>  key;</span><br><span class="line">key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 通过ftok函数创建一个key_t类型的变量，作为共享内存的key，ftok函数的两个参数分别是文档名(一个存在的路径),上例中的路径是<code>.</code>表示当前路径，另一个参数是子序号</p>
</blockquote>
</li>
<li><p>创建并初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sem_id;</span><br><span class="line">sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"semget"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == (semctl(sem_id, <span class="number">0</span>, SETVAL, value)))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"semctl"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过semget()函数创建一个信号量，初始值为1，再通过semctl()函数初始化该信号量</p>
</blockquote>
</li>
<li><p>创建共享内存并挂载在进程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. Creat the shared memory(1K bytes)</span></span><br><span class="line">shm_id = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == shm_id)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"shmget"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5. attach the shm_id to this process</span></span><br><span class="line"><span class="keyword">char</span> *shm_ptr;</span><br><span class="line">shm_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == shm_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"shmat"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这部分代码中，首先通过shmget()函数创建了一个大小为1000B的共享内存，然后通过shmat函数，将刚刚创建的共享内存以可读写的方式挂载在进程上，并且指定系统将自动选择一个合适的地址给共享内存，将挂载的共享内存地址赋值给char型指针shm_ptr</p>
</blockquote>
</li>
<li><p>Sender主循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主循环中首先判断表示共享内存访问情况的信号量是否为0(为0表示共享内存空闲)，如果为0的话提示用户输入想要输入的消息，并将用户输入的消息写入共享内存中，写完后通过semop函数将信号量加一，通知receiver读取消息。并且定义一个<code>end</code>命令表示退出当前进程。循环退出的时候取消共享内存的挂载</p>
</blockquote>
</li>
<li><p>Receiver主循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == (value = semctl(sem_id, <span class="number">0</span>, GETVAL)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nNow, receive message process running:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tThe message is : %s\n"</span>, shm_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == semop(sem_id, &amp;sem_b, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit the receiver process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主循环中首先判断表示共享内存访问情况的信号量是否为1(为1表示共享内存已经写入消息，可以读取)，如果为1的话输出该消息，输出后通过semop函数将信号量减1，通知Sender可以再次写入消息。并且定义一个<code>end</code>命令表示退出当前进程。循环退出的时候取消共享内存的挂载</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实验现象</p>
<p>将上述源码编译后进行测试，得到下面的结果。</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173932.jpg" alt></p>
<blockquote>
<p>可以看到sender进程发出的消息receiver进程均准确无误的收到</p>
</blockquote>
</li>
<li><p>删除互斥访问相关的代码</p>
<p>程序主要的代码没有变化，只是在Sender和Receiver进程的主循环中将用于控制互斥访问共享内存的相关代码删除，注释后的结果如下：</p>
<p><code>Sender_2.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nNow, snd message process running:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tInput the snd message:  "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm_ptr);</span><br><span class="line">    <span class="comment">//if enter "end", then end the process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (<span class="built_in">strcmp</span>(shm_ptr ,<span class="string">"end"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExit sender process now!\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Receiver_2.c:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\nNow, receive message process running:\n&quot;);</span><br><span class="line">    printf(&quot;\tThe message is : %s\n&quot;, shm_ptr);</span><br><span class="line"></span><br><span class="line">    //if enter &quot;end&quot;, then end the process</span><br><span class="line">    if(0 == (strcmp(shm_ptr ,&quot;end&quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\nExit the receiver process now!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后加一个sleep(1)用于控制打印的速度，便于观察现象</p>
</blockquote>
</li>
<li><p>删除互斥访问后的实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173937.jpg" alt></p>
<blockquote>
<p>实验现象解释：当删除互斥访问之后，两个进程便没有限制的访问共享内存，Sender进程由于受限于用户输入的速度，会停留一直等待用户输入数据，但是Receiver进程会一直输出共享内存中的消息。</p>
</blockquote>
</li>
<li><p>打印Sender和Receiver进程中共享内存的地址</p>
<p>在原始代码的基础上修改，具体代码文件分别是<code>Sender_3.c</code>和<code>Receiver_3.c</code>，具体修改就是如下：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173942.jpg" alt></p>
<p>在挂载共享内存后打印挂载后的地址</p>
</li>
<li><p>打印共享内存地址实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173945.jpg" alt></p>
<blockquote>
<p>可以看到实验现象，在两个进程中共享内存的地址不一样</p>
</blockquote>
<p>==<strong>现象解释：</strong>==</p>
<p>通过上面的现象可以看到共享内存在不同进程中是不相同的，总结有以下的原因导致共享内存在不同进程中的地址不一样：</p>
<ul>
<li>进程在挂载内存的时候使用的<code>shmat()</code>函数中的第二个参数使用的是NULL，NULL参数的含义是进程让系统分配给共享内存合适的地址。在<code>shmat()</code>函数中，第二个参数有三种选择，分别是：</li>
</ul>
<p>| 参数值 |             NULL             |                             addr                             |                             addr                             |<br>| :——: | :—————————————: | :—————————————————————————————: | :—————————————————————————————: |<br>|  含义  | 系统将自动选择一个合适的地址 | 如果shmaddr非0 并且指定了SHM_RND 则此段连接到shmaddr -（shmaddr mod SHMLAB)所表示的地址上。 | 第三个参数如果在flag中指定了SHM_RDONLY位，则以只读方式连接此段，否则以读写的方式连接此 段。 |</p>
<p>​    可以看到，当addr有具体的值的时候，便将共享内存挂载到指定的地址上</p>
<ul>
<li>现代操作系统中都存在ASLR(地址空间随机化)，ASLR是⼀种针对缓冲区溢出的安全保护机制，具有ASLR机制的操作系统每次加载到内存的程序起始地址会随机变化。系统的这个随机化操作可能导致共享内存的地址不一致。</li>
</ul>
<p>==<strong>验证：</strong>==</p>
<ol>
<li><p>指定Sender_4.c和Receiver_4.c中共享内存的挂载地址为<code>0x7fcc2c0bb000</code></p>
<ul>
<li><p>修改具体的代码如下：</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173951.jpg" alt></p>
</li>
<li><p>运行结果：</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-173955.jpg" alt></p>
<blockquote>
<p>实验结果结果佐证了上面的现象解释，通过指定挂载共享内存的地址，可以使共享内存的地址一致，可以随意指定改地址</p>
</blockquote>
</li>
</ul>
</li>
<li><p>关闭系统的ASLR操作</p>
</li>
</ol>
<ul>
<li>具体的关闭命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   sudo su</span><br><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>  + 运行结果：

    &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;&quot; width=&quot;800&quot; /&gt;&lt;/div&gt;

    ![](http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174000.jpg)

    &gt; 这个实验现象也佐证了系统的ASLR也对导致挂载的共享内存地址不一样
</code></pre><h4 id="4-2-2-管道通信"><a href="#4-2-2-管道通信" class="headerlink" title="4.2.2 管道通信"></a>4.2.2 管道通信</h4><h5 id="（1）无名管道"><a href="#（1）无名管道" class="headerlink" title="（1）无名管道"></a>（1）无名管道</h5><ol>
<li><p>实验源码</p>
<p><code>pipe.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     //for pipe()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;     //for memset()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     //for exit()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pipe(fd))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd[<span class="number">1</span>], <span class="string">"hello,world"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(fd[<span class="number">0</span>], buf, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The message is: %s\n"</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>通过pipe函数创建管道，函数传递一个整形数组fd，fd的两个整形数表示的是两个文件描述符，其中第一个用于读取数据，第二个用于写数据。两个描述符相当远管道的两端，一段负责写数据，一段负责读数据。</li>
<li>pipe管道是半双工的工作模式，某一时刻只能读或者只能写</li>
<li>读写管道就和读写普通文件一样，使用write和read</li>
</ul>
</li>
<li><p>实验现象</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174009.jpg" alt></p>
</li>
<li><p>无名管道同步机制验证</p>
<blockquote>
<p>为了验证无名管道的同步机制，在上述代码的基础上进行修改，得到如下的代码</p>
</blockquote>
<p><code>pipe_2.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     //for pipe()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;     //for memset()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     //for exit()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == pipe(fd))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	child=fork();</span><br><span class="line">	<span class="keyword">if</span>(child==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="string">"EXIT_FAILURE"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//关闭子进程中不需要的写描述符</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf))&gt;<span class="number">0</span>)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"子进程接收的消息是:%s\n"</span>,buf);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"子进程:管道中没有数据\n"</span>);</span><br><span class="line">			sleep(<span class="number">2</span>);		</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"end"</span>)==<span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(child&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"父进程中-请输入消息:"</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">			write(fd[<span class="number">1</span>],buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"end"</span>)==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于上述代码做出如下解释：父进程是消息的发送者，在父进程中创建了两个文件描述符，fork一个子进程的时候会复制这两个管道文件描述符，因此父进程和子进程都会将自己的那个用不到的文件描述符关闭。父进程中会持续向管道中写入用户输入的消息，子进程会一直输出管道中的消息，如果管道中没有消息就会阻塞等待。</p>
</blockquote>
</li>
<li><p>无名管道同步机制实验现象</p>
<div align="center"><img src width="600"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174012.jpg" alt></p>
<blockquote>
<p>可以看到输出进程是按照输入进程输入的顺序输出数据，并且当输入进程没有数据输入，即管道中没有数据的时候，输出进程会阻塞。因此无名管道通信系统调用的时候已经yijing实现了同步机制</p>
</blockquote>
</li>
<li><p>无名管道同步机制原理</p>
<p>通过上面的实验和查阅相关资料，得到无名管道如下的同步机制：</p>
<ul>
<li><p>管道的读写通过两个系统调用write和read实现</p>
</li>
<li><p>发送者在向管道内存中写入数据之前，首先<strong>检查内存是否被读进程锁定</strong>和<strong>内存中是否还有剩余空间</strong>，如果这两个要求都满足的话write函数会对内存上锁，然后进行写入数据，写完之后解锁；否则就会等待(阻塞)。</p>
</li>
<li>写进程在读取管道中的数据之前，也会<strong>检查内存是否被读进程锁定</strong>和<strong>管道内存中是否有数据</strong>，如果满足这两个条件，read函数会对内存上锁，读取数据后在解锁；否则会等到(阻塞)</li>
</ul>
</li>
</ol>
<h5 id="（2）有名管道"><a href="#（2）有名管道" class="headerlink" title="（2）有名管道"></a>（2）有名管道</h5><ol>
<li><p>实验代码</p>
<blockquote>
<p>有名管道实验中设计两个代码文件<code>fifo_send.c</code>和<code>fifo_rcv.c</code></p>
</blockquote>
<p><code>fifo_send.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"./my_fifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"hello,world"</span>;</span><br><span class="line">    <span class="comment">//1. check the fifo file existed or not</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = access(FIFO, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)    <span class="comment">//file /tmp/my_fifo existed</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="number">-1</span> == mkfifo(FIFO, <span class="number">0766</span>))</span><br><span class="line">    	&#123;</span><br><span class="line">    	    perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">    	    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.Open the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> fifo_fd;</span><br><span class="line">    fifo_fd = open(FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. write the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = write(fifo_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="keyword">sizeof</span>(buf))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write the message ok!\n"</span>);</span><br><span class="line"></span><br><span class="line">    close(fifo_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fifo_rcv.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *File: fifo_rcv.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"./my_fifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`. check the fifo file existed or not</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = access(FIFO, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)    <span class="comment">//file /tmp/my_fifo existed</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==mkfifo(FIFO,<span class="number">0766</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo"</span>); </span><br><span class="line">            <span class="built_in">exit</span>(<span class="string">"EXIT_FAILURE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	2.Open the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> fifo_fd;</span><br><span class="line">    fifo_fd = open(FIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. read the fifo file</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = read(fifo_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Read %d words: %s\n"</span>, num, buf);</span><br><span class="line">    close(fifo_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li>写进程fifo_send分为四个步骤执行，首先判断当前目录下是否已经存在my_fifo文件，不存在的话在当前目录下通过mkfifo()函数创建FIFO类型的文件my_fifo；再通过open()函数打开my_fifo文件，最后向文件中写入消息；</li>
<li>读进程的过程和写进程的类似，只没有了创建fifo文件的过程而已</li>
</ul>
</li>
<li><p>实验现象</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174019.jpg" alt></p>
<blockquote>
<p>现象描述：在仅仅只运行fifo_send进程的时候，没有任何输出，进程一直阻塞，直到fifo_rcv进程运行，两个进程才开始输出信息。</p>
</blockquote>
<p>当写进程和读进程都设置成阻塞状态的时候，不论先执行那个进程，先执行的进程都会阻塞等待，待另一个进程执行后两个进程才正常执行。</p>
</li>
<li><p>探究有名管道的同步和阻塞机制</p>
<p>通过<code>fifo_fd=open(FIFO,O_RDONLY | O_NONBLOCK)</code>设置为非阻塞状态，<code>fifo_fd=open(FIFO,O_RDONLY)</code>设置为阻塞状态，对应四个进程分别为fifo_send(阻塞)、fifo_rcv(阻塞)、fifo_send_1(非阻塞)、fifo_rcv_1(非阻塞)</p>
<ul>
<li><p>读进程阻塞、写进程阻塞</p>
<ul>
<li><p>先执行fifo_send后执行fifo_rcv，结果正确</p>
<p>截图请见上面的实验现象</p>
</li>
<li><p>先执行fifo_rcv后执行fifo_send，结果正确</p>
</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174023.jpg" alt></p>
<p>具体的原因是读进程在open FIFO的时候由于没有s</p>
<p>通过查阅资料得到了FIFO管道的阻塞机制如下：</p>
<p>对于设置了阻塞的读进程而言：</p>
<blockquote>
<ol>
<li>读进程阻塞的原因有三种：FIFO 中没有数据、有其他的读进程正在读取这些数据、没有写进程打开FIFO文件</li>
<li>不论是哪种原因引起的阻塞，解开阻塞的原因都是FIFO有新的数据写入</li>
<li>如果一个读进程有多个read操作，那么只会阻塞第一个read，其他的不会发生阻塞</li>
</ol>
</blockquote>
<p>对于设置了阻塞的写进程而言：</p>
</li>
</ul>
<blockquote>
<ol>
<li>当写入的数据量小于PIPE_BUF时，Linux保证写入原子性。如果此时管道中的空闲位置不足以容纳要写入的数据，泽写进程阻塞，直到管道中空间足够，一次性写入所有数据</li>
<li>当写入的数据量大于PIPE_BUF时，Linux不再保证写入的原子性。一旦管道中有空闲位置便尝试写入数据，直到所有数据写入完成后返回。</li>
</ol>
</blockquote>
<ul>
<li><p>读进程阻塞，写进程非阻塞</p>
<ul>
<li>先执行fifo_send_1后执行fifo_rcv，写进程open函数返回-1</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174026.jpg" alt></p>
<ul>
<li>先执行fifo_rcv后执行fifo_send_1，结果正常</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174030.jpg" alt></p>
</li>
<li><p>读进程非阻塞，写进程阻塞</p>
<ul>
<li>先执行fifo_send后执行fifo_rcv_1,结果正常</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174035.jpg" alt></p>
<ul>
<li>先执行fifo_rcv_1后执行fifo_send，程序崩溃</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174039.jpg" alt></p>
</li>
<li><p>读写进程都是非阻塞</p>
<ul>
<li>先执行fifo_send_1后执行fifo_rcv_1</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174043.jpg" alt></p>
<ul>
<li>先执行fifo_rcv_1后执行fifo_send_1</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174046.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<h4 id="4-2-3-消息队列"><a href="#4-2-3-消息队列" class="headerlink" title="4.2.3 消息队列"></a>4.2.3 消息队列</h4><ol>
<li><p>实验代码</p>
<blockquote>
<p>本实验代码文件分为Server.c和Client.c两个</p>
</blockquote>
<p><code>Server.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Rebuild the strcut (must be)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. creat a mseg queue</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgId;</span><br><span class="line">    </span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    msgId = msgget(key, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgId)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process (%s) is started, pid=%d\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm(<span class="number">0</span>);</span><br><span class="line">        alarm(<span class="number">600</span>);     <span class="comment">//if doesn't receive messge in 600s, timeout &amp; exit</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">rcvBuf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;rcvBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(struct msgbuf));</span><br><span class="line">        msgrcv(msgId, &amp;rcvBuf, BUF_SIZE, <span class="number">1</span>, <span class="number">0</span>);                </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Receive msg: %s\n"</span>, rcvBuf.mtext);</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sndBuf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;sndBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sndBuf));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncpy</span>((sndBuf.mtext), (rcvBuf.mtext), <span class="built_in">strlen</span>(rcvBuf.mtext)+<span class="number">1</span>);</span><br><span class="line">        sndBuf.mtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == msgsnd(msgId, &amp;sndBuf, <span class="built_in">strlen</span>(rcvBuf.mtext)+<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//if scanf "end~", exit</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"end~"</span>, rcvBuf.mtext))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d exit~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Client.c:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Rebuild the strcut (must be)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. creat a mseg queue</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgId;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d started~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line"></span><br><span class="line">    key = ftok(<span class="string">"."</span>, <span class="number">0xFF</span>);</span><br><span class="line">    msgId = msgget(key, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgId)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. creat a sub process, wait the server message</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (pid = fork()))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"vfork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//In child process</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            alarm(<span class="number">0</span>);</span><br><span class="line">            alarm(<span class="number">100</span>);     <span class="comment">//if doesn't receive messge in 100s, timeout &amp; exit</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">rcvBuf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;rcvBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(struct msgbuf));</span><br><span class="line">            msgrcv(msgId, &amp;rcvBuf, BUF_SIZE, <span class="number">2</span>, <span class="number">0</span>);                </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Server said: %s\n"</span>, rcvBuf.mtext);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//parent process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sndBuf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;sndBuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sndBuf));</span><br><span class="line">            <span class="keyword">char</span> buf[BUF_SIZE] ;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nInput snd mesg: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">strncpy</span>(sndBuf.mtext, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">            sndBuf.mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == msgsnd(msgId, &amp;sndBuf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">//if scanf "end~", exit</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"end~"</span>, buf))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"THe process(%s),pid=%d exit~\n"</span>, argv[<span class="number">0</span>], getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解释</p>
<ul>
<li><p>程序分为服务器端和客户端，客户端向服务器发起通信，服务器端收到数据后将一模一样的数据返回</p>
</li>
<li><p>通过mgsrcv函数读取客户端传过来的消息，msgrcv的参数列表见下面。</p>
<p><code>int msgrcv(int msqid, void  *ptr, size_t  length, long  type, int  flag);</code></p>
</li>
</ul>
<p>| 参数 |     msgid      |      ptr       |    length    |                             type                             |                          flag                          |<br>| :—: | :——————: | :——————: | :—————: | :—————————————————————————————: | :——————————————————————————: |<br>| 含义 | 消息队列标识符 | 消息缓冲区指针 | 消息数据长度 |                 决定从队列中返回那一条下消息                 |                        阻塞与否                        |<br>| 备注 |                |                |              | =0 返回消息队列中第一条消息<br>&gt;0 返回消息队列中等于mtype 类型的第一条消息。<br>&lt;0 返回mtype&lt;=type 绝对值最小值的第一条消息。 | msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式 |</p>
<ul>
<li>通过msgsnd函数向消息队列中加入消息，msgsnd的参数列表见下面。</li>
</ul>
<p><code>int msgsnd(int  msqid, const  void   *ptr, size_t    length, int   flag);</code></p>
<p>| 参数 |     msgid      |      ptr       |    length    |                          flag                          |<br>| :—: | :——————: | :——————: | :—————: | :——————————————————————————: |<br>| 含义 | 消息队列标识符 | 消息缓冲区指针 | 消息数据长度 |                        阻塞与否                        |<br>| 备注 |                |                |              | msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式 |</p>
<ul>
<li>客户端的子进程主要负责消息的接受，父进程主要负责消息的发送；</li>
<li>通过分析上面的代码可以知道，客户端和服务器端都是以阻塞的方式读取和写入消息</li>
</ul>
</li>
<li><p>程序运行结果</p>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174053.jpg" alt></p>
</li>
<li><p>探究消息队列的同步和阻塞机制</p>
<blockquote>
<p>通过上面的程序解释中可以看出，消息队列通过msgrcv和msgsnd两个函数的flag参数控制是否阻塞，将其设置为IPC_NOWAIT表示不阻塞；如果客户端和服务器端都设置阻塞话，就可以达到同步的目的</p>
</blockquote>
<p>现在做出如下探究：</p>
<ul>
<li>客服端不阻塞(代码为Client_1.c),服务器端阻塞，得到结果如下。</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174058.jpg" alt></p>
<blockquote>
<p>可以看到当客户端不阻塞的话在客户端接受服务器端消息的时候会无限制的打印消息队列中的空消息，哪怕消息队列中没有任何消息</p>
</blockquote>
<ul>
<li>客户端阻塞，服务器端不阻塞(代码为Server_1.c)</li>
</ul>
<div align="center"><img src width="800"></div>

<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-174105.jpg" alt></p>
<blockquote>
<p>可以看到当服务器端没有设置阻塞的时候，服务器端会一直接受消息队列中的空消息并向客户端转发。 </p>
</blockquote>
</li>
</ol>
<h2 id="Task-5"><a href="#Task-5" class="headerlink" title="Task 5"></a>Task 5</h2><blockquote>
<p>本实验分析进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。</p>
</blockquote>
<p>我们首先从<code>devices/timer.c</code>文件中的timer_sleep函数开始 分析，下面是该函数的具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sleeps for approximately TICKS timer ticks.  Interrupts must</span></span><br><span class="line"><span class="comment">   be turned on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_sleep</span> <span class="params">(<span class="keyword">int64_t</span> ticks)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> start = timer_ticks ();</span><br><span class="line">  ASSERT (intr_get_level () == INTR_ON);</span><br><span class="line">  <span class="keyword">while</span> (timer_elapsed (start) &lt; ticks) </span><br><span class="line">    thread_yield ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始逐行分析这个函数，第5行的<code>timer_ticks</code>函数也在timer.c文件中，跳转到该函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the number of timer ticks since the OS booted. */</span></span><br><span class="line"><span class="keyword">int64_t</span> timer_ticks (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">int64_t</span> t = ticks;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timer_ticks</code>函数中第4行涉及一个名为intr_disable()的函数，该函数的具体定义在<code>devices/interrupt.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disables interrupts and returns the previous interrupt status. */</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_level <span class="title">intr_disable</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_get_level ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable interrupts by clearing the interrupt flag.</span></span><br><span class="line"><span class="comment">     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable</span></span><br><span class="line"><span class="comment">     Hardware Interrupts". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"cli"</span> : : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> old_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看看返回值<code>intr_level</code>是个什么结构,代码在<code>devices/interrupt.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts on or off? */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level </span><br><span class="line">  &#123;</span><br><span class="line">    INTR_OFF,             <span class="comment">/* Interrupts disabled. */</span></span><br><span class="line">    INTR_ON               <span class="comment">/* Interrupts enabled. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现，intr_level这个枚举类型表示的是是否允许中断。于是分析得到<code>intr_disable</code>函数做了两件事。1. 调用<code>intr_old_level</code>函数 2. 直接执行汇编代码保证这个线程不能被中断。之后返回调用<code>intr_old_level</code>函数的返回值。</p>
<p>再看看<code>intr_get_level</code>函数的实现细节，该函数的定义也在<code>devices/interrupt.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current interrupt status. */</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_level <span class="title">intr_get_level</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line">  <span class="comment">/* Push the flags register on the processor stack, then pop the</span></span><br><span class="line"><span class="comment">     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"</span></span><br><span class="line"><span class="comment">     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware</span></span><br><span class="line"><span class="comment">     Interrupts". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"pushfl; popl %0"</span> : <span class="string">"=g"</span> (flags))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> flags &amp; FLAG_IF ? INTR_ON : INTR_OFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释信息和分析汇编代码可以知道，<code>intr_get_level</code>这个函数的作用是返回当前的中断状态。<code>intr_get_level</code>函数弄清楚了之后，返回上一层函数中，到了<code>intr_disable</code>函数中，这样就可以清楚的知道<code>intr_disable</code>函数的作用：</p>
<ul>
<li>获取当前中断状态</li>
<li>将当前中断状态更改为不可中断</li>
<li>返回先前的中断状态</li>
</ul>
<p>弄清楚了<code>intr_disable</code>函数，接着看<code>timer_ticks</code>函数的5、6、7行</p>
<ul>
<li>第5行通过一个int64_t类型的变量t获取全局变量ticks的值；</li>
<li><p>第6行<code>intr_set_level(old_level)</code>表示将当前中断状态设置为之前的中断状态。</p>
</li>
<li><p>第7行返回t</p>
</li>
</ul>
<p>这样，函数<code>timer_ticks</code>的含义也就弄清楚了。其实<code>timer_ticks</code>函数的作用很简单，就是想获取当前系统的ticks值而已，而上面通过这么大篇幅的介绍<code>timer_ticks</code>函数的4、6两行的作用，原因是第4行和第6行通过先关闭中断，待t获取到ticks值之后载恢复之前的中断状态，来保证操作的原子性，简单的说就是在t获取全局变量ticks的值的时候，不能被打断。</p>
<p>然后接着分析<code>timer_sleep</code>函数的第6行<code>ASSERT (intr_get_level () == INTR_ON);</code>这里是一个断言，当<code>intr_get_lvel</code>函数获取的当前中断状态不是<code>INTR_ON</code>的时候发生警告且退出。</p>
<p><code>timer_sleep</code>函数剩下的就是一个循环了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (timer_elapsed (start) &lt; ticks) </span><br><span class="line">    thread_yield ();</span><br></pre></td></tr></table></figure>
<p>通过分析不难得出<code>timer_elapsed()</code>函数的作用是计算当前的系统ticks减去之前得到的start的差值，如果这个差值小于函数参数ticks的话一直执行thread_yield()函数。</p>
<p>再看看<code>thread_yield</code>函数的具体定义（在<code>thread/thread.c文件中</code>），分析一下该函数的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Yields the CPU.  The current thread is not put to sleep and</span></span><br><span class="line"><span class="comment">   may be scheduled again immediately at the scheduler's whim. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_yield</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">if</span> (cur != idle_thread) </span><br><span class="line">    list_push_back (&amp;ready_list, &amp;cur-&gt;elem);</span><br><span class="line">  cur-&gt;status = THREAD_READY;</span><br><span class="line">  schedule ();</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_yield</code>函数第5行顾名思义，作用就是返回当前正在运行的线程，通过一个thread类型的结构体指针接受该函数返回值。</p>
<p><code>thread_yield</code>函数的第7行通过断言的方式判断中断类型，如果是由于I/O等引起的硬中断则退出，如果是软中断的话正常运行。</p>
<p>再看第8行和第13行的之前也分析过，这是保证9-12行操作的原子性。</p>
<p>再分析9-12行：</p>
<ul>
<li>9-10行：如何当前线程不是空闲的线程就调用list_push_back把当前线程的元素扔到就绪队列里面， </li>
<li>11行：把线程改成THREAD_READY状态</li>
<li>12行：调用schedule函数</li>
</ul>
<p>再深入<code>schedule</code>函数(<code>thread/thread.c文件</code>)看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Schedules a new process.  At entry, interrupts must be off and</span></span><br><span class="line"><span class="comment">   the running process's state must have been changed from</span></span><br><span class="line"><span class="comment">   running to some other state.  This function finds another</span></span><br><span class="line"><span class="comment">   thread to run and switches to it.</span></span><br><span class="line"><span class="comment">   It's not safe to call printf() until thread_schedule_tail()</span></span><br><span class="line"><span class="comment">   has completed. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span> = <span class="title">next_thread_to_run</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line">  ASSERT (cur-&gt;status != THREAD_RUNNING);</span><br><span class="line">  ASSERT (is_thread (next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur != next)</span><br><span class="line">    prev = switch_threads (cur, next);</span><br><span class="line">  thread_schedule_tail (prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule</code>函数首先获取当前正在运行的线程指针cur和下一个运行的线程next，之后是三个断言。</p>
<ul>
<li><code>ASSERT (intr_get_level () == INTR_OFF)</code>：保证中断状态是开启的</li>
<li><code>ASSERT (cur-&gt;status != THREAD_RUNNING)</code>：保证当前运行的线程是RUNNING_THREAD的</li>
<li><code>ASSERT (is_thread (next))</code>：保证下一个线程有效</li>
</ul>
<p>17-18行的作用是：如果当前线程和下一个要跑的线程不是同一个的话调用switch_threads返回给prev</p>
<p>下面再看看<code>switch_threads</code>函数(在<code>threads/switch.S</code>中)这是一个完全由汇编语言编写的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;threads/switch.h&quot;</span><br><span class="line"></span><br><span class="line">#### struct thread *switch_threads (struct thread *cur, struct thread *next);</span><br><span class="line">####</span><br><span class="line">#### Switches from CUR, which must be the running thread, to NEXT,</span><br><span class="line">#### which must also be running switch_threads(), returning CUR in</span><br><span class="line">#### NEXT&apos;s context.</span><br><span class="line">####</span><br><span class="line">#### This function works by assuming that the thread we&apos;re switching</span><br><span class="line">#### into is also running switch_threads().  Thus, all it has to do is</span><br><span class="line">#### preserve a few registers on the stack, then switch stacks and</span><br><span class="line">#### restore the registers.  As part of switching stacks we record the</span><br><span class="line">#### current stack pointer in CUR&apos;s thread structure.</span><br><span class="line"></span><br><span class="line">.globl switch_threads</span><br><span class="line">.func switch_threads</span><br><span class="line">switch_threads:</span><br><span class="line">	# Save caller&apos;s register state.</span><br><span class="line">	#</span><br><span class="line">	# Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,</span><br><span class="line">	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See</span><br><span class="line">	# [SysV-ABI-386] pages 3-11 and 3-12 for details.</span><br><span class="line">	#</span><br><span class="line">	# This stack frame must match the one set up by thread_create()</span><br><span class="line">	# in size.</span><br><span class="line">	pushl %ebx</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line"></span><br><span class="line">	# Get offsetof (struct thread, stack).</span><br><span class="line">.globl thread_stack_ofs</span><br><span class="line">	mov thread_stack_ofs, %edx</span><br><span class="line"></span><br><span class="line">	# Save current stack pointer to old thread&apos;s stack, if any.</span><br><span class="line">	movl SWITCH_CUR(%esp), %eax</span><br><span class="line">	movl %esp, (%eax,%edx,1)</span><br><span class="line"></span><br><span class="line">	# Restore stack pointer from new thread&apos;s stack.</span><br><span class="line">	movl SWITCH_NEXT(%esp), %ecx</span><br><span class="line">	movl (%ecx,%edx,1), %esp</span><br><span class="line"></span><br><span class="line">	# Restore caller&apos;s register state.</span><br><span class="line">	popl %edi</span><br><span class="line">	popl %esi</span><br><span class="line">	popl %ebp</span><br><span class="line">	popl %ebx</span><br><span class="line">        ret</span><br><span class="line">.endfunc</span><br><span class="line"></span><br><span class="line">.globl switch_entry</span><br><span class="line">.func switch_entry</span><br><span class="line">switch_entry:</span><br><span class="line">	# Discard switch_threads() arguments.</span><br><span class="line">	addl $8, %esp</span><br><span class="line"></span><br><span class="line">	# Call thread_schedule_tail(prev).</span><br><span class="line">	pushl %eax</span><br><span class="line">.globl thread_schedule_tail</span><br><span class="line">	call thread_schedule_tail</span><br><span class="line">	addl $4, %esp</span><br><span class="line"></span><br><span class="line">	# Start thread proper.</span><br><span class="line">	ret</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure>
<p>分析这段汇编代码，首先将4个寄存器的值压栈保护寄存器状态，这四个寄存器的值是<code>switch_threads_frame</code>的成员，<code>switch_threads_frame</code>结构的具体定义如下(<code>thread/switch.h</code>中定义)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* switch_thread()'s stack frame. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">switch_threads_frame</span> </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> edi;               <span class="comment">/*  0: Saved %edi. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> esi;               <span class="comment">/*  4: Saved %esi. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;               <span class="comment">/*  8: Saved %ebp. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;               <span class="comment">/* 12: Saved %ebx. */</span></span><br><span class="line">    <span class="keyword">void</span> (*eip) (<span class="keyword">void</span>);         <span class="comment">/* 16: Return address. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span>;</span>         <span class="comment">/* 20: switch_threads()'s CUR argument. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span>;</span>        <span class="comment">/* 24: switch_threads()'s NEXT argument. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>全局变量<code>thread_stack_ofs</code>记录线程和栈之间的间隙，下面我们来看线程切换中保存现场的过程。</p>
<ul>
<li><p>35-36行：先把当前的线程指针放到eax中， 并把线程指针保存在相对基地址偏移量为edx的地址中</p>
</li>
<li><p>40-41: 切换到下一个线程的线程栈指针， 保存在ecx中， 再把这个线程相对基地址偏移量edx地址（上一次保存现场的时候存放的）放到esp当中继续执行。</p>
<blockquote>
<p>这里ecx, eax起容器的作用， edx指向当前现场保存的地址偏移量。简单来说就是保存当前线程状态， 恢复新线程之前保存的线程状态。</p>
</blockquote>
</li>
</ul>
<p>由此我们可以看出<code>schedule</code>函数是先将当前线程放入就绪队列，如果下一个线程和当前线程不一样的话切换到下一个线程。</p>
<p>再看看<code>shcedule</code>函数最后一行执行的操作，最后一行调用<code>thread_schedule_tail</code>函数，下面详细分析一下这个函数（<code>thread/thread.c</code>文件中）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_schedule_tail</span> <span class="params">(struct thread *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  </span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark us as running. */</span></span><br><span class="line">  cur-&gt;status = THREAD_RUNNING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start new time slice. */</span></span><br><span class="line">  thread_ticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USERPROG</span></span><br><span class="line">  <span class="comment">/* Activate the new address space. */</span></span><br><span class="line">  process_activate ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the thread we switched from is dying, destroy its struct</span></span><br><span class="line"><span class="comment">     thread.  This must happen late so that thread_exit() doesn't</span></span><br><span class="line"><span class="comment">     pull out the rug under itself.  (We don't free</span></span><br><span class="line"><span class="comment">     initial_thread because its memory was not obtained via</span></span><br><span class="line"><span class="comment">     palloc().) */</span></span><br><span class="line">  <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread) </span><br><span class="line">    &#123;</span><br><span class="line">      ASSERT (prev != cur);</span><br><span class="line">      palloc_free_page (prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是获得当前线程的的cur(切换之后的线程)，然后将cur的状态改为<code>THREAD_RUNNING</code>，然后thread_ticks清零开始新的线程切换时间片。然后调用diaoyong<code>process_activate</code>函数申请新的地址空间，再分析<code>process_active</code>函数(在<code>useruserprog/process.c</code>文件中定义)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sets up the CPU for running user code in the current</span></span><br><span class="line"><span class="comment">   thread.</span></span><br><span class="line"><span class="comment">   This function is called on every context switch. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_activate</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="comment">/* Activate thread's page tables. */</span></span><br><span class="line">  pagedir_activate (t-&gt;pagedir);</span><br><span class="line">  <span class="comment">/* Set thread's kernel stack for use in processing</span></span><br><span class="line"><span class="comment">     interrupts. */</span></span><br><span class="line">  tss_update ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的就是<code>pagedir_activate()</code>函数和<code>tss_update</code>函数，这两个函数分别位于<code>userprog/pagedir.c</code>和<code>userprog/tss.c</code>文件中</p>
<p>下面再进入<code>pagedir_activate()</code>函数中查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Loads page directory PD into the CPU's page directory base</span></span><br><span class="line"><span class="comment">   register. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pagedir_activate</span> <span class="params">(<span class="keyword">uint32_t</span> *pd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    pd = init_page_dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the physical address of the page directory into CR3</span></span><br><span class="line"><span class="comment">     aka PDBR (page directory base register).  This activates our</span></span><br><span class="line"><span class="comment">     new page tables immediately.  See [IA32-v2a] "MOV--Move</span></span><br><span class="line"><span class="comment">     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base</span></span><br><span class="line"><span class="comment">     Address of the Page Directory". */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%cr3"</span> : : <span class="string">"r"</span> (vtop (pd)) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个汇编指令将当前线程的页目录指针存储到CR3（页目录表物理内存基地址寄存器）中，也就是说这个函数更新了现在的页目录表</p>
<p>再进入<code>tss_update</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sets the ring 0 stack pointer in the TSS to point to the end</span></span><br><span class="line"><span class="comment">   of the thread stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tss_update</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (tss != <span class="literal">NULL</span>);</span><br><span class="line">  tss-&gt;esp0 = (<span class="keyword">uint8_t</span> *) thread_current () + PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tss指的是 task state segment， 叫任务状态段， 任务（进程）切换时的任务现场信息。这里其实是把TSS的一个栈指针指向了当前线程栈的尾部， 也就是更新了任务现场的信息和状态。</p>
<p>到此<code>process_activate</code>函数的分析完毕，它做了两件事：</p>
<ul>
<li>更新页目录表</li>
<li>更新任务现场信息（tss）</li>
</ul>
<p>在继续看<code>thread_schedule_tail</code>函数的最后4行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread) </span><br><span class="line">&#123;</span><br><span class="line">    ASSERT (prev != cur);</span><br><span class="line">    palloc_free_page (prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是说如果我们切换的线程状态是THREAD_DYING（代表欲要销毁的线程）的话， 调用palloc_free_page（<code>thread/palloc.c</code>文件中定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Frees the page at PAGE. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">palloc_free_page</span> <span class="params">(<span class="keyword">void</span> *page)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  palloc_free_multiple (page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单而言作用就是释放PAGE参数中的页面</p>
<p>到此，<code>thread_schedule_tail</code>函数分析完毕，其作用就是分配恢复之前执行的状态和现场， 如果当前线程死了就清空资源。</p>
<p><code>schedule</code>函数的作用就是拿下一个线程切换过来继续运行。<code>thread_yield</code>函数的作用是shi把当前进程放在就绪队列里，调用<code>schedule</code>切换到下一个进程。</p>
<p>最后返回到最顶层的<code>timer_sleep</code>函数，他的作用就是在ticks的时间内nei，如果线程处于running状态就不断的把它放在就绪队列不让它执行。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/11/lab2/" class="post-title-link" itemprop="url">进程实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-03-11 20:10:33" itemprop="dateCreated datePublished" datetime="2019-03-11T20:10:33+08:00">2019-03-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-12 17:35:49" itemprop="dateModified" datetime="2019-09-12T17:35:49+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统实验/" itemprop="url" rel="index"><span itemprop="name">操作系统实验</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>3.9k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>4 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验二实验报告"><a href="#实验二实验报告" class="headerlink" title="实验二实验报告"></a>实验二实验报告</h1><blockquote>
<p>孙汉武    16281047    安全1601</p>
</blockquote>
<h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><h3 id="1-1-实验步骤"><a href="#1-1-实验步骤" class="headerlink" title="1.1 实验步骤"></a>1.1 实验步骤</h3><ol>
<li><p>打开一个vi进程</p>
</li>
<li><p>通过ps命令找到名字为vi的进程，命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -auxc | grep vi$</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171938.jpg" width="600"></p>
<p>这里对该命令中的参数做出解释</p>
<ul>
<li><code>-aux</code>:    显示所有进程</li>
<li><code>-c</code>:            将command列输出更改为可执行文件名而不是命令名称</li>
<li><code>grep</code>         正则表达式搜索</li>
<li><code>vi$</code>           匹配结尾为vi字符串    </li>
</ul>
<p>这里对ps命令的输出结果每一列的含义做出解释，<code>ps -aux</code>命令的输出结果一共有十一列，从左往右分别是：</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>进程所属用户名</td>
<td>进程ID</td>
<td>占用CPU百分比</td>
<td>占用内存百分比</td>
<td>虚拟大小</td>
<td>驻留中页的数量</td>
</tr>
<tr>
<td>示例</td>
<td>ubuntu</td>
<td>13716</td>
<td>0.0</td>
<td>0.5</td>
<td>40384</td>
<td>10144</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>终端ID</td>
<td>进程状态</td>
<td>开始时间</td>
<td>累计CPU时间</td>
<td></td>
</tr>
<tr>
<td>实例</td>
<td>pts/2</td>
<td>S+</td>
<td>20:33</td>
<td>0:00</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>寻找vi的父进程，直到init进程为止</p>
<p>使用如下命令查看指定进程的父进程的PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.&lt;pid&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<ol>
<li><code>-eo</code>    表示按照指定格式输出，这里指定的格式是pid,ppid,user,command</li>
<li>\<pid\>     是要查询的pid号</pid\></li>
</ol>
</blockquote>
<p>\<pid\>填写查询进程的pid.</pid\></p>
<ul>
<li><p>通过步骤2可知vi的pid为13716，所以查询vi的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w 13716</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171945.jpg" width="600"></p>
<p>由图可知，vi的父进程的pid是7854</p>
</li>
<li><p>查询7854的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.7854</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171948.jpg" width="600"></p>
<p>由图可知，7854的父进程的pid是7745</p>
</li>
<li><p>查询7745的父进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w ^.7745</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171955.jpg" width="600"></p>
<p>由图可知，7745的父进程的pid是1</p>
</li>
<li><p>查询1的父进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,user,command | grep -w 1</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171958.jpg" width="600"></p>
</li>
</ul>
<p>综上所述，可以得到如下结果：</p>
<p>| 进程号 | 父进程号 | 所属用户 | 命令 |<br>| ——— | ———— | ———— | —— |<br>| 13716  | 7854     | ubuntu   | vi   |<br>| 7854   | 7745     | ubuntu   | -zsh |<br>| 7745   | 1        | ubuntu   | tmux |<br>| 1      | 0        | root     | init |</p>
<ol>
<li>将步骤三得到的进程树和pstree得到的进程树比较</li>
</ol>
<p>通过<code>pstree</code>命令得到如下结果：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172002.jpg" width="600"></p>
<p>左边的虚线代表init进程，可以看到两种方式得到的进程树是相同的。</p>
<p>两种方式各自的优点如下：</p>
<ul>
<li><code>pstree</code>:<ul>
<li>进程树比较直观，一目了然</li>
<li>能一次显示所有的进程的进程树</li>
</ul>
</li>
<li><code>ps</code>命令查询出的进程树<ul>
<li>能查看每个中间进程的详细信息</li>
<li>ps命令自主性比较好，可以由用户自定义参数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="2-1-实验步骤"><a href="#2-1-实验步骤" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ul>
<li>实验代码如下：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1a82h4avqj31370u0436.jpg" width="600"></p>
<ul>
<li><p>编译并运行程序</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172008.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172011.jpg" width="600"></p>
</li>
<li><p>查看vi进程和父进程的状态</p>
<ul>
<li>vi进程</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172015.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172020.jpg" width="600"></p>
<p>​    可以看到vi进程的进程号为12703,父进程pid为12702，占用CPU和MEM分别为0.5%和0.6%</p>
<ul>
<li><p>vi进程父进程</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172027.jpg" width="600"></p>
</li>
</ul>
</li>
<li><p>对所有进程按照CPU占用率排序</p>
<ul>
<li><p>方法一：使用htop命令，自动按照CPU占用率对进程排序</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172032.jpg" width="600"></p>
</li>
<li><p>方法二：使用top命令按照CPU占用率对进程排序</p>
<p>​        <img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172037.jpg" width="600"></p>
<p>​        </p>
</li>
</ul>
</li>
</ul>
<h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="2-1-实验步骤-1"><a href="#2-1-实验步骤-1" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ol>
<li><p>实验源码</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1a83mqnwoj30uk0u0gr4.jpg" width="600">    </p>
<p>对上述源码的分析包含以下几个方面：</p>
<ul>
<li>fork函数的功能和返回值：<ul>
<li>fork的功能是从当前行开始复制父进程，创建一个和父进程一样的子进程</li>
<li>fork的返回值在父进程中大于0，在子进程中等于0，如果创建子进程发生错误返回-1</li>
</ul>
</li>
<li>程序流程如下：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172042.jpg" width="600"></p>
<ul>
<li><p>程序解释：</p>
<p>结合上面的程序流程图，可以看到程序执行最初的那个进程就是父进程A，在一开始就通过fork函数创建一个子进程B，并用p1接受fork的返回值，由于p1在进程A和进程B的值不同，所以两个进程接下来执行的代码部分并不相同。进程A执行p1&gt;0的部分代码，并且在p1&gt;0的那部分代码中，进程A再次通过fork创建了一个子进程C。随后进程A和进程C分别打印自己的pid和ppid(父进程id)。在来看进程B，在p1==0的那部分代码中，进程B也是通过fork创建了一个子进程D,并将fork的返回值交给p2，在父进程B中，p2的值大于0，所以父进程B还创建了一个子进程E,而在子进程D中，p2\=\=0，所以不执行p2&gt;0代码块里面的语句，直接打印pid和ppid，之后分别是进程E和B打印pid和ppid。到此满足实验要求的进程树创建完毕。</p>
</li>
</ul>
</li>
<li><p>编译执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc task3.c -o task3</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172048.jpg" width="600"></p>
</li>
<li><p>调试分析</p>
<p>由于涉及的进程数比较多，所以通过调试的方式分析比较直观，所以下面利用gdb调试器进行调试。</p>
<p>首先是调试前的准备,在gcc编译的时候加上-g 参数以支持gdb调试:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g task3.c -o task3</span><br></pre></td></tr></table></figure>
<p>通过<code>gdb task3</code>命令进入调试器，首先是配置成多进程调试模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在gdb中按照如下命令设置，可以设置成对进城调试模式</span></span><br><span class="line">set follow-fork-mode parent</span><br><span class="line">set detach-on-fork off</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172052.jpg" width="600"></p>
<p>设置断点，在含有fork函数的所有地方设置断点</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172056.jpg" width="600"></p>
<p>开始调试，首先通过<code>r</code>命令进入第一个进程开始调试，这里称此进程为A :</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172100.jpg" width="600"></p>
<p>通过调试结果可以看出来进程A的进程号是28608，进程A的父进程pid是28570，并且p1=28613大于0，说明进程A走的是<code>if (p1&gt;0)</code>下面的那个分支。</p>
<p>分析源码可知，进程A在第6行和第7行分别创建了一个子进程，我分别称之为进程B和进程C.</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172113.jpg" width="600"></p>
<p>下面切换到进程B中调试：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172117.jpg" width="600"></p>
<p>通过输出的调试信息可以看出，此时的p1的值为0，说明进程B执行的是<code>P1==0</code>下面的代码,而<code>P2&gt;0</code>说明此时进程B执行了<code>if (p2&gt;0)</code>后面的fork函数。最后得到进程B的pid为28613，进程B的父进程是进程A，其pid是28608，这与上面的进程A的pid是一直的。</p>
<p>在调试信息中可以看到，当进程B运行到13行和15行的时候分别创建了两个新的子进程，我们称这两个进程为进程D和进程E</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172121.jpg" width="600"></p>
<p>接着对进程C进程分析，进程C是进程A在26行复制得到，并且后面没有创建任何其他的子进程。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172123.jpg" width="600"></p>
</li>
</ol>
<p>​    通过调试信息可以看出，进程C的pid为28615，其父进程pid为28606,父进程为A，这与上面的信息一致。</p>
<p>​    再对进程D进程分析：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172128.jpg" width="600"></p>
<p>​    通过上面分析可知，p1和p2均为0,所以说明进程D是进程B在13行创建的子进程，进程D的spid为28740，其父进程pid为28613，和前面的信息一致。</p>
<p>​    最后分析进程E：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172131.jpg" width="600"></p>
<p>​    通过输出的信息可以看到p1=0,p2&gt;0，分析可知进程E是进程B在15行创建的子进程。进程E的pid是28741，其父进程pid是28613,恰好是进程B的pid</p>
<p>​    分析上面可知，在本次调试过程中，得到的进程信息如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pid</td>
<td style="text-align:center">28608</td>
<td style="text-align:center">28613</td>
<td style="text-align:center">28615</td>
<td style="text-align:center">28740</td>
<td style="text-align:center">28741</td>
</tr>
<tr>
<td style="text-align:center">ppid</td>
<td style="text-align:center">28570</td>
<td style="text-align:center">28608</td>
<td style="text-align:center">28608</td>
<td style="text-align:center">28613</td>
<td style="text-align:center">28613</td>
</tr>
</tbody>
</table>
</div>
<p>​    于是可以得到这五个进程的进程树如下(与实验要求一致)：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172138.jpg" width="500">        </p>
<ol>
<li><p>遇到的问题及解决办法</p>
<ul>
<li><p>问题</p>
<p>刚开始的时候由于没有考虑到父进程会在子进程之前结束的问题，导致所有的子进程在getppid()的时候父进程已经结束了，得到的是init进程的pid=1，所以在代码中加入sleep(1)，让父进程等待一秒钟再结束，等待子进程获取了其pid。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172141.jpg" width="600"></p>
</li>
<li><p>解决办法</p>
<p>在代码中中加入sleep(1),再次编译执行即可得到正确结果。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h2><ol>
<li><p>实验源码</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1a85bo9v3j316u06y3z9.jpg" width="600"></p>
<p>代码和Task3中的代码基本一致，只是将输出信息编程循环输出，并且没打印一次后sleep一秒钟</p>
</li>
<li><p>打印进程树</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172147.jpg" width="600"></p>
<p>可以看到进程树信息如上图所示</p>
</li>
<li><p>终止进程p2</p>
<ul>
<li><p>采用<code>kill -9</code>的方式终止进程p2</p>
<p>删除之p2的子进程p4和p5挂载init上面。然后进程p1,p2,p3还是原来的进程，进程p2虽然被杀死，但是变成Z+的状态，成为退出状态进程的僵尸进程。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172148.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172155.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172151.jpg" width="600"></p>
<p>查看输出信息，发现进程p2的输出已经没有了</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172158.jpg" width="600"></p>
</li>
<li><p>采用<code>exit()</code>正常退出进程</p>
<ul>
<li><p>实验源码如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1a85yjcijj313e0lmdi6.jpg" width="600"></p>
</li>
<li><p>实验步骤</p>
<p>下面是进程p2在exit之前的进程树</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172202.jpg" width="600"></p>
<p>代码中可以看到，进程p2在输出10次之后就会正常退出。下面是进程p2退出之后的进程树。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172205.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172208.jpg" width="600"></p>
<p>再查看进程p2的详细信息，得知进程p2的状态也变成了Z+，成为即将退出的僵尸进程。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172212.jpg" width="600"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>采用段错误退出</p>
<ul>
<li><p>实验代码</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1a86kbwu9j313g0patbj.jpg" width="600"></p>
<p>实验代码如上，在进程p2的进程段里面定义一个野指针，野指针没有初始化会产生段错误导致进程退出。</p>
</li>
<li><p>实验步骤</p>
<p>下面是进程p2在退出之前的的进程树</p>
</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172216.jpg" width="600"></p>
<p>​    下面在p2进程退出之后的进程出，进程p2的子进程p4,p5挂载在init上，然后p2进程变成了状态为Z+ 的僵尸进程。</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172220.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172223.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-172226.jpg" width="600"></p>
<p>综上所述，三种方式的终止进程都会将进程变成僵尸进程，进程在退出的过程中，系统回收资源，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。这也是为什么进程p2终止之后在进程树中还能看到进程p2的信息等。</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/gitbook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/01/gitbook/" class="post-title-link" itemprop="url">在github部署gitbook教程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-03-01 20:10:33" itemprop="dateCreated datePublished" datetime="2019-03-01T20:10:33+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-12 17:35:27" itemprop="dateModified" datetime="2019-09-12T17:35:27+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>229</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gitbook使用"><a href="#gitbook使用" class="headerlink" title="gitbook使用"></a>gitbook使用</h1><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><blockquote>
<p>在本地利用 yu writer进行编辑之后使用git上传到github<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;修改的文件名&gt;</span><br><span class="line">git commit -m <span class="string">"修改的简述"</span></span><br><span class="line">git push -u github master</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://pdt3s257u.bkt.clouddn.com/Snip20180822_8.png" alt></p>
<h2 id="服务器从github同步数据"><a href="#服务器从github同步数据" class="headerlink" title="服务器从github同步数据"></a>服务器从github同步数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull github master</span><br></pre></td></tr></table></figure>
<p><img src="http://pdt3s257u.bkt.clouddn.com/Snip20180822_9.png" alt></p>
<h2 id="重启gitbook服务"><a href="#重启gitbook服务" class="headerlink" title="重启gitbook服务"></a>重启gitbook服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:4000</span><br><span class="line"><span class="comment"># 找到pid之后杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid</span><br><span class="line">setsid gitbook serve .</span><br></pre></td></tr></table></figure>
<p><img src="http://pdt3s257u.bkt.clouddn.com/20180822/Snip20180822_10.png" alt></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/01/lab5/" class="post-title-link" itemprop="url">文件系统实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-03-01 20:10:33" itemprop="dateCreated datePublished" datetime="2019-03-01T20:10:33+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-12 17:34:38" itemprop="dateModified" datetime="2019-09-12T17:34:38+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统实验/" itemprop="url" rel="index"><span itemprop="name">操作系统实验</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>21k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>19 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验五-文件系统-实验报告"><a href="#实验五-文件系统-实验报告" class="headerlink" title="实验五-文件系统 实验报告"></a><center>实验五-文件系统 实验报告</center></h1><blockquote>
<center>孙汉武    16281047    安全1601</center>

</blockquote>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab5" target="_blank" rel="noopener">实验源码链接:https://github.com/sunhanwu/16281047_OperatingSystemExperiment/tree/master/lab5</a></p>
<p><a href="https://github.com/sunhanwu/16281047_OperatingSystemExperiment/raw/master/lab5/lab5.pdf" target="_blank" rel="noopener">pdf下载</a></p>
<h2 id="一-概要设计"><a href="#一-概要设计" class="headerlink" title="一 概要设计"></a>一 概要设计</h2><p>$\qquad$本次的实验的实验目的是在模拟的I/O系统中开发一个简单的文件系统，并且提供一些借口给用户用于交互，从实验目的可以看出，本实验重点在于构建模拟的I/O系统和基于I/O系统的文件系统。所以，在概要设计中，将详细介绍模拟I/O系统的设计、文件系统的设计和测试模块的设计这三个部分。</p>
<h3 id="1-1-I-O系统设计"><a href="#1-1-I-O系统设计" class="headerlink" title="1.1 I/O系统设计"></a>1.1 I/O系统设计</h3><p> $\qquad$IO系设计首先要解决的是需要有一个物理磁盘，为此，我们通过定义一个三维的磁盘块结构体数组表示物理磁盘，该结构体数组的每一个维度分别表示物理磁盘中的一个层次。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-082923.jpg" width="400"></div>

<p>$\qquad$我们模拟的磁盘如上所示，第一维表柱面，第二维表示磁头，最后一维表示扇区。磁盘定义好之后需要定义一系列的函数用于操作磁盘。IO系统工作的流程和结构如下所示：</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-090054.jpg" width="400"></div>

<p>$\qquad$IO系统提供的操作磁盘的API如上图所示，主要分为五个大类，分别是初始化磁盘、磁盘搜索、磁盘读写、磁盘位图处理、磁盘与文件转化等，下面的表格分别介绍了各个类别提供的API的详细信息。</p>
<ul>
<li>磁盘初始化</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InitDisk()</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">初始化磁盘数组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>磁盘搜索 </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SearchBitMap</td>
<td style="text-align:center">无</td>
<td style="text-align:center">空闲磁盘块号</td>
<td style="text-align:center">搜索并返回最小的空闲磁盘块号</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>磁盘读写</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ReadBlock</td>
<td style="text-align:center">int i :指定读取的磁盘块号<br>char *p ：返回读取内容</td>
<td style="text-align:center">无</td>
<td style="text-align:center">读取指定磁盘块内容</td>
</tr>
<tr>
<td style="text-align:center">WriteBlock</td>
<td style="text-align:center">int i：指定写入的磁盘块号<br>char *p:写入的内容</td>
<td style="text-align:center">无</td>
<td style="text-align:center">写入内容到指定磁盘块</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>磁盘位图处理</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InitBitMap</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">初始化位图</td>
</tr>
<tr>
<td style="text-align:center">ChangeBitMap</td>
<td style="text-align:center">int i:要修改的磁盘块号<br>char p:修改的内容(Y/N)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">修改位图每一位的值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>磁盘与文件的转化</li>
</ul>
<p>$\qquad$由于是在内从中创建数组模拟物理磁盘，所以这种方式无法模拟物理磁盘断电不丢失信息的特性。为了满足这个要求，设计一下的函数用于将数组中的信息存储到文件中和文件中读取相关信息。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DiskToFile</td>
<td style="text-align:center">char filename[]：文件名</td>
<td style="text-align:center">无</td>
<td style="text-align:center">将磁盘数组信息存储为文件</td>
</tr>
<tr>
<td style="text-align:center">FileToDsik</td>
<td style="text-align:center">char filename[]:文件名</td>
<td style="text-align:center">无</td>
<td style="text-align:center">将文件读取到磁盘数组中</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-2-文件系统设计"><a href="#1-2-文件系统设计" class="headerlink" title="1.2 文件系统设计"></a>1.2 文件系统设计</h3><p>$\qquad$在上一节设计的IO系统的基础上，进行文件系统的设计，文件系统设计时有两个很重要的概念，分别是文件描述符和目录项这两个数据结构的定以及在这个基础上进行的一系列操作。</p>
<ol>
<li>用户接口</li>
</ol>
<p>$\qquad$文件系统提供了一系列便于用户操作的接口，用于对文件系统中的文件进行增删改查，具体接口信息如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">create</td>
<td style="text-align:center">char filename[]</td>
<td style="text-align:center">无</td>
<td style="text-align:center">创建文件</td>
</tr>
<tr>
<td style="text-align:center">destroy</td>
<td style="text-align:center">char filename[]</td>
<td style="text-align:center">无</td>
<td style="text-align:center">删除文件</td>
</tr>
<tr>
<td style="text-align:center">open</td>
<td style="text-align:center">char  filename[]</td>
<td style="text-align:center">无</td>
<td style="text-align:center">打开文件</td>
</tr>
<tr>
<td style="text-align:center">close</td>
<td style="text-align:center">char filename[]</td>
<td style="text-align:center">无</td>
<td style="text-align:center">关闭文件</td>
</tr>
<tr>
<td style="text-align:center">read</td>
<td style="text-align:center">index:文件描述符号<br>mem_area:读取的位置<br>count:读取的字节数</td>
<td style="text-align:center">无</td>
<td style="text-align:center">读取文件内容</td>
</tr>
<tr>
<td style="text-align:center">write</td>
<td style="text-align:center">index:文件描述符<br>mem_area:x写入的位置<br>count:写入字节数</td>
<td style="text-align:center">无</td>
<td style="text-align:center">向文件中写入信息</td>
</tr>
<tr>
<td style="text-align:center">lseek</td>
<td style="text-align:center">index:文件描述符 号<br>pos:位置</td>
<td style="text-align:center">无</td>
<td style="text-align:center">移动文件读写指针</td>
</tr>
</tbody>
</table>
</div>
<p>$\qquad$文件系统提供的上述接口已经可以满足对文件系统的常规操作。上面的接口中提到的文件描述符在文件系统中是一个很重要的概念，每个文件都必须 通过一个文件描述符来表示 ，其文件长度信息 ，文件存储位置等常规 信息都存储在文件描述符中。</p>
<p>$\qquad$为此我设计了一个结构体<code>FileDescriptor</code>用于表示文件描述符，并且将该结构体进行4字节对齐，方便后续以二进制形式存储在文件中。</p>
<p>$\qquad$在文件系统中另外一个重要概念就是目录，因此定义一个结构体表示目录项，用于存储文件名和文件描述符号。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-100056.jpg" width="400"></div>

<p>$\qquad$文件描述符和目录项在磁盘中存储的位置如上图所示，其中磁盘块的第一和第二块用于存储磁盘块的位图，第3-13块用于存储文描述符，14块用于存储目录项信息。</p>
<p>$\qquad$经过4字节对齐之后的文件描述符结构体大小为24字节，而一个磁盘块有512字节存储空间，所以一个磁盘块最多存储21个文件描述符，而本实验中设置的用于存储文件描述符的磁盘块为10块，最多可以存储210个文件描述符。</p>
<p>$\qquad$目录也可以看做一个文件，所以也会占据一个文件文件描述符，本实验中目录占用的文件描述符是第一个文件描述符。并且存储目录信息的磁盘是14号磁盘，经过4字节对齐的目录项结构体大小为16B，所以最多有32个文件。</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-102802.jpg" width="400"></div>

<p>$\qquad$文件系统的API如上图所示，我将文件系统的API分为初始化、用户接口、搜索和其他这四类，每一个大类具体的函数如下表所示：</p>
<ul>
<li>文件系统初始化</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InitFileDescriptor</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">初始化文件描述符数组</td>
</tr>
<tr>
<td style="text-align:center">InitMenu</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">初始化目录项数组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>文件系统用户接口(上面已经介绍过，不在赘述)</li>
<li>文件系统搜索</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SearchFileDescriptor</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">搜索空闲的文件描述符</td>
</tr>
<tr>
<td style="text-align:center">SearchMenuItem</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">搜索空闲的目录项</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>其他</li>
</ul>
<p>$\qquad$这部分主要定义的是一些方便操作的函数，例如将文件描述符数组写入磁盘块中去，将目录系统写入磁盘块等等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回值</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DiskToFileDescriptor</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">从磁盘块中恢复文件描述符数组</td>
</tr>
<tr>
<td style="text-align:center">FileDescriptorToDisk</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">将文件描述符数组信息写入磁盘块</td>
</tr>
<tr>
<td style="text-align:center">MenuToFileDescriptor</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">将目录项数组写入第一个文件描述符</td>
</tr>
<tr>
<td style="text-align:center">FileDescriptorToMenu</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">将第一个文件描述符内容恢复到目录项数组</td>
</tr>
</tbody>
</table>
</div>
<p>$\qquad$到此，文件系统部分所有数据结构和函数均介绍完毕</p>
<h3 id="1-3-菜单系统设计"><a href="#1-3-菜单系统设计" class="headerlink" title="1.3 菜单系统设计"></a>1.3 菜单系统设计</h3><p>$\qquad$完成IO系统的设计和文件系统的设计，需要对上述的功能设计一个外壳程序，即一个用户界面便于使用，总结文件系统的所有功能，设计的菜单驱动程序包含如下两层菜单。</p>
<ol>
<li>一级菜单<ul>
<li>创建新磁盘系统</li>
<li>从文件中恢复历史磁盘系统</li>
</ul>
</li>
<li>二级菜单<ul>
<li>查看目录</li>
<li>创建文件</li>
<li>删除文件</li>
<li>打开文件</li>
<li>修改文件</li>
<li>查看位图</li>
<li>保存磁盘</li>
<li>退出</li>
</ul>
</li>
</ol>
<h2 id="二-I-O系统"><a href="#二-I-O系统" class="headerlink" title="二 I/O系统"></a>二 I/O系统</h2><h3 id="2-1-磁盘块结构体"><a href="#2-1-磁盘块结构体" class="headerlink" title="2.1 磁盘块结构体"></a>2.1 磁盘块结构体</h3><blockquote>
<p>I/O系统部分全部代码都在IO.h文件中</p>
</blockquote>
<ol>
<li>磁盘块结构体BLOCK</li>
</ol>
<p>$\qquad$设计整个I/O系统的基础就是设计模拟磁盘块的结构体，并用结构体数组代表磁盘，通过定义三维的结构体数组来模拟出整个磁盘的物理结构，这三维分别代表柱面、磁头和扇区。下面是磁盘块(逻辑块)结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Content[<span class="number">512</span>]; <span class="comment">//逻辑块存储的内容</span></span><br><span class="line">    <span class="keyword">int</span> BlockNnum; <span class="comment">//逻辑块号</span></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// 柱面号</span></span><br><span class="line">    <span class="keyword">int</span> h; <span class="comment">//磁头号</span></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//扇区号</span></span><br><span class="line">&#125;BLOCK;</span><br></pre></td></tr></table></figure>
<p>$\qquad$磁盘块结构体最重要的成员就是用于存储信息Content，这是一个字符型数组，大小为512个字节。而另外的逻辑块号，柱面号，磁头号和扇区号这四个成员是为了便于后续程序设计的。下面的表格详细表示每个成员的信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Content</td>
<td style="text-align:center">字符数组</td>
<td style="text-align:center">512字节</td>
<td style="text-align:center">存储磁盘块内容</td>
</tr>
<tr>
<td style="text-align:center">BlockNum</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">磁盘块的逻辑块号</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">柱面号</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">磁头号</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">扇区号</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>物理磁盘(BLOCK数组)</li>
</ol>
<p>$\qquad$磁盘块结构体定义好之后，可以模拟出一个磁盘块，但是完整的磁盘是一个三维的磁盘块结构体数组构成的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 10 <span class="comment">// 柱面号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H 10 <span class="comment">//磁头号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 10 <span class="comment">//扇区号</span></span></span><br><span class="line">BLOCK ldisk[C][H][B];<span class="comment">//磁盘模型</span></span><br></pre></td></tr></table></figure>
<p>$\qquad$在<code>IO.h</code>直接定义ldisk数组，模拟物理磁盘。并且通过宏定义C、H和B三个量调整物理磁盘的大小。</p>
<ol>
<li>磁盘初始化函数</li>
</ol>
<p>$\qquad$在模拟物理磁盘的三维结构体数组定义好之后，需要对该数组进行初始化，对数组中的每个元素，即每个磁盘块进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitDisk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ldisk[i][j][k].c=i;</span><br><span class="line">                ldisk[i][j][k].h=j;</span><br><span class="line">                ldisk[i][j][k].b=k;</span><br><span class="line">                ldisk[i][j][k].BlockNnum=DiskNumToBlock(i,j,k);<span class="comment">//计算对应的逻辑块号</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$可以看到对磁盘块数组进行初始化的方式非常简单，主要包含两个工作，一个就是顺序编号其柱面号、磁头号和扇区号；还有一个功能就是计算逻辑块号</p>
<h3 id="2-2-磁盘读写"><a href="#2-2-磁盘读写" class="headerlink" title="2.2 磁盘读写"></a>2.2 磁盘读写</h3><p>$\qquad$说道磁盘系统的API函数，最重要的两个函数就是对磁盘块进行读写操作的两个函数。下面分别介绍这个两个函数的详细内容。</p>
<ol>
<li>读磁盘块函数：<code>ReadBlock(int i,char *p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadBlock</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,h,b;<span class="comment">//磁盘的柱面 磁道 扇区</span></span><br><span class="line">    c = i % (H*B);<span class="comment">//</span></span><br><span class="line">    h = (i -c*H*B) % B;<span class="comment">//</span></span><br><span class="line">    b = i-c*H*B - h*B;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,ldisk[c][h][b].Content,<span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$3-6行计算逻辑号为i的逻辑块在磁盘系统中的柱面号、磁头号和扇区号；</p>
<p>$\qquad$第7行可以看作此函数的核心操作，完成的工作就是将制定磁盘块中的内容通过<code>memcpy</code>函数复制到字符型指针p中去。</p>
<blockquote>
<p>注意：这里不能使用strcpy函数复制字符串，因为strcpy函数在复制的时候会遇到第一个\0就会停止复制，但是磁盘块中存储的信息可能不是连续的字符串，可能是一些其他信息，例如文件描述符等，这个时候就会碰到一些空位置用\0补充，但是后面还有有用的信息，所以使用memcp函数，按照指定字节数复制，而不考虑\0的问题</p>
</blockquote>
<ol>
<li>写磁盘块函数：<code>WriteBlock(int i,char *p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,h,b;</span><br><span class="line">    b = i % B;</span><br><span class="line">    h = ((i - b) / B) % H;</span><br><span class="line">    c = (i -b -h*B) / (H*B);</span><br><span class="line">    b = i -c*H*B -h*B ;</span><br><span class="line">    <span class="built_in">memcpy</span>(ldisk[c][h][b].Content,p,<span class="number">512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$3-6行操作与上面相似，就是计算柱面号、磁头号和扇区号这三个参数</p>
<p>$\qquad$8第8行主要用于将参数p指针中的内容复制到磁盘块中</p>
<h3 id="2-3-磁盘位图"><a href="#2-3-磁盘位图" class="headerlink" title="2.3 磁盘位图"></a>2.3 磁盘位图</h3><p>$\qquad$为了方便查询磁盘中的空闲磁盘块，直接遍历查询的效率非常低，所以本实验中采用了位图的方式来表示磁盘块的占用与否，一个字符表示一个磁盘块的占用与否，其中Y表示占用，N表示空闲。而位图编号就是磁盘块的逻辑块号数。</p>
<ol>
<li>初始化磁盘位图函数：<code>InitBitMap(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第0，1号磁盘已经被占用</span></span><br><span class="line">    ChangeBitMap(<span class="number">0</span>,<span class="string">'Y'</span>);</span><br><span class="line">    ChangeBitMap(<span class="number">1</span>,<span class="string">'Y'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;C*H*B;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ChangeBitMap(i,<span class="string">'N'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$可以看到初始化函数中将磁盘块数量(C*B*H)个单位的字符修改为N，表示为占用。4-5两行表示第一块和第二块物理磁盘初始化就被占用，因为这两块物理磁盘用于存储位图。</p>
<ol>
<li>修改位图函数：<code>ChangeBitMap(int i,char p):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeBitMap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">512</span>)</span><br><span class="line">        ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[i] = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[i<span class="number">-512</span>] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$这个函数使用一个if结构判断逻辑块号，如果大于512的话存入 第二个磁盘块中，否则存入第一个磁盘块中。</p>
<h3 id="2-4-磁盘文件的存取"><a href="#2-4-磁盘文件的存取" class="headerlink" title="2.4 磁盘文件的存取"></a>2.4 磁盘文件的存取</h3><p>$\qquad$在内存中定义的磁盘块结构体数组无法满足断电后信息还能保存的特性，因此需要内存中的磁盘块数组中的信息保存到文件中去，需要的时候再加载出来。</p>
<ol>
<li>将磁盘数组保存为文件：<code>DiskToFile(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskToFile</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    FileDescriptorToDisk();</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(filename,<span class="string">"wb"</span>);</span><br><span class="line">    <span class="comment">//判断fp打开成功</span></span><br><span class="line">    <span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File Open Fail"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历，将磁盘块内容写入二进制文件中去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">                <span class="comment">//以二进制的形式写入二进制文件中</span></span><br><span class="line">                fwrite(ldisk[i][j][k].Content,<span class="number">512</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$3-5行以二进制写入形式打开指定文件名的文件</p>
<p>$\qquad$7-11行判断文件是否打开成功，没打开成功的话输出错误信息并退出程序</p>
<p>$\qquad$13-17行，遍历磁盘数组，以二进制的形式将磁盘块中存储的内容写入到文件中去。最后关闭文件</p>
<ol>
<li>加载文件到磁盘块数组：<code>FileToDisk(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件中读取数据，恢复磁盘系统</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileToDisk</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line">     fp = fopen(filename,<span class="string">"rb"</span>);</span><br><span class="line">     <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"File Open Fail"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">int</span> c,h,b;</span><br><span class="line">         b = index % B;</span><br><span class="line">         h = ((index - b) / B) % H;</span><br><span class="line">         c = (index -b -h*B) / (H*B);</span><br><span class="line">         b = index -c*H*B -h*B ;</span><br><span class="line">         fread(ldisk[c][h][b].Content,<span class="number">512</span>,<span class="number">1</span>,fp);</span><br><span class="line">         ldisk[c][h][b].c = c;</span><br><span class="line">         ldisk[c][h][b].h = h;</span><br><span class="line">         ldisk[c][h][b].b = b;</span><br><span class="line">         index++;</span><br><span class="line">     &#125;</span><br><span class="line">     fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$这段程序除了打开文件等常规操作之外，核心的代码是while循环中的，首先计算逻辑号为index的逻辑块的柱面号、磁头号和扇区号；之后每次读取512字节数据到对应磁盘块数组中的磁盘块中去。</p>
<h3 id="2-5-空闲磁盘块搜索"><a href="#2-5-空闲磁盘块搜索" class="headerlink" title="2.5 空闲磁盘块搜索"></a>2.5 空闲磁盘块搜索</h3><p>$\qquad$2.3节中定义了位图，用于存储磁块的空闲状态，所以当需要使用磁盘块的时候 ，需要查询位图找到一个空闲磁盘块号返回。</p>
<ol>
<li>空闲磁盘块搜索函数：`SearchBitMap(void)：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索位图，找到空闲磁盘块号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>;i&lt;C*H*B;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">512</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[i]==<span class="string">'N'</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[i<span class="number">-512</span>]==<span class="string">'N'</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> $\qquad$本函数的实现方式就是通过遍位图知道找到一个空闲的磁盘块。不过由于所有的位图 信息并不是全部存储在一个磁盘块中，而是两个磁盘块，所以在遍历的时候需要判断在哪个磁盘块。</p>
<h2 id="三-文件系统"><a href="#三-文件系统" class="headerlink" title="三 文件系统"></a>三 文件系统</h2><blockquote>
<p>文件系统全部代码存储在FS.h文件中</p>
</blockquote>
<h3 id="3-1-文件描述符结构体-amp-目录项结构体"><a href="#3-1-文件描述符结构体-amp-目录项结构体" class="headerlink" title="3.1 文件描述符结构体 &amp; 目录项结构体"></a>3.1 文件描述符结构体 &amp; 目录项结构体</h3><ol>
<li><p>文件描述符结构体定义</p>
<p>$\qquad$文件系统采用文件描述符来记录每一个文件的信息，下面是文件描述符的结构体定义：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileDescriptor</span> //此文件描述符总共占据磁盘24字节</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Length;<span class="comment">//文件长度</span></span><br><span class="line">    <span class="keyword">int</span> DiskNum[DiskNumLen]; <span class="comment">//第二个3只是表示每个磁盘块好最大长度是3位</span></span><br><span class="line">    <span class="keyword">int</span> Num; <span class="comment">//文件描述符号</span></span><br><span class="line">    <span class="keyword">char</span> IsFree; <span class="comment">//表示此文件描述符是否空闲</span></span><br><span class="line">&#125;FileDescriptor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个结构体定义有一个特别的地方需要注意，就是使用了4字节对齐机制，因为后来这些结构体需要存储到字符型数组中，如果不采用对齐的话可能会导致不同结构体的长度不同，读取的时候就没办法读取.</p>
</blockquote>
<p>$\qquad$下面是该结构体各个成员的详细解释：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Length</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">存储文件大小</td>
</tr>
<tr>
<td style="text-align:center">DiskNum</td>
<td style="text-align:center">整型数组</td>
<td style="text-align:center">12字节</td>
<td style="text-align:center">存储文件内容的磁盘块好数组</td>
</tr>
<tr>
<td style="text-align:center">Num</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">文件描述符号</td>
</tr>
<tr>
<td style="text-align:center">IsFree</td>
<td style="text-align:center">字符型</td>
<td style="text-align:center">4字节(对齐后)</td>
<td style="text-align:center">表示当前描述符时候空闲</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>目录项结构体定义</li>
</ol>
<p>$\qquad$目录是文件系统必不可缺的组成部分，本实验中通过目录项数组组成一个目录，而每个目录项由文件名和文件描述符号组成。下面是目录项结构体定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MenuItem</span> //目录对应0号文件描述符,一个目录项占据16字节，所以一个文件描述符可以存储96个文件</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> FileName[<span class="number">12</span>]; <span class="comment">//目录项中文件名的最大长度为16字节</span></span><br><span class="line">    <span class="keyword">int</span> FileDescriptorNum;<span class="comment">//文件描述符号</span></span><br><span class="line">&#125;MenuItem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样目录项结构体也是经过4字节对齐的，作用与上面的文件描述符结构体相似</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileName</td>
<td style="text-align:center">字符型数组</td>
<td style="text-align:center">12字节</td>
<td style="text-align:center">存储文件名</td>
</tr>
<tr>
<td style="text-align:center">FileDescriptorNum</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">文件描述符号</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-2-文件系统初始化"><a href="#3-2-文件系统初始化" class="headerlink" title="3.2 文件系统初始化"></a>3.2 文件系统初始化</h3><p>$\qquad$文件系统的初始化包括对文件描述符数组的初始化和目录项数组的初始化，和IO系统中的磁盘数组初始化一样，文件系统的初始化也就是对这两个数组进行一些编号操作等基本操作。</p>
<ol>
<li>文件描述符初始化：<code>InitFileDescriptor(void):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span>  DiskNum[<span class="number">3</span>]; <span class="comment">//磁盘号数组</span></span><br><span class="line">      DiskNum[<span class="number">0</span>] = i;</span><br><span class="line">      DiskNum[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">      DiskNum[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> FileDescriptorNum = i; <span class="comment">//文件描述符号</span></span><br><span class="line">      ChangeFileDescriptor(&amp;filedescriptor[i],<span class="number">0</span>,DiskNum,FileDescriptorNum,<span class="string">'Y'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    FileDescriptorToDisk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$首先遍历整个文件描述符数组，进行编号并且初始化的时候文件描述符对应的三个磁盘块只分配一个。</p>
<ol>
<li>目录项初始化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMenu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        menuitem[i].FileDescriptorNum = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-文件系统用户接口"><a href="#3-3-文件系统用户接口" class="headerlink" title="3.3 文件系统用户接口"></a>3.3 文件系统用户接口</h3><ol>
<li>创建文件：<code>create(char filename[]):</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是文件系统与用户直接的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> FileDescriptorNum,MenuItemNum,DiskNum;</span><br><span class="line">    <span class="comment">//寻找空闲目录项</span></span><br><span class="line">    MenuItemNum = SearchMenuItem();</span><br><span class="line">    <span class="built_in">strcpy</span>(menuitem[MenuItemNum].FileName,filename);</span><br><span class="line">    <span class="comment">//寻找空闲文件描述符</span></span><br><span class="line">    FileDescriptorNum = SearchFileDescriptor();</span><br><span class="line">    menuitem[MenuItemNum].FileDescriptorNum = FileDescriptorNum;</span><br><span class="line">    <span class="comment">//寻找空闲磁盘块</span></span><br><span class="line">    DiskNum = SearchBitMap();</span><br><span class="line">    filedescriptor[FileDescriptorNum].DiskNum[<span class="number">0</span>] = DiskNum;</span><br><span class="line">    filedescriptor[FileDescriptorNum].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    <span class="comment">//修改磁盘位图</span></span><br><span class="line">    ChangeBitMap(DiskNum,<span class="string">'Y'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$创建一个新的文件的时候，首先需要搜索一个空闲的目录项，将文件名存储在目录项中，然后在搜索一个空闲的描述符，分配该文件描述符给他文件，在搜索 一个空闲的磁盘块，将该磁盘块存储在文件描述符中。最后修改文件描述符状态和位图对应磁盘块的状态为占用。</p>
<ol>
<li>删除文件：<code>destroy(char filename[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MenuItemNum=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(menuitem[i].FileName,filename)==<span class="number">0</span>)</span><br><span class="line">            MenuItemNum = i;</span><br><span class="line">    <span class="keyword">if</span>(MenuItemNum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"目录中没有此文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> FileDesCriptorNum = menuitem[MenuItemNum].FileDescriptorNum;</span><br><span class="line">    <span class="comment">//将目录项重置,重置时只需要将文件名删除，而不需要重置文件描述符，因为前面判断文件是否存在的条件是文件名是否存在</span></span><br><span class="line">    <span class="built_in">memset</span>(menuitem[MenuItemNum].FileName,<span class="number">0</span>, <span class="keyword">sizeof</span>(menuitem[MenuItemNum].FileName));</span><br><span class="line">    <span class="comment">//修改文件描述符为空闲状态</span></span><br><span class="line">    filedescriptor[FileDesCriptorNum].IsFree = <span class="string">'Y'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(filedescriptor[FileDesCriptorNum].DiskNum[i]!=<span class="number">-1</span>)</span><br><span class="line">        ChangeBitMap(filedescriptor[FileDesCriptorNum].DiskNum[i],<span class="string">'N'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$根据文件名在目录项数组中搜索对应的目录项，删除文件名，再找到目录项后读取该文件对应的文件描述符号，修改文件描述符状态为空闲；再讲文件描述符中记录的所有磁盘块状态全部改为空闲。</p>
<ol>
<li>打开文件：<code>open(char filename[])</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">char</span> filename[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MenuItemNum=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(menuitem[i].FileName,filename)==<span class="number">0</span>)</span><br><span class="line">            MenuItemNum = i;</span><br><span class="line">    <span class="keyword">if</span>(MenuItemNum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"目录中没有此文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//返回文件描述符号</span></span><br><span class="line">        <span class="keyword">return</span> menuitem[MenuItemNum].FileDescriptorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$这个函数通过遍历目录项数组，找到文件名符合的目录项，读取其文件描述符号返回，没有找到的话打印错误信息并返回-1</p>
<ol>
<li>读取文件：<code>read(int index,int mem_area,int count)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">read</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> mem_area,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *temp;</span><br><span class="line">   <span class="keyword">char</span> block[<span class="number">512</span>];</span><br><span class="line">   temp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(count* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">   ReadBlock(filedescriptor[index].DiskNum[<span class="number">0</span>],block);</span><br><span class="line">   <span class="built_in">memcpy</span>(temp,&amp;block[mem_area],count);</span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$读取文件内容函数首先找到文件描述符中的磁盘号，然后调用IO系统提供的读取磁盘块的接口读取该磁盘块，读取后按照要求取对应位置指定长度的数据返回。</p>
<ol>
<li>写文件：<code>write(int index,int mem_area,int count,char content[])：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> mem_area,<span class="keyword">int</span> count,<span class="keyword">char</span> content[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span> *s1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(mem_area* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">char</span> *s2=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(mem_area* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">int</span> DiskNum = filedescriptor[index].DiskNum[<span class="number">0</span>];</span><br><span class="line">    ReadBlock(DiskNum,temp);</span><br><span class="line">    <span class="built_in">memcpy</span>(s1,temp,mem_area);</span><br><span class="line">    <span class="built_in">memcpy</span>(s2,&amp;temp[mem_area],<span class="number">512</span>-mem_area);</span><br><span class="line">    s = <span class="built_in">strcat</span>(s1,content);</span><br><span class="line">    s = <span class="built_in">strcat</span>(s,s2);</span><br><span class="line">    filedescriptor[index].Length = <span class="built_in">strlen</span>(s);</span><br><span class="line">    WriteBlock(DiskNum,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$写文件的时候需要考虑可能是在原来文件的基础上，在某段插入一些内容，所以用s1字符指针保存mem_area之前的信息，s2保存mem_area之后的信息，加入要加入的内容后在连接成为一个完整的字符数组，最后调用IO系统提供的写入磁盘块接口写入 对应磁盘块。</p>
<h3 id="3-4-搜索文件系统"><a href="#3-4-搜索文件系统" class="headerlink" title="3.4 搜索文件系统"></a>3.4 搜索文件系统</h3><p>$\qquad$上面文件系统的用户接口中 很多地方用到了搜索文件描述符、搜索目录项等操作，所以需要单独写几个函数用于搜索文件描述符和目录项等结构。</p>
<ol>
<li>搜索空闲文件描述符:<code>SearchFileDescriptor():</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchFileDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(filedescriptor[i].IsFree == <span class="string">'Y'</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$遍历文件描述符数组，找到空闲的文件描述符号返回</p>
<ol>
<li>搜索空闲目录项：<code>SearchMenuItem()：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchMenuItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(menuitem[i].FileName)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$遍历所有的目录项数组，知道找到空闲的目录项返回目录项号</p>
<h3 id="3-5-其它文件系统函数"><a href="#3-5-其它文件系统函数" class="headerlink" title="3.5 其它文件系统函数"></a>3.5 其它文件系统函数</h3><p>$\qquad$除了上面介绍的文件操作之外，还需一些函数，例如将文件描述符写入到磁盘中去，将目录项数组写入到第一个文件描述符对应的磁盘中；从磁盘中恢复文件描述符数组，恢复目录项数组。</p>
<ol>
<li>将文件描述符数组写入磁盘：<code>FileDescriptorToDisk(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件描述符写入磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileDescriptorToDisk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp_block[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> DiskNumIndex = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_descriptor[<span class="number">24</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_descriptor,&amp;filedescriptor[i], <span class="keyword">sizeof</span>(FileDescriptor));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;temp_block[index*<span class="number">24</span>],temp_descriptor,<span class="number">24</span>);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">int</span> t = index % <span class="number">21</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(DiskNumIndex&lt;<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][DiskNumIndex].Content,temp_block,<span class="number">512</span>);</span><br><span class="line">                ChangeBitMap(DiskNumIndex,<span class="string">'Y'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(ldisk[<span class="number">0</span>][<span class="number">1</span>][DiskNumIndex-B].Content,temp_block,<span class="number">512</span>);</span><br><span class="line">                ChangeBitMap(DiskNumIndex,<span class="string">'Y'</span>);<span class="comment">//修改位图</span></span><br><span class="line">            &#125;</span><br><span class="line">            DiskNumIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$遍历整个文件描述符数组，每个文件描述符占据24字节信息，21个文件描述符一组，一共504字节，将每组504字节信息存入到一个磁盘块中，存入后修改磁盘的状态为占用。</p>
<ol>
<li>从磁盘恢复文件描述符数组：<code>DiskToFileDescriptor(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将磁盘读取的信息恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskToFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">if</span> (i&lt;B)</span><br><span class="line">            <span class="built_in">memcpy</span>(temp,ldisk[<span class="number">0</span>][<span class="number">0</span>][i].Content,<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memcpy</span>(temp,ldisk[<span class="number">0</span>][<span class="number">1</span>][i-B].Content,<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">21</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(((i<span class="number">-2</span>)*<span class="number">21</span>+j)&gt;<span class="number">256</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">char</span> temp_FileDescriptor[<span class="number">24</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(temp_FileDescriptor,&amp;temp[j*<span class="number">24</span>],<span class="number">24</span>);</span><br><span class="line">            FileDescriptor *f;</span><br><span class="line">            f = (FileDescriptor*)temp_FileDescriptor;</span><br><span class="line">            <span class="keyword">int</span> num = (i<span class="number">-2</span>)*<span class="number">21</span>+j;</span><br><span class="line">            filedescriptor[num].IsFree = f-&gt;IsFree;</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">0</span>] = f-&gt;DiskNum[<span class="number">0</span>];</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">1</span>] = f-&gt;DiskNum[<span class="number">1</span>];</span><br><span class="line">            filedescriptor[num].DiskNum[<span class="number">2</span>] = f-&gt;DiskNum[<span class="number">2</span>];</span><br><span class="line">            filedescriptor[num].Length = f-&gt;Length;</span><br><span class="line">            filedescriptor[num].Num = f-&gt;Num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$由于每个磁盘块的空间只能存储21个文件描述符，所以每隔21就需要将index归零一次，用于从新读取一个新的磁盘的文件描述符信息，每次读取的是一整个磁盘的信息，长度是512字节，而每个文件描述符的大小为24，所以首先全部服务磁盘块信息到<code>temp_block</code>，然后每次读取24字节信息到<code>temp_descriptor</code>,之后通过强制类型转换，将字符换数组转化为文件描述符结构体指针，这样就将磁盘块中的信息读入。</p>
<ol>
<li>将目录项数组写入文件描述符：<code>MenuToFileDescriptor(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将目录内容写入文件描述中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MenuToFileDescriptor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp_FileDescriptor[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_menuitem[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_menuitem,&amp;menuitem[i],<span class="number">16</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;temp_FileDescriptor[i*<span class="number">16</span>],temp_menuitem,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].IsFree = <span class="string">'N'</span>;</span><br><span class="line">    filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>] = SearchBitMap();</span><br><span class="line">    filedescriptor[<span class="number">0</span>].Length = <span class="number">512</span>;</span><br><span class="line">    WriteBlock(filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>],temp_FileDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$将所有的目录项合并为一个512字节的字符数组(注意使用的是memcpy而不是strcpy)然后将第一个文件描述符的状态修改位占用，并将字符数组写入第一个文件描述符对应的磁盘块。</p>
<ol>
<li>从第一个文件描述符恢复目录项数组：<code>FileDescriptorToMenu(void)：</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileDescriptorToMenu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> MenuContent[<span class="number">512</span>];</span><br><span class="line">    ReadBlock(filedescriptor[<span class="number">0</span>].DiskNum[<span class="number">0</span>],MenuContent);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp_menuitem[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_menuitem,&amp;MenuContent[i*<span class="number">16</span>],<span class="number">16</span>);</span><br><span class="line">        MenuItem *t;</span><br><span class="line">        t = (MenuItem *)temp_menuitem;</span><br><span class="line">        <span class="built_in">strcpy</span>(menuitem[i].FileName,t-&gt;FileName);</span><br><span class="line">        menuitem[i].FileDescriptorNum = t-&gt;FileDescriptorNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$首先读取第一个文件描述符对应的磁盘块信息到<code>MenuContent</code>字符数中去，然后每次读取16字节信息，将读取的16字节信息强制转换为目录项指针。这样磁盘上存储的所欲目录项信息就会被全部读取。</p>
<h2 id="四-菜单系统"><a href="#四-菜单系统" class="headerlink" title="四 菜单系统"></a>四 菜单系统</h2><blockquote>
<p>菜单系统代码在main.cpp文件中</p>
</blockquote>
<p>$\qquad$IO系统和文件系统准备好之后就可以更具需要的功能设计出具体的功能，并对应写出一个菜单系统。</p>
<p>对应的菜单系统有如下函数：</p>
<ol>
<li>查看目录函数：<code>ShowDir()</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> exist = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************目录***********************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前目录下文件有:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(menuitem[i].FileName)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %s %dB\n"</span>,index,menuitem[i].FileName,filedescriptor[menuitem[i].FileDescriptorNum].Length);</span><br><span class="line">            exist++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"一共存在%d个文件\n"</span>,exist);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************************************\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$可以看到这个查看目录函数遍历目录项数组，打印所有非空目录项 内容，包括文件名和文件大小，最后统计出一共存在多少个文件。</p>
<ol>
<li>打印位图：<code>ShowBitMap()</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowBitMap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n****************位图**********************\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前的磁盘使用情况如下(Y表示使用，N表示未使用)\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d号柱面磁盘信息如下:\n"</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   区:0 1 2 3 4 5 6 7 8 9\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"头\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t:"</span>,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=i*H*B+j*B+k;</span><br><span class="line">                <span class="keyword">if</span>(t&lt;<span class="number">512</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>,ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t]);</span><br><span class="line">                    <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t] == <span class="string">'Y'</span>)</span><br><span class="line">                        used++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>,ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].Content[t<span class="number">-512</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(ldisk[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].Content[t] == <span class="string">'Y'</span>)</span><br><span class="line">                        used++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"总共使用%d个磁盘块，剩余%d个磁盘块空闲\n"</span>,used,(C*B*H-used));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"****************************************\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$这个函数的大部分代码在进行位图打印信息的排版，每个柱面为一页，每一页中每一行表示一个磁头，每一列表示一个扇区。最后统计出所有磁盘的使用占比。</p>
<ol>
<li>主菜单程序</li>
</ol>
<blockquote>
<p>由于整个函数代码太长，所以只展示核心代码，完整代码请查看github</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:ShowDir();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要创建的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        create(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要删除的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        destroy(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要打开的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        ReadFile(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">int</span> choice3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1. 增加内容\t2. 删除内容"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n请选择："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice3);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要修改的文件名:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        <span class="keyword">if</span>(choice3==<span class="number">1</span>)</span><br><span class="line">            ChangeFileAdd(filename);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choice3==<span class="number">2</span>)</span><br><span class="line">            ChangeFileDel(filename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ShowBitMap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要保存的文件名："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">        save(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\qquad$这个switch结构提供个8个选择，对应8个功能。</p>
<h2 id="五-文件系统测试"><a href="#五-文件系统测试" class="headerlink" title="五 文件系统测试"></a>五 文件系统测试</h2><p>$\qquad$IO系统、文件系统和菜单系统完成之后需要对文件系统进行测试，下面是测试的详细过程。</p>
<h3 id="5-1-测试概述"><a href="#5-1-测试概述" class="headerlink" title="5.1 测试概述"></a>5.1 测试概述</h3><p>$\qquad$测试部分分别测试IO系统、文件系统对应的功能，测试计划如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试名称</th>
<th style="text-align:center">测试描述</th>
<th style="text-align:center">被测试模块</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保存磁盘文件测试</td>
<td style="text-align:center">将当前磁盘信息存入二进制文件</td>
<td style="text-align:center">IO系统磁盘写入文件功能、菜单系统等</td>
</tr>
<tr>
<td style="text-align:center">读取磁盘文件测试</td>
<td style="text-align:center">从文件系统中读取磁盘文件，装载到磁盘系统中</td>
<td style="text-align:center">IO系统磁盘写入文件功能、菜单系统等</td>
</tr>
<tr>
<td style="text-align:center">目录查看测试</td>
<td style="text-align:center">查看当前目录中存在的所有文件</td>
<td style="text-align:center">文件系统目录模块、文件描述符模块；<br>菜单系统</td>
</tr>
<tr>
<td style="text-align:center">文件创建测试</td>
<td style="text-align:center">创建新的文件</td>
<td style="text-align:center">文件系统目录模块、文件系统用户接口</td>
</tr>
<tr>
<td style="text-align:center">文件删除测试</td>
<td style="text-align:center">删除已有(不存在)文件</td>
<td style="text-align:center">文件系统目录模块、文件系统用户接口</td>
</tr>
<tr>
<td style="text-align:center">打开文件测试</td>
<td style="text-align:center">打开并查看文件内容</td>
<td style="text-align:center">文件系统用户接口</td>
</tr>
<tr>
<td style="text-align:center">修改文件测试</td>
<td style="text-align:center">修改文件内容</td>
<td style="text-align:center">文件系统目录模块、文件系统用户接口，IO系统</td>
</tr>
<tr>
<td style="text-align:center">查看位图测试</td>
<td style="text-align:center">查看当前磁盘位图信息</td>
<td style="text-align:center">IO系统位图模块，菜单系统</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-系统测试"><a href="#5-2-系统测试" class="headerlink" title="5.2 系统测试"></a>5.2 系统测试</h3><ol>
<li>保存磁盘文件测试 &amp; 文件创建测试</li>
</ol>
<ul>
<li>保存磁盘系统之前首先需要创建一个新的磁盘系统</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152201.jpg" width="400"></div>

<ul>
<li>在新的文件系统中创建文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152411.jpg" width="400"></div>

<blockquote>
<p>可以看到查看文件目录的时候看到刚刚创建的目录</p>
</blockquote>
<ul>
<li>给刚刚创建的文件添加一点内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152553.jpg" width="400"></div>

<blockquote>
<p>可以看到添加了内容之后内容保存到文中去</p>
</blockquote>
<ul>
<li>再次查看目录</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152726.jpg" width="400"></div>

<p>可以看到文件的长度确实发生了变化</p>
<ul>
<li>保存磁盘文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-152830.jpg" width="400"></div>

<blockquote>
<p>将磁盘系统保存到test.dat中去</p>
</blockquote>
<ul>
<li>为了验证刚刚的磁盘信息确实保存了下来，使用xxd工具查看test.dat文件的内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153038.jpg" width="400"></div>

<blockquote>
<p>可以看到test.dat中前面是位图信息，共占用15个磁盘块，标志位’Y’,其他所有磁盘块状态为空闲，标志位’N’</p>
</blockquote>
<ul>
<li>再检索刚刚创建的文件是否存在</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153234.jpg" width="400"></div>

<blockquote>
<p>可以看到检索’Hello’和文件名’test’的时候都有对应内容，说明磁盘信息缺失保存了下来</p>
</blockquote>
<ol>
<li>读取磁盘文件测试 &amp; 目录查看测试 &amp; 打开文件测试</li>
</ol>
<ul>
<li>打开上面测试中保存的<code>test.dat</code>文件</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153515.jpg" width="400"></div>

<blockquote>
<p>可以看到磁盘信息全部恢复了</p>
</blockquote>
<ul>
<li>打开文件内容具体查看一下，内容是否存在变化</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153724.jpg" width="400"></div>

<blockquote>
<p>可以看到文件内容没有发生改变</p>
</blockquote>
<ol>
<li>文件删除测试</li>
</ol>
<ul>
<li>为了便于进行文件删除测试，首先先创建一个文件<code>test2.txt</code></li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-153946.jpg" width="400"></div>

<ul>
<li>删除文件<code>test2.txt</code></li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154041.jpg" width="400"></div>

<ol>
<li>修改文件测试</li>
</ol>
<p>$\qquad$修改文件测时候分为在原有文件的基础上增加内容和删除内容，我们这在<code>test.txt</code>的基础上进行增加和删除操作</p>
<ul>
<li>在<code>test.txt</code>上增加内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154448.jpg" width="400"></div>

<blockquote>
<p>可以看到在指定位置增加了指定的内容</p>
</blockquote>
<ul>
<li>在<code>test.txt</code>删除内容</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-154628.jpg" width="400"></div>

<blockquote>
<p>可以看到指定位置的指定内容被删除了</p>
</blockquote>
<ol>
<li>查看位图测试</li>
</ol>
<ul>
<li>文件系统在初始化之后应该有15个磁盘块被占用，其中2个用于存储位图，12个用于存储文件描述符，1个用于存储目录</li>
</ul>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155003.jpg" width="400"></div>

<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155027.jpg" width="400"></div>

<blockquote>
<p>可以看到0号柱面的磁盘位图信息如上所示,总共使用14个磁盘块，其他全部空闲</p>
</blockquote>
<ul>
<li>增加一个文件之后，查看磁盘位图</li>
</ul>
<p>$\qquad$增加文件之后，当文件内容小于一个磁盘块大小时，暂时只分配一个磁盘块，所以应该只占用前个磁盘块</p>
<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155232.jpg" width="400"></div>

<div align="center"><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-06-14-155252.jpg" width="400"></div>

<h2 id="六-实验总结"><a href="#六-实验总结" class="headerlink" title="六 实验总结"></a>六 实验总结</h2><p>$\qquad$通过本次实验收获到了许多的东西，也许到了很多知识。实验之前，看完整个实验要求之后没有一个整体的思路就开始编写程序，导致后期的时候很多地方考虑不够全面，各个系统中函数组织混乱，整个构架不够完整，本次实验收获到的第一点就是在进行实验之前一定要提前设计好实验的思路，最好做好整个概要设计；第二点收获就是对文件系统有了更加深刻的认知，实验从最底层的磁盘块开始模拟，一点一点到IO系统，再到文件系、目录等等，通过自己的实践更加深刻的了解了文件系统；最后一点 收获就是在编程能力上的收获，这次通过编写这个文件系统，再次巩固了自己对于C语言的掌握能力，并且了解到了以前所用的处理字符串的一系列函数的缺点，例如strcpy只能复制\0之前的内容，strcat只能连接两个字符换的可见内容等等，学会了新的函数memcpy，通过这个函数实现将结构体以二进制的形式存储到字符串中和将字符串再恢复到结构体中。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/01/lab1/" class="post-title-link" itemprop="url">系统调用实验</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-01T00:00:00+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-12 17:33:41" itemprop="dateModified" datetime="2019-09-12T17:33:41+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统实验/" itemprop="url" rel="index"><span itemprop="name">操作系统实验</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>6.7k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>6 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验一实验报告"><a href="#实验一实验报告" class="headerlink" title="实验一实验报告"></a>实验一实验报告</h1><blockquote>
<p>孙汉武    16281047    安全1601</p>
</blockquote>
<p>[TOC]</p>
<h2 id="Task-1-系统调用实验"><a href="#Task-1-系统调用实验" class="headerlink" title="Task 1 系统调用实验"></a>Task 1 系统调用实验</h2><h3 id="1-1-直接调用和汇编中断调用系统调用getpid"><a href="#1-1-直接调用和汇编中断调用系统调用getpid" class="headerlink" title="1.1 直接调用和汇编中断调用系统调用getpid"></a>1.1 直接调用和汇编中断调用系统调用getpid</h3><h4 id="C语言直接调用"><a href="#C语言直接调用" class="headerlink" title="C语言直接调用"></a>C语言直接调用</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>getpid_c.c</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = getpid();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源代码，得到可执行文件getpid_c</li>
<li>执行可执行文件，得到程序的pid</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171700.jpg" width="600"></p>
</li>
<li><p>查看getpid的系统调用号</p>
<p>64位Linux系统的系统调用列表保存在/usr/include/asm/unistd_64.h（32位在unistd_32.h）,查看该文件可得到<strong>getpid的系统调用号为39（32位系统的系统调用号为20）</strong></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171717.jpg" width="600"></p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171721.jpg" width="600"></p>
<p>通过上图可以看出，在64位系统中，有两套系统调用号的宏定义，除了64位正常的系统调用号表之外，还有一套用于向下兼容32位系统。</p>
<p>在Linux(debian)中，/usr/include/asm中有两个h文件，分别是unistd_32.h和unistd_64.这两个头文件中保存着系统调用号的宏定义， 当在程序代码中用到系统调用时，编译器会将上面提到的宏展开，展开后的代码实际上是将系统调用号放入ax后移用int 0x80使处理器转向系统调用入口，然后查找系统调用表，进而由内核调用真正的功能函数。 通过汇编代码可以看到中断向量号是0x80,而0x14是指系统调用号，在32位系统中，getpid系统调用号为20，所以是16进制的0x14，而64位系统的getpid的系统调用号为39.</p>
</li>
<li><p>系统调用号跟操作系统的位数(32或64)和不同的发行版本(debian和Ubuntu)有关，例如Ubuntu 64位机器上getpid的系统调用号是172，而网上查到Linux内核64位为39，32位为20。 出现不一致的原因是，在Linux64位系统中，对32位程序进行了兼容操作。之前的32位机中，系统通过开放0x80搭配系统调用号来实现用户程序使用系统调用功能。但在64位机中，已经不使用int 0x80作为触发系统调用的机制了，而使用syscall指令来触发。但为了保持兼容性，系统仍然支持int 0x80进行‘32位’风格的调用。自然我们的汇编代码使用20这个系统调用号，依然可以正确运行在64位机器上。</p>
</li>
</ol>
<h4 id="汇编中断调用"><a href="#汇编中断调用" class="headerlink" title="汇编中断调用"></a>汇编中断调用</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>getpid_asm.c</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">            <span class="keyword">pid_t</span> pid;  </span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl $0x14,%%eax\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"int $0x80\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl %%eax,%0\n\t"</span>  </span></span></span><br><span class="line"><span class="function"><span class="params">             :<span class="string">"=m"</span>(pid)  </span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" current PID is : %u\n"</span>,pid);  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源码，得到可执行文件getpid_asm</li>
<li>执行可执行文件，得到程序的pid</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171732.jpg" width="600"></p>
</li>
<li><p>getpid的中断向量号</p>
<p>在汇编代码<code>int $0x80\n\t</code>可以看到getpid的<strong>中断向量号为0x80</strong></p>
</li>
</ol>
<h3 id="1-2-习题1-13"><a href="#1-2-习题1-13" class="headerlink" title="1.2 习题1.13"></a>1.2 习题1.13</h3><h4 id="使用C语言"><a href="#使用C语言" class="headerlink" title="使用C语言"></a>使用C语言</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>print_c.c</code>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译源码，得到可执行文件print_c</li>
<li>执行文件，屏幕打印Hello World</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171737.jpg" width="600"></p>
</li>
</ol>
<h4 id="使用汇编"><a href="#使用汇编" class="headerlink" title="使用汇编"></a>使用汇编</h4><ol>
<li><p>实验步骤</p>
<ul>
<li>源代码<code>print_asm.asm</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">section data</span><br><span class="line">msg db &quot;Hello World&quot;,0xA</span><br><span class="line">len equ $-msg</span><br><span class="line">section .text</span><br><span class="line">	global _start</span><br><span class="line">_start:</span><br><span class="line">	mov eax,4</span><br><span class="line">	mov ebx,1</span><br><span class="line">	mov ecx,msg</span><br><span class="line">	mov edx,len</span><br><span class="line">	int 0x80</span><br><span class="line">	mov eax,1</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	int 0x80</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编源码，得到对象文件print_asm.o</li>
<li>链接得到可执行文件print_asm</li>
<li>执行可执行文件print_asm,屏幕打印Hello World</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171743.jpg" width="600"></p>
</li>
</ol>
<h3 id="1-3-阅读pintos源码"><a href="#1-3-阅读pintos源码" class="headerlink" title="1.3 阅读pintos源码"></a>1.3 阅读pintos源码</h3><p>​    pintos中关于系统调用的源码以下部分。下面分别介绍他们各自的作用：</p>
<ol>
<li><p><code>/src/lib/user/syscall.c</code></p>
<ul>
<li>这个文件中以宏定义的形式定义了四种系统调用的方式，分别是不传递参数、传递一个参数、传递两个参数、传递三个参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall0(NUMBER) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall1(NUMBER, ARG0) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall2(NUMBER, ARG0, ARG1) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall3(NUMBER, ARG0, ARG1, ARG2) ...</span></span><br></pre></td></tr></table></figure>
<p>四个系统调用方式的中断向量号均为0x30.</p>
<ul>
<li>定义了20种系统调用函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">halt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function">pid_t <span class="title">exec</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait</span> <span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">create</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> initial_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filesize</span> <span class="params">(<span class="keyword">int</span> fd)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buffer, <span class="keyword">unsigned</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">unsigned</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seek</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> position)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">tell</span> <span class="params">(<span class="keyword">int</span> fd)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">mapid_t</span> mmap (<span class="keyword">int</span> fd, <span class="keyword">void</span> *addr);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">munmap</span> <span class="params">(<span class="keyword">mapid_t</span> mapid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chdir</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mkdir</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readdir</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> name[READDIR_MAX_LEN + <span class="number">1</span>])</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdir</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inumber</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的系统调用在下面的头文件中都有对应的系统调用号</p>
</li>
<li><p><code>/src/lib/syscallnr.h</code></p>
<p>这个文件中定义了系统调用列表，通过枚举类型定义了系统调用号</p>
<p>具体如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171749.jpg" width="600"></p>
</li>
<li><p><code>src/userprog/syscall.c</code></p>
<p>这个文件中只有两个函数<code>syscall_init</code>和<code>syscall_handler</code>,其中<code>syscall_init</code>是负责系统调用初始化工作的，<code>syscall_handler</code>是负责处理系统调用的</p>
<ul>
<li><p><code>syscall_init</code>函数</p>
<p>这个函数内部调用了<code>intr_register_int</code>函数，用于注册软中断从而调用系统调用处理函数</p>
</li>
</ul>
</li>
<li><p>下面是pintos系统调用的完整流程图</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171754.jpg" width="300"></p>
</li>
</ol>
<h2 id="Task-2-并发实验"><a href="#Task-2-并发实验" class="headerlink" title="Task 2 并发实验"></a>Task 2 并发实验</h2><h3 id="2-1-实验步骤"><a href="#2-1-实验步骤" class="headerlink" title="2.1 实验步骤"></a>2.1 实验步骤</h3><ol>
<li><p>编写<code>cpu.c</code>程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage:cpu&lt;string&gt;\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *str=argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码cpu.c，得到可执行文件cpu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc cpu.c -o cpu</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行cpu程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cpu A &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D</span><br></pre></td></tr></table></figure>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171801.jpg" width="600"></p>
</li>
<li><p>程序功能解释：</p>
<p>该程序的接受且仅能接受一个参数，当正确接受到参数的时候打印该参数，没有正确接受参数的时候，通过打印标准错误输出提示用户正确输入参数。</p>
</li>
</ol>
<h3 id="2-2-实验结果"><a href="#2-2-实验结果" class="headerlink" title="2.2 实验结果"></a>2.2 实验结果</h3><p>通过上面的实验可以观察到四个进程的运行顺序并没有规律。对于这种现象的解释如下：</p>
<ul>
<li>现代操作系统中进程的运行都是并发实现的，并不是像以前的单道批处理的操作系统那样，总是按照进程进入内存的先后顺序来执行，因此进程的运行的顺序并没有规律。</li>
<li>现代CPU一般都是多核CUP（我的电脑是四核），因此实验中的四个进程可能也不是简单的在一个CPU中并发，而有可能是在多个CPU核心中并行运行，也有可能某两个进程在一个CPU核心中并发运行，和其他的进程在不同的CPU核心中并行运行。所以进程的运行顺序并没有特别的规律。</li>
</ul>
<h2 id="Task-3-内存分配实验"><a href="#Task-3-内存分配实验" class="headerlink" title="Task 3 内存分配实验"></a>Task 3 内存分配实验</h2><h3 id="3-1-实验步骤"><a href="#3-1-实验步骤" class="headerlink" title="3.1 实验步骤"></a>3.1 实验步骤</h3><ol>
<li><p>编写<code>mem.c</code>程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	assert(p!=<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(%d) address pointed to by p: %p\n"</span>,getpid(),p);</span><br><span class="line">	*p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		*p=*p+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d) p: %d\n"</span>,getpid(),*p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码<code>mem.c</code>，得到可执行程序<code>mem</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mem.c -o mem</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行mem程序</p>
<ul>
<li>测试一：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171809.jpg" width="600"></p>
<ul>
<li>测试二：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171812.jpg" width="600"></p>
<ul>
<li>测试三：</li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171818.jpg" width="600"></p>
</li>
</ol>
<ol>
<li><p>程序功能解释</p>
<p>mem程序的功能是首先申请一个int大小的内存地址，并打印进程号和内存地址。之后就是对该内存地址保存的值进行循环累加操作</p>
</li>
</ol>
<h3 id="3-2-实验结果与结论"><a href="#3-2-实验结果与结论" class="headerlink" title="3.2 实验结果与结论"></a>3.2 实验结果与结论</h3><ol>
<li><p>实验现象</p>
<p>通过内存分配实验可以观察到如下现象：</p>
<ul>
<li>两个进程申请分配的内存地址有时一样，有时不一样，但是大概率出现的是不一样的。</li>
<li>对于每个进程而言，每个进程一直在该分配的内存空间进行累加操作，并且两个进程之间没有相互影响。</li>
<li>关闭地址空间随机化之后会发现每次执行两个进程申请的地址是相同的。</li>
</ul>
</li>
<li><p>原理解释</p>
<ul>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。进程需要用页表来记录哪些数据在物理地址，哪些不在，如果在的话在哪。</li>
<li>printf函数中%p打印的是虚拟地址</li>
<li>当关闭了地址空间随机化之后，在每个进程相当于有4G的独立虚拟内存，由于每个进程的程序是一模一样的，所以分配的地址肯定也一样。如果在申请的话应该就是顺序分配了。</li>
</ul>
</li>
<li><p>现象解释</p>
<p>由于每个进程都会有独立的4G虚拟内存，所以每个进程的内存地址在分配的时候可能相同，也可能不同，因为两个虚拟的地址之间没有任何关联。由于每个进程的虚拟地址是独立于其他进程的，通过页表将虚拟地址转换为真实地址，不论两个进程申请的虚拟内存地址是否相同，真实的物理地址一定是不一样的，所以两个进程对地址上的数值操作都是独立的。</p>
<p>但是关闭地址空间随机化之后两个进程的操作是完全一样的，加上有没有地址空间随机化的干扰，所以地址就是相同的</p>
</li>
</ol>
<h2 id="Task-4-共享问题"><a href="#Task-4-共享问题" class="headerlink" title="Task 4 共享问题"></a>Task 4 共享问题</h2><h3 id="4-1-实验步骤"><a href="#4-1-实验步骤" class="headerlink" title="4.1 实验步骤"></a>4.1 实验步骤</h3><ol>
<li><p>编写程序<code>thread.c</code>,源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> loops;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage: thread &lt;value&gt;\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	loops=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Initial value: %d\n"</span>,counter);</span><br><span class="line">	pthread_create(&amp;p1,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Final value: %d\n"</span>,counter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译源码<code>thread.c</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o thread -lpthread thread.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行thread程序</p>
<ul>
<li><code>./thread 1000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171825.jpg" width="600"></p>
<ul>
<li><code>./thread 10000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171829.jpg" width="600"></p>
<ul>
<li><code>./thread_1 1000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171833.jpg" width="600"></p>
<ul>
<li><code>./thread_1 10000</code></li>
</ul>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171837.jpg" width="600"></p>
</li>
<li><p>程序功能解释</p>
<p>程序一个main进程下创建了两个线程，两个线程执行相同的操作，都是对loops变量进行自增操作。</p>
</li>
</ol>
<h3 id="4-2-实验结果与结论"><a href="#4-2-实验结果与结论" class="headerlink" title="4.2 实验结果与结论"></a>4.2 实验结果与结论</h3><ol>
<li><p>实验现象</p>
<p>可以看到当输入的参数比较小的时候，Final value等于Initial value的两倍，当输入的参数比较大的时候，Final value的值在Initial vlaue的一倍到两倍之间.并且在最后两个测试样例中可以看到两个线程操作的loops变量的内存地址是相同的。</p>
</li>
<li><p>原理解释</p>
<ul>
<li>由于两个线程在同一个进程中，并且访问操作的是共享的变量。如果每个线程对内存都是可读可写的话，就会发生读取脏数据的问题，即是线程A读取内存x的之后，对它进行+1，在线程A操作完成的数据写入x之前，线程B也读取了原来的数据，导致最终线程B写入的数据和A写入的一样，相当于两个线程只进行了一次操作。</li>
<li>为了解决上面所说的脏数据的问题，现代CPU一般采用了加锁的解决办法，通过加锁使另一个线程不能读取。</li>
<li>现代计算机都是多核心的，对于每个独立的CPU核心来说，都不会发生问题，但是不同CPU核心之间却依然有问题。</li>
</ul>
</li>
<li><p>现象解释</p>
<ul>
<li>当输入的参数比较小的时候，一个CPU的核心足够处理，就是单核CPU运行多线程，由于每个核心都有内存锁机制，所以计算结果没有错误</li>
<li>当输入的参数比较大的时候，使用多个CPU核心进行运算，就会发生读取脏数据的问题。</li>
</ul>
</li>
</ol>
<h2 id="5-实验疑问"><a href="#5-实验疑问" class="headerlink" title="5 实验疑问"></a>5 实验疑问</h2><ol>
<li><p>在Task3中，关闭了地址空间随机化之后，按照理论上将申请两个int的地址应该是连续的，所以我我就验证了一下，在原本的代码中申请两个int类型的地址，然后打印这两个地址，看这两个地址连不连续。代码如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171842.jpg" width="600"></p>
</li>
</ol>
<p>之后编译运行程序，结果如下：</p>
<p><img src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-04-29-171850.jpg" width="600"></p>
<p>发现地址并不是连续的，因此还有一下疑问：</p>
<ul>
<li>0x1fd5260这个地址指的是啥，就是每个进程的虚拟内存的地址吗？</li>
<li>我尝试过将int换成其他类型的，发现并没有发生变化，这是为啥呢？</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/ss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/09/11/ss/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-09-11 04:53:38" itemprop="dateCreated datePublished" datetime="2018-09-11T04:53:38+08:00">2018-09-11</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>218</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Ubuntu16-04服务器搭建ss服务"><a href="#Ubuntu16-04服务器搭建ss服务" class="headerlink" title="Ubuntu16.04服务器搭建ss服务"></a>Ubuntu16.04服务器搭建ss服务</h1><ol>
<li><p>安装unzip wget</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install unzip wget</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装shadowsocks</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ToyoDAdoubi/doubi/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">cd</span> ./master</span><br><span class="line">sudo chmod 777 ssr.sh</span><br><span class="line">sudo ./ssr.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装过程一路都有提示，十分简单</p>
</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/ss_err/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/09/11/ss_err/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-09-11 04:53:38" itemprop="dateCreated datePublished" datetime="2018-09-11T04:53:38+08:00">2018-09-11</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>15</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shadowsocks启动报错"><a href="#shadowsocks启动报错" class="headerlink" title="shadowsocks启动报错"></a>shadowsocks启动报错</h1>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/zsh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/09/11/zsh/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-09-11 04:53:38" itemprop="dateCreated datePublished" datetime="2018-09-11T04:53:38+08:00">2018-09-11</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>2.3k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>2 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Mac-OS下安装oh-my-zsh并配置主题和插件"><a href="#Linux-Mac-OS下安装oh-my-zsh并配置主题和插件" class="headerlink" title="Linux/Mac OS下安装oh my zsh并配置主题和插件"></a>Linux/Mac OS下安装oh my zsh并配置主题和插件</h1><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h2><ol>
<li><p>安装git 、zsh</p>
<ul>
<li>Linux(Ubuntu16.04)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh git</span><br></pre></td></tr></table></figure>
<ul>
<li>Mac OS</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先自行百度安装homebrew</span></span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装oh my zsh(两种系统命令相同)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题：vim ～/.zshrc</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到对应行改为</span></span><br><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>source ~/.zshrc</li>
</ul>
</li>
</ol>
<h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><ol>
<li><p>wd </p>
<ul>
<li>它的作用就是能够快速的切换到常用的目录。 ​            </li>
<li>我们用命令行时经常会遇到这样一种情况， 我们常用的目录就那么几个，而这些目录有时候会再很深的层级中。 使用 cd 命令在这些深层级目录中切换就比较耗费时间了。 ​            </li>
<li>例如 Nginx的wwwroot目录/usr/share/nginx/html  ,我们进入这个目录，输入wd add html   #这个html这个名称是可以随便取的. 下次再进入这个目录就可以直接输入 wd thml</li>
<li>wd用法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Usage: wd [command] [point]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    add &lt;point&gt;     Adds the current working directory to your warp points</span><br><span class="line">    add             Adds the current working directory to your warp points with current directory&apos;s name</span><br><span class="line">    add! &lt;point&gt;    Overwrites existing warp point</span><br><span class="line">    add!            Overwrites existing warp point with current directory&apos;s name</span><br><span class="line">    rm &lt;point&gt;      Removes the given warp point</span><br><span class="line">    rm              Removes the given warp point with current directory&apos;s name</span><br><span class="line">    show &lt;point&gt;    Print path to given warp point</span><br><span class="line">    show            Print warp points to current directory</span><br><span class="line">    list            Print all stored warp points</span><br><span class="line">    ls  &lt;point&gt;     Show files from given warp point (ls)</span><br><span class="line">    path &lt;point&gt;    Show the path to given warp point (pwd)</span><br><span class="line">    clean!          Remove points warping to nonexistent directories</span><br><span class="line"></span><br><span class="line">    -v | --version  Print version</span><br><span class="line">    -d | --debug    Exit after execution with exit codes (for testing)</span><br><span class="line">    -c | --config   Specify config file (default ~/.warprc)</span><br><span class="line">    -q | --quiet    Suppress all output</span><br><span class="line"></span><br><span class="line">    help            Show this extremely helpful text</span><br></pre></td></tr></table></figure>
</li>
<li><p>sudo</p>
<ul>
<li>连按两次Esc添加或去掉sudo</li>
</ul>
</li>
<li><p>zsh-syntax-highlighting ​    #高亮可用命令</p>
<ol>
<li><p>Linux</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mac OS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>zsh-autosuggestions ​    #记录上一条命令，并自动建议</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
</li>
</ol>
<ul>
<li>在～/.zshrc下配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">  wd</span><br><span class="line">  sudo</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后source ~/.zshrc</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/vsftp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunhanwu">
      <meta itemprop="description" content="Talk is cheap, show me the code!">
      <meta itemprop="image" content="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SunPages">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/09/11/vsftp/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-09-11 04:53:38" itemprop="dateCreated datePublished" datetime="2018-09-11T04:53:38+08:00">2018-09-11</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>606</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ubuntu16-04配置vsftp服务器"><a href="#ubuntu16-04配置vsftp服务器" class="headerlink" title="ubuntu16.04配置vsftp服务器"></a>ubuntu16.04配置vsftp服务器</h1><h2 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h2><ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 /etc/vsftp.conf</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许匿名用户和本地用户登录，本地用户即/etc/passwd中的用户</span></span><br><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止全局写命令</span></span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止匿名用户上传和创建文件夹</span></span><br><span class="line">anon_upload_enable=NO</span><br><span class="line">anon_mkdir_write_enable=NO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只允许userlist的用户登录</span></span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：使用了vsftpd.user_list后，要在其中加入anonymous才能使用匿名用户登录，如以下内容，表示只有匿名用户和名为ftp的用户，以及本地用户ubuntu可以登录</span></span><br><span class="line">anonymous</span><br><span class="line">ftp</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建/etc/vsftpd.user_list文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><p>启动、重启、关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd start</span><br><span class="line">sudo /etc/init.d/vsftpd stop</span><br><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="http://ipic-picgo.oss-cn-beijing.aliyuncs.com/2019-09-12-logo.jpg"
      alt="sunhanwu">
  <p class="site-author-name" itemprop="name">sunhanwu</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code!</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">博客</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/sunhanwu" title="GitHub &rarr; https://github.com/sunhanwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:1965190613@qq.com" title="E-Mail &rarr; mailto:1965190613@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://jackyanghc.github.io/" title="https://jackyanghc.github.io/" rel="noopener" target="_blank">Jackyanghc</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://michel-liu.github.io/" title="https://michel-liu.github.io/" rel="noopener" target="_blank">Michel</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunhanwu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">123k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">1:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
